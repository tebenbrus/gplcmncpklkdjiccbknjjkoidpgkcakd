var Dr = Object.defineProperty, Ir = Object.defineProperties, Tr = Object.getOwnPropertyDescriptors, tr = Object.getOwnPropertySymbols, Fr = Object.prototype.hasOwnProperty, Or = Object.prototype.propertyIsEnumerable, sr = (Ae, J, I) => J in Ae ? Dr(Ae, J, { enumerable: !0, configurable: !0, writable: !0, value: I }) : Ae[J] = I, be = (Ae, J) => { for (var I in J || (J = {})) Fr.call(J, I) && sr(Ae, I, J[I]); if (tr) for (var I of tr(J)) Or.call(J, I) && sr(Ae, I, J[I]); return Ae }, nr = (Ae, J) => Ir(Ae, Tr(J)); (self.webpackChunkbrowser_extension = self.webpackChunkbrowser_extension || []).push([["default-projects_browser-extension_src_app_components_ext-header_ext-header_component_ts-proj-ac64ab"], { 7245: (Ae, J, I) => { "use strict"; var a, O; I.d(J, { Q: () => a }), (O = a || (a = {}))[O.Trial = 0] = "Trial", O[O.Subscription = 1] = "Subscription", O[O.Prepaid = 2] = "Prepaid", O[O.SharedAccount = 3] = "SharedAccount" }, 548: (Ae, J, I) => { "use strict"; I.d(J, { j: () => O }); var a = I(4001); class O { constructor() { this.powers = [{ suffix: "B", value: Math.pow(10, 9) }, { suffix: "M", value: Math.pow(10, 6) }, { suffix: "K", value: Math.pow(10, 3) }] } transform(o, v = 1) { if (!o || isNaN(o)) return o; v = Math.min(Math.max(v, 0), 3); const y = Math.abs(o), _ = o < 0; let x = Math.pow(10, v); const F = this.powers.find(ce => y >= ce.value); let te = y, oe = ""; return F && (te > 1e5 && te < 1e6 && (x = 1), te = y / F.value, F.value > 100 && (te = Math.floor(10 * te) / 10), te = Math.trunc(te * x) / x, oe = F.suffix), (_ ? "-" : "") + te + oe } } O.\u0275fac = function (o) { return new (o || O) }, O.\u0275pipe = a.Yjl({ name: "numeral", type: O, pure: !0 }) }, 3586: Ae => { Ae.exports = function () { return !!("undefined" != typeof window && null !== window && ("(-webkit-min-device-pixel-ratio: 1.25), (min--moz-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5/4), (min-resolution: 1.25dppx)", window.devicePixelRatio > 1.25 || window.matchMedia && window.matchMedia("(-webkit-min-device-pixel-ratio: 1.25), (min--moz-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5/4), (min-resolution: 1.25dppx)").matches)) } }, 7305: (Ae, J, I) => { "use strict"; I.d(J, { Ao: () => W, Fx: () => de }); var a = I(4001), O = I(8267), k = I(3586), o = I.n(k), v = I(3657), y = I(3981), _ = I(5191), x = I(5308); var te = I(2014); function oe(V, M) { if (1 & V) { const L = a.EpF(); a.TgZ(0, "img", 3), a.NdJ("error", function (Ue) { return a.CHM(L), a.oxw().fetchAvatarSource(Ue) }), a.qZA() } if (2 & V) { const L = a.oxw(); a.Q6J("src", L.avatarSrc, a.LSH)("width", L.size)("height", L.size)("ngStyle", L.avatarStyle) } } function ce(V, M) { if (1 & V && (a.TgZ(0, "div", 5), a._uU(1), a.qZA()), 2 & V) { const L = a.oxw(2); a.Q6J("ngStyle", L.avatarStyle), a.xp6(1), a.hij(" ", L.avatarText, " ") } } function he(V, M) { if (1 & V && a.YNc(0, ce, 2, 2, "div", 4), 2 & V) { const L = a.oxw(); a.Q6J("ngIf", L.avatarText) } } class De { constructor(M) { this.sourceId = M } } const q = { FACEBOOK: "facebook", GOOGLE: "google", TWITTER: "twitter", VKONTAKTE: "vkontakte", SKYPE: "skype", GRAVATAR: "gravatar", GITHUB: "github", CUSTOM: "custom", INITIALS: "initials", VALUE: "value" }; class tt { constructor(M) { this.sourceId = M, this.sourceType = q.FACEBOOK } getAvatar(M) { return `https://graph.facebook.com/${this.sourceId}/picture?width=${M}&height=${M}` } } class Le { constructor(M) { this.sourceId = M, this.sourceType = q.TWITTER } getAvatar(M) { const L = this.getImageSize(M); return `https://twitter.com/${this.sourceId}/profile_image?size=${L}` } getImageSize(M) { return M <= 24 ? "mini" : M <= 48 ? "normal" : M <= 73 ? "bigger" : "original" } } class st extends De { constructor(M) { super(M), this.sourceType = q.GOOGLE } getAvatar() { return `https://picasaweb.google.com/data/entry/api/user/${this.sourceId}?alt=json` } processResponse(M, L) { const pe = M.entry.gphoto$thumbnail.$t; if (pe) return pe.replace("s64", "s" + L) } } class We { constructor(M) { this.sourceId = M, this.sourceType = q.CUSTOM } getAvatar() { return this.sourceId } } class ze { constructor(M) { this.sourceId = M, this.sourceType = q.INITIALS } getAvatar(M) { return this.getInitials(this.sourceId, M) } getInitials(M, L) { if (!(M = M ? M.trim() : null)) return ""; const pe = M.split(" "); return L && L < pe.length ? this.constructInitials(pe.slice(0, L)) : this.constructInitials(pe) } constructInitials(M) { return M && M.length ? M.filter(L => L && L.length > 0).map(L => L[0].toUpperCase()).join("") : "" } } class bt { constructor(M) { this.value = M, this.sourceType = q.GRAVATAR, this.sourceId = M.match("^[a-f0-9]{32}$") ? M : v.V.hashStr(M).toString() } getAvatar(M) { const L = o()() ? 2 * M : M; return `https://secure.gravatar.com/avatar/${this.sourceId}?s=${L}&d=404` } } class Q { constructor(M) { this.sourceId = M, this.sourceType = q.SKYPE } getAvatar() { return `https://api.skype.com/users/${this.sourceId}/profile/avatar` } } class fe { constructor(M) { this.sourceId = M, this.sourceType = q.VALUE } getAvatar() { return this.sourceId } } class Me extends De { constructor(M) { super(M), this.sourceType = q.VKONTAKTE } getAvatar(M) { const L = this.getImageSize(M); return `https://api.vk.com/method/users.get?user_id=${this.sourceId}&v=5.8&fields=${L}` } processResponse(M) { const L = Object.keys(M.response[0]).pop(); return M.response[0][L] } getImageSize(M) { return M <= 50 ? "photo_50" : M <= 100 ? "photo_100" : M <= 200 ? "photo_200" : "photo_max" } } class j extends De { constructor(M) { super(M), this.sourceType = q.GITHUB } getAvatar() { return `https://api.github.com/users/${this.sourceId}` } processResponse(M, L) { return L ? `${M.avatar_url}&s=${L}` : M.avatar_url } } class G { constructor() { this.sources = {}, this.sources[q.FACEBOOK] = tt, this.sources[q.TWITTER] = Le, this.sources[q.GOOGLE] = st, this.sources[q.SKYPE] = Q, this.sources[q.GRAVATAR] = bt, this.sources[q.CUSTOM] = We, this.sources[q.INITIALS] = ze, this.sources[q.VALUE] = fe, this.sources[q.VKONTAKTE] = Me, this.sources[q.GITHUB] = j } newInstance(M, L) { return new this.sources[M](L) } } G.\u0275fac = function (M) { return new (M || G) }, G.\u0275prov = a.Yz7({ token: G, factory: G.\u0275fac }), G.ctorParameters = () => []; const P = new a.OlP("avatar.config"); class se { constructor(M) { this.userConfig = M } getAvatarSources(M) { if (this.userConfig && this.userConfig.sourcePriorityOrder && this.userConfig.sourcePriorityOrder.length) { const pe = [...new Set(this.userConfig.sourcePriorityOrder)].filter(Ue => M.includes(Ue)); return [...pe, ...M.filter(Ue => !pe.includes(Ue))] } return M } getAvatarColors(M) { return this.userConfig && this.userConfig.colors && this.userConfig.colors.length && this.userConfig.colors || M } } se.\u0275fac = function (M) { return new (M || se)(a.LFG(P, 8)) }, se.\u0275prov = a.Yz7({ token: se, factory: se.\u0275fac }), se.ctorParameters = () => [{ type: void 0, decorators: [{ type: a.FiY }, { type: a.tBr, args: [P] }] }]; const ee = [q.FACEBOOK, q.GOOGLE, q.TWITTER, q.VKONTAKTE, q.SKYPE, q.GRAVATAR, q.GITHUB, q.CUSTOM, q.INITIALS, q.VALUE], gt = ["#1abc9c", "#3498db", "#f1c40f", "#8e44ad", "#e74c3c", "#d35400", "#2c3e50", "#7f8c8d"]; class N { constructor(M, L) { this.http = M, this.avatarConfigService = L, this.avatarSources = ee, this.avatarColors = gt, this.overrideAvatarSources(), this.overrideAvatarColors() } fetchAvatar(M) { return this.http.get(M) } getRandomColor(M) { if (!M) return "transparent"; const L = this.calculateAsciiCode(M); return this.avatarColors[L % this.avatarColors.length] } copmareSources(M, L) { return this.getSourcePriority(M) - this.getSourcePriority(L) } isSource(M) { return this.avatarSources.includes(M) } isTextAvatar(M) { return [q.INITIALS, q.VALUE].includes(M) } overrideAvatarSources() { this.avatarSources = this.avatarConfigService.getAvatarSources(ee) } overrideAvatarColors() { this.avatarColors = this.avatarConfigService.getAvatarColors(gt) } calculateAsciiCode(M) { return M.split("").map(L => L.charCodeAt(0)).reduce((L, pe) => L + pe) } getSourcePriority(M) { return this.avatarSources.indexOf(M) } } N.\u0275fac = function (M) { return new (M || N)(a.LFG(y.eN), a.LFG(se)) }, N.\u0275prov = a.Yz7({ token: N, factory: N.\u0275fac }), N.ctorParameters = () => [{ type: y.eN }, { type: se }]; class W { constructor(M, L, pe) { this.elementRef = M, this.sourceFactory = L, this.avatarService = pe, this.round = !0, this.size = 50, this.textSizeRatio = 3, this.fgColor = "#FFF", this.style = {}, this.cornerRadius = 0, this.clickOnAvatar = new a.vpe, this.isAlive = !0, this.avatarStyle = {}, this.hostStyle = {}, this.currentSource = 0, this.sources = Array() } onAvatarClicked() { this.clickOnAvatar.emit(this.sources[this.currentSource - 1]) } ngOnChanges(M) { for (const L in M) if (this.avatarService.isSource(L) && M[L].currentValue) { const pe = M[L].currentValue; this.addSource(q[L.toUpperCase()], pe) } this.initializeAvatar() } fetchAvatarSource(M) { const L = this.sources[this.currentSource]; !L || (this.avatarService.isTextAvatar(L.sourceType) ? (this.buildTextAvatar(L), this.avatarSrc = void 0) : this.buildImageAvatar(L), this.currentSource++) } ngOnDestroy() { this.isAlive = !1 } initializeAvatar() { this.currentSource = 0, this.sources.length > 0 && this.sources[this.currentSource] && (this.sortAvatarSources(), this.fetchAvatarSource(), this.hostStyle = { width: this.size + "px", height: this.size + "px" }) } sortAvatarSources() { this.sources.sort((M, L) => this.avatarService.copmareSources(M.sourceType, L.sourceType)) } buildTextAvatar(M) { this.avatarText = M.getAvatar(this.initialsSize), this.avatarStyle = this.getInitialsStyle(M.sourceId) } buildImageAvatar(M) { this.avatarStyle = this.getImageStyle(), M instanceof De ? this.fetchAndProcessAsyncAvatar(M) : this.avatarSrc = M.getAvatar(this.size) } getInitialsStyle(M) { return Object.assign({ textAlign: "center", borderRadius: this.round ? "100%" : this.cornerRadius + "px", border: this.borderColor ? "1px solid " + this.borderColor : "", textTransform: "uppercase", color: this.fgColor, backgroundColor: this.bgColor ? this.bgColor : this.avatarService.getRandomColor(M), font: Math.floor(this.size / this.textSizeRatio) + "px Helvetica, Arial, sans-serif", lineHeight: this.size + "px" }, this.style) } getImageStyle() { return Object.assign({ maxWidth: "100%", borderRadius: this.round ? "50%" : this.cornerRadius + "px", border: this.borderColor ? "1px solid " + this.borderColor : "", width: this.size, height: this.size }, this.style) } fetchAndProcessAsyncAvatar(M) { this.avatarService.fetchAvatar(M.getAvatar()).pipe(function (V, M = !1) { return (0, _.e)((L, pe) => { let Ue = 0; L.subscribe((0, x.x)(pe, Jt => { const Dt = V(Jt, Ue++); (Dt || M) && pe.next(Jt), !Dt && pe.complete() })) }) }(() => this.isAlive), (0, te.U)(L => M.processResponse(L, this.size))).subscribe(L => this.avatarSrc = L, L => { console.error(`ngx-avatar: error while fetching ${M.sourceType} avatar `) }) } addSource(M, L) { if (this.isSourceExist(M)) { const pe = this.sources.findIndex(Ue => Ue.sourceType === M); this.sources[pe].sourceId = L } else this.sources.push(this.sourceFactory.newInstance(M, L)) } isSourceExist(M) { return this.sources.map(L => L.sourceType).includes(M) } } W.\u0275fac = function (M) { return new (M || W)(a.Y36(a.SBq), a.Y36(G), a.Y36(N)) }, W.\u0275cmp = a.Xpm({ type: W, selectors: [["ngx-avatar"]], inputs: { round: "round", size: "size", textSizeRatio: "textSizeRatio", fgColor: "fgColor", style: "style", cornerRadius: "cornerRadius", bgColor: "bgColor", borderColor: "borderColor", facebook: ["facebookId", "facebook"], twitter: ["twitterId", "twitter"], google: ["googleId", "google"], vkontakte: ["vkontakteId", "vkontakte"], skype: ["skypeId", "skype"], gravatar: ["gravatarId", "gravatar"], github: ["githubId", "github"], custom: ["src", "custom"], initials: ["name", "initials"], value: "value", placeholder: "placeholder", initialsSize: "initialsSize" }, outputs: { clickOnAvatar: "clickOnAvatar" }, features: [a.TTD], decls: 4, vars: 3, consts: [[1, "avatar-container", 3, "ngStyle", "click"], ["class", "avatar-content", 3, "src", "width", "height", "ngStyle", "error", 4, "ngIf", "ngIfElse"], ["textAvatar", ""], [1, "avatar-content", 3, "src", "width", "height", "ngStyle", "error"], ["class", "avatar-content", 3, "ngStyle", 4, "ngIf"], [1, "avatar-content", 3, "ngStyle"]], template: function (M, L) { if (1 & M && (a.TgZ(0, "div", 0), a.NdJ("click", function () { return L.onAvatarClicked() }), a.YNc(1, oe, 1, 4, "img", 1), a.YNc(2, he, 1, 1, "ng-template", null, 2, a.W1O), a.qZA()), 2 & M) { const pe = a.MAs(3); a.Q6J("ngStyle", L.hostStyle), a.xp6(1), a.Q6J("ngIf", L.avatarSrc)("ngIfElse", pe) } }, directives: [O.PC, O.O5], styles: ["[_nghost-%COMP%] {\n        border-radius: '50%';\n      }"] }), W.ctorParameters = () => [{ type: a.SBq }, { type: G }, { type: N }], W.propDecorators = { round: [{ type: a.IIB }], size: [{ type: a.IIB }], textSizeRatio: [{ type: a.IIB }], bgColor: [{ type: a.IIB }], fgColor: [{ type: a.IIB }], borderColor: [{ type: a.IIB }], style: [{ type: a.IIB }], cornerRadius: [{ type: a.IIB }], facebook: [{ type: a.IIB, args: ["facebookId"] }], twitter: [{ type: a.IIB, args: ["twitterId"] }], google: [{ type: a.IIB, args: ["googleId"] }], vkontakte: [{ type: a.IIB, args: ["vkontakteId"] }], skype: [{ type: a.IIB, args: ["skypeId"] }], gravatar: [{ type: a.IIB, args: ["gravatarId"] }], github: [{ type: a.IIB, args: ["githubId"] }], custom: [{ type: a.IIB, args: ["src"] }], initials: [{ type: a.IIB, args: ["name"] }], value: [{ type: a.IIB, args: ["value"] }], placeholder: [{ type: a.IIB, args: ["placeholder"] }], initialsSize: [{ type: a.IIB, args: ["initialsSize"] }], clickOnAvatar: [{ type: a.r_U }] }; class de { static forRoot(M) { return { ngModule: de, providers: [{ provide: P, useValue: M || {} }] } } } de.\u0275fac = function (M) { return new (M || de) }, de.\u0275mod = a.oAB({ type: de }), de.\u0275inj = a.cJS({ providers: [G, N, se], imports: [[O.ez]] }) }, 1278: (Ae, J, I) => { "use strict"; I.d(J, { b: () => _ }); var a = I(4314); const k = new (I(3544).v)(a.o); var v = I(5191), y = I(5308); function _(x, F = k) { return (0, v.e)((te, oe) => { let ce = null, he = null, De = null; const q = () => { if (ce) { ce.unsubscribe(), ce = null; const Le = he; he = null, oe.next(Le) } }; function tt() { const Le = De + x, st = F.now(); if (st < Le) return ce = this.schedule(void 0, Le - st), void oe.add(ce); q() } te.subscribe((0, y.x)(oe, Le => { he = Le, De = F.now(), ce || (ce = F.schedule(tt, x), oe.add(ce)) }, () => { q(), oe.complete() }, void 0, () => { he = ce = null })) }) } }, 6567: (Ae, J, I) => { "use strict"; I.d(J, { R: () => v }); var a = I(5191), O = I(5308), k = I(3957), o = I(1074); function v(y) { return (0, a.e)((_, x) => { (0, k.Xf)(y).subscribe((0, O.x)(x, () => x.complete(), o.Z)), !x.closed && _.subscribe(x) }) } }, 4314: (Ae, J, I) => { "use strict"; I.d(J, { o: () => v }); var a = I(2270); class O extends a.w0 { constructor(_, x) { super() } schedule(_, x = 0) { return this } } const k = { setInterval(y, _, ...x) { const { delegate: F } = k; return (null == F ? void 0 : F.setInterval) ? F.setInterval(y, _, ...x) : setInterval(y, _, ...x) }, clearInterval(y) { const { delegate: _ } = k; return ((null == _ ? void 0 : _.clearInterval) || clearInterval)(y) }, delegate: void 0 }; var o = I(3241); class v extends O { constructor(_, x) { super(_, x), this.scheduler = _, this.work = x, this.pending = !1 } schedule(_, x = 0) { var F; if (this.closed) return this; this.state = _; const te = this.id, oe = this.scheduler; return null != te && (this.id = this.recycleAsyncId(oe, te, x)), this.pending = !0, this.delay = x, this.id = null !== (F = this.id) && void 0 !== F ? F : this.requestAsyncId(oe, this.id, x), this } requestAsyncId(_, x, F = 0) { return k.setInterval(_.flush.bind(_, this), F) } recycleAsyncId(_, x, F = 0) { if (null != F && this.delay === F && !1 === this.pending) return x; null != x && k.clearInterval(x) } execute(_, x) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const F = this._execute(_, x); if (F) return F; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(_, x) { let te, F = !1; try { this.work(_) } catch (oe) { F = !0, te = oe || new Error("Scheduled action threw falsy error") } if (F) return this.unsubscribe(), te } unsubscribe() { if (!this.closed) { const { id: _, scheduler: x } = this, { actions: F } = x; this.work = this.state = this.scheduler = null, this.pending = !1, (0, o.P)(F, this), null != _ && (this.id = this.recycleAsyncId(x, _, null)), this.delay = null, super.unsubscribe() } } } }, 3544: (Ae, J, I) => { "use strict"; I.d(J, { v: () => k }); const a = { now: () => (a.delegate || Date).now(), delegate: void 0 }; class O { constructor(v, y = O.now) { this.schedulerActionCtor = v, this.now = y } schedule(v, y = 0, _) { return new this.schedulerActionCtor(this, v).schedule(_, y) } } O.now = a.now; class k extends O { constructor(v, y = O.now) { super(v, y), this.actions = [], this._active = !1 } flush(v) { const { actions: y } = this; if (this._active) return void y.push(v); let _; this._active = !0; do { if (_ = v.execute(v.state, v.delay)) break } while (v = y.shift()); if (this._active = !1, _) { for (; v = y.shift();)v.unsubscribe(); throw _ } } } }, 3657: (Ae, J) => { "use strict"; var a = function () { function O() { this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start() } return O.hashStr = function (k, o) { return void 0 === o && (o = !1), this.onePassHasher.start().appendStr(k).end(o) }, O.hashAsciiStr = function (k, o) { return void 0 === o && (o = !1), this.onePassHasher.start().appendAsciiStr(k).end(o) }, O._hex = function (k) { var y, _, x, F, o = O.hexChars, v = O.hexOut; for (F = 0; F < 4; F += 1)for (_ = 8 * F, y = k[F], x = 0; x < 8; x += 2)v[_ + 1 + x] = o.charAt(15 & y), y >>>= 4, v[_ + 0 + x] = o.charAt(15 & y), y >>>= 4; return v.join("") }, O._md5cycle = function (k, o) { var v = k[0], y = k[1], _ = k[2], x = k[3]; y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & _ | ~y & x) + o[0] - 680876936 | 0) << 7 | v >>> 25) + y | 0) & y | ~v & _) + o[1] - 389564586 | 0) << 12 | x >>> 20) + v | 0) & v | ~x & y) + o[2] + 606105819 | 0) << 17 | _ >>> 15) + x | 0) & x | ~_ & v) + o[3] - 1044525330 | 0) << 22 | y >>> 10) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & _ | ~y & x) + o[4] - 176418897 | 0) << 7 | v >>> 25) + y | 0) & y | ~v & _) + o[5] + 1200080426 | 0) << 12 | x >>> 20) + v | 0) & v | ~x & y) + o[6] - 1473231341 | 0) << 17 | _ >>> 15) + x | 0) & x | ~_ & v) + o[7] - 45705983 | 0) << 22 | y >>> 10) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & _ | ~y & x) + o[8] + 1770035416 | 0) << 7 | v >>> 25) + y | 0) & y | ~v & _) + o[9] - 1958414417 | 0) << 12 | x >>> 20) + v | 0) & v | ~x & y) + o[10] - 42063 | 0) << 17 | _ >>> 15) + x | 0) & x | ~_ & v) + o[11] - 1990404162 | 0) << 22 | y >>> 10) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & _ | ~y & x) + o[12] + 1804603682 | 0) << 7 | v >>> 25) + y | 0) & y | ~v & _) + o[13] - 40341101 | 0) << 12 | x >>> 20) + v | 0) & v | ~x & y) + o[14] - 1502002290 | 0) << 17 | _ >>> 15) + x | 0) & x | ~_ & v) + o[15] + 1236535329 | 0) << 22 | y >>> 10) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & x | _ & ~x) + o[1] - 165796510 | 0) << 5 | v >>> 27) + y | 0) & _ | y & ~_) + o[6] - 1069501632 | 0) << 9 | x >>> 23) + v | 0) & y | v & ~y) + o[11] + 643717713 | 0) << 14 | _ >>> 18) + x | 0) & v | x & ~v) + o[0] - 373897302 | 0) << 20 | y >>> 12) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & x | _ & ~x) + o[5] - 701558691 | 0) << 5 | v >>> 27) + y | 0) & _ | y & ~_) + o[10] + 38016083 | 0) << 9 | x >>> 23) + v | 0) & y | v & ~y) + o[15] - 660478335 | 0) << 14 | _ >>> 18) + x | 0) & v | x & ~v) + o[4] - 405537848 | 0) << 20 | y >>> 12) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & x | _ & ~x) + o[9] + 568446438 | 0) << 5 | v >>> 27) + y | 0) & _ | y & ~_) + o[14] - 1019803690 | 0) << 9 | x >>> 23) + v | 0) & y | v & ~y) + o[3] - 187363961 | 0) << 14 | _ >>> 18) + x | 0) & v | x & ~v) + o[8] + 1163531501 | 0) << 20 | y >>> 12) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y & x | _ & ~x) + o[13] - 1444681467 | 0) << 5 | v >>> 27) + y | 0) & _ | y & ~_) + o[2] - 51403784 | 0) << 9 | x >>> 23) + v | 0) & y | v & ~y) + o[7] + 1735328473 | 0) << 14 | _ >>> 18) + x | 0) & v | x & ~v) + o[12] - 1926607734 | 0) << 20 | y >>> 12) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y ^ _ ^ x) + o[5] - 378558 | 0) << 4 | v >>> 28) + y | 0) ^ y ^ _) + o[8] - 2022574463 | 0) << 11 | x >>> 21) + v | 0) ^ v ^ y) + o[11] + 1839030562 | 0) << 16 | _ >>> 16) + x | 0) ^ x ^ v) + o[14] - 35309556 | 0) << 23 | y >>> 9) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y ^ _ ^ x) + o[1] - 1530992060 | 0) << 4 | v >>> 28) + y | 0) ^ y ^ _) + o[4] + 1272893353 | 0) << 11 | x >>> 21) + v | 0) ^ v ^ y) + o[7] - 155497632 | 0) << 16 | _ >>> 16) + x | 0) ^ x ^ v) + o[10] - 1094730640 | 0) << 23 | y >>> 9) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y ^ _ ^ x) + o[13] + 681279174 | 0) << 4 | v >>> 28) + y | 0) ^ y ^ _) + o[0] - 358537222 | 0) << 11 | x >>> 21) + v | 0) ^ v ^ y) + o[3] - 722521979 | 0) << 16 | _ >>> 16) + x | 0) ^ x ^ v) + o[6] + 76029189 | 0) << 23 | y >>> 9) + _ | 0, y = ((y += ((_ = ((_ += ((x = ((x += ((v = ((v += (y ^ _ ^ x) + o[9] - 640364487 | 0) << 4 | v >>> 28) + y | 0) ^ y ^ _) + o[12] - 421815835 | 0) << 11 | x >>> 21) + v | 0) ^ v ^ y) + o[15] + 530742520 | 0) << 16 | _ >>> 16) + x | 0) ^ x ^ v) + o[2] - 995338651 | 0) << 23 | y >>> 9) + _ | 0, y = ((y += ((x = ((x += (y ^ ((v = ((v += (_ ^ (y | ~x)) + o[0] - 198630844 | 0) << 6 | v >>> 26) + y | 0) | ~_)) + o[7] + 1126891415 | 0) << 10 | x >>> 22) + v | 0) ^ ((_ = ((_ += (v ^ (x | ~y)) + o[14] - 1416354905 | 0) << 15 | _ >>> 17) + x | 0) | ~v)) + o[5] - 57434055 | 0) << 21 | y >>> 11) + _ | 0, y = ((y += ((x = ((x += (y ^ ((v = ((v += (_ ^ (y | ~x)) + o[12] + 1700485571 | 0) << 6 | v >>> 26) + y | 0) | ~_)) + o[3] - 1894986606 | 0) << 10 | x >>> 22) + v | 0) ^ ((_ = ((_ += (v ^ (x | ~y)) + o[10] - 1051523 | 0) << 15 | _ >>> 17) + x | 0) | ~v)) + o[1] - 2054922799 | 0) << 21 | y >>> 11) + _ | 0, y = ((y += ((x = ((x += (y ^ ((v = ((v += (_ ^ (y | ~x)) + o[8] + 1873313359 | 0) << 6 | v >>> 26) + y | 0) | ~_)) + o[15] - 30611744 | 0) << 10 | x >>> 22) + v | 0) ^ ((_ = ((_ += (v ^ (x | ~y)) + o[6] - 1560198380 | 0) << 15 | _ >>> 17) + x | 0) | ~v)) + o[13] + 1309151649 | 0) << 21 | y >>> 11) + _ | 0, y = ((y += ((x = ((x += (y ^ ((v = ((v += (_ ^ (y | ~x)) + o[4] - 145523070 | 0) << 6 | v >>> 26) + y | 0) | ~_)) + o[11] - 1120210379 | 0) << 10 | x >>> 22) + v | 0) ^ ((_ = ((_ += (v ^ (x | ~y)) + o[2] + 718787259 | 0) << 15 | _ >>> 17) + x | 0) | ~v)) + o[9] - 343485551 | 0) << 21 | y >>> 11) + _ | 0, k[0] = v + k[0] | 0, k[1] = y + k[1] | 0, k[2] = _ + k[2] | 0, k[3] = x + k[3] | 0 }, O.prototype.start = function () { return this._dataLength = 0, this._bufferLength = 0, this._state.set(O.stateIdentity), this }, O.prototype.appendStr = function (k) { var _, x, o = this._buffer8, v = this._buffer32, y = this._bufferLength; for (x = 0; x < k.length; x += 1) { if ((_ = k.charCodeAt(x)) < 128) o[y++] = _; else if (_ < 2048) o[y++] = 192 + (_ >>> 6), o[y++] = 63 & _ | 128; else if (_ < 55296 || _ > 56319) o[y++] = 224 + (_ >>> 12), o[y++] = _ >>> 6 & 63 | 128, o[y++] = 63 & _ | 128; else { if ((_ = 1024 * (_ - 55296) + (k.charCodeAt(++x) - 56320) + 65536) > 1114111) throw new Error("Unicode standard supports code points up to U+10FFFF"); o[y++] = 240 + (_ >>> 18), o[y++] = _ >>> 12 & 63 | 128, o[y++] = _ >>> 6 & 63 | 128, o[y++] = 63 & _ | 128 } y >= 64 && (this._dataLength += 64, O._md5cycle(this._state, v), y -= 64, v[0] = v[16]) } return this._bufferLength = y, this }, O.prototype.appendAsciiStr = function (k) { for (var _, o = this._buffer8, v = this._buffer32, y = this._bufferLength, x = 0; ;) { for (_ = Math.min(k.length - x, 64 - y); _--;)o[y++] = k.charCodeAt(x++); if (y < 64) break; this._dataLength += 64, O._md5cycle(this._state, v), y = 0 } return this._bufferLength = y, this }, O.prototype.appendByteArray = function (k) { for (var _, o = this._buffer8, v = this._buffer32, y = this._bufferLength, x = 0; ;) { for (_ = Math.min(k.length - x, 64 - y); _--;)o[y++] = k[x++]; if (y < 64) break; this._dataLength += 64, O._md5cycle(this._state, v), y = 0 } return this._bufferLength = y, this }, O.prototype.getState = function () { var k = this, o = k._state; return { buffer: String.fromCharCode.apply(null, k._buffer8), buflen: k._bufferLength, length: k._dataLength, state: [o[0], o[1], o[2], o[3]] } }, O.prototype.setState = function (k) { var _, o = k.buffer, v = k.state, y = this._state; for (this._dataLength = k.length, this._bufferLength = k.buflen, y[0] = v[0], y[1] = v[1], y[2] = v[2], y[3] = v[3], _ = 0; _ < o.length; _ += 1)this._buffer8[_] = o.charCodeAt(_) }, O.prototype.end = function (k) { void 0 === k && (k = !1); var x, o = this._bufferLength, v = this._buffer8, y = this._buffer32, _ = 1 + (o >> 2); if (this._dataLength += o, v[o] = 128, v[o + 1] = v[o + 2] = v[o + 3] = 0, y.set(O.buffer32Identity.subarray(_), _), o > 55 && (O._md5cycle(this._state, y), y.set(O.buffer32Identity)), (x = 8 * this._dataLength) <= 4294967295) y[14] = x; else { var F = x.toString(16).match(/(.*?)(.{0,8})$/); if (null === F) return; var te = parseInt(F[2], 16), oe = parseInt(F[1], 16) || 0; y[14] = te, y[15] = oe } return O._md5cycle(this._state, y), k ? this._state : O._hex(this._state) }, O.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]), O.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), O.hexChars = "0123456789abcdef", O.hexOut = [], O.onePassHasher = new O, O }(); J.V = a, "5d41402abc4b2a76b9719d911017c592" !== a.hashStr("hello") && console.error("Md5 self test failed.") }, 6024: (Ae, J, I) => { "use strict"; I.d(J, { T: () => Me }); var a = I(4001), O = I(8806), k = I(8094), o = I(7245), v = I(7456), y = I(548), _ = I(8267), x = I(6048); function F(j, G) { if (1 & j && (a.TgZ(0, "div", 4), a.TgZ(1, "span"), a._uU(2), a.qZA(), a.qZA()), 2 & j) { const P = a.oxw(2); a.xp6(2), a.Oqu(P.userPlanType) } } function te(j, G) { 1 & j && a._UZ(0, "cls-spinner", 10) } function oe(j, G) { if (1 & j && (a.TgZ(0, "div", 5), a.TgZ(1, "div", 6), a.TgZ(2, "progress", 7), a._uU(3), a.qZA(), a.qZA(), a.YNc(4, te, 1, 0, "cls-spinner", 8), a.TgZ(5, "span", 9), a._uU(6), a.qZA(), a.qZA()), 2 & j) { const P = a.oxw(2); a.MGl("title", "", P.pagesLeft, " Credits left"), a.xp6(2), a.Q6J("value", P.pagesLeft)("max", P.planPages), a.xp6(1), a.hij(" ", P.pagesLeftAsString, " "), a.xp6(1), a.Q6J("ngIf", P.isLoading), a.xp6(2), a.hij(" ", P.pagesLeftAsString, " ") } } function ce(j, G) { if (1 & j && (a.TgZ(0, "div", 1), a.YNc(1, F, 3, 1, "div", 2), a.YNc(2, oe, 7, 6, "div", 3), a.qZA()), 2 & j) { const P = a.oxw(); a.xp6(1), a.Q6J("ngIf", P.canShowTag), a.xp6(1), a.Q6J("ngIf", P.canShowCredits) } } let he = class { constructor(G, P) { this._paymentService = G, this._numeralPipe = P, this.isLoading = !0 } get pagesLeftAsString() { return this._numeralPipe.transform(this.pagesLeft, 1) } get pagesLeftPercentage() { return this.pagesLeft / this.planPages * 100 } get userPlanType() { var G; switch (null === (G = this.userBalance) || void 0 === G ? void 0 : G.accountType) { case o.Q.Trial: return "Trial"; case o.Q.Prepaid: return "Prepaid"; case o.Q.SharedAccount: return "Org Member" } } get canShowCredits() { var G, P, se, ee; return ((null === (G = this.userBalance) || void 0 === G ? void 0 : G.accountType) == o.Q.Subscription || (null === (P = this.userBalance) || void 0 === P ? void 0 : P.accountType) == o.Q.Prepaid || (null === (se = this.userBalance) || void 0 === se ? void 0 : se.accountType) == o.Q.Trial) && 0 != (null === (ee = this.userBalance) || void 0 === ee ? void 0 : ee.current) } ngOnInit() { this._paymentService.userBalance$.pipe((0, k.t)(this)).subscribe(G => (0, O.mG)(this, void 0, void 0, function* () { G && (this.userBalance = G, this.pagesLeft = G.current, this.planPages = G.max, this._initSubscription(), this.isLoading = !1, document.documentElement.style.setProperty("--progress-bar-percentage", this.pagesLeftPercentage + "%"), this.pagesLeftPercentage < 15 ? document.documentElement.style.setProperty("--progress-bar-color", "#f44336") : document.documentElement.style.setProperty("--progress-bar-color", "#3f9af5")) })) } _initSubscription() { return (0, O.mG)(this, void 0, void 0, function* () { this.userBalance.accountType == o.Q.Subscription || this.userBalance.accountType == o.Q.Trial ? (this.canShowTag = !1, this.userBalance.accountType == o.Q.Subscription && (this.userSubscription = yield this._paymentService.getExtensionSubscriptionStateAsync())) : this.canShowTag = !0 }) } }; he.\u0275fac = function (G) { return new (G || he)(a.Y36(v.v), a.Y36(y.j)) }, he.\u0275cmp = a.Xpm({ type: he, selectors: [["app-user-plan"]], decls: 1, vars: 1, consts: [["class", "user-plan-container", 4, "ngIf"], [1, "user-plan-container"], ["class", "user-plan-tag-container", 4, "ngIf"], ["class", "progress-bar-container", "fxLayoutAlign", "center center", 3, "title", 4, "ngIf"], [1, "user-plan-tag-container"], ["fxLayoutAlign", "center center", 1, "progress-bar-container", 3, "title"], [1, "progress-bar"], ["min", "0", 3, "value", "max"], ["width", "20px", 4, "ngIf"], [1, "progress-bar-percentage"], ["width", "20px"]], template: function (G, P) { 1 & G && a.YNc(0, ce, 3, 2, "div", 0), 2 & G && a.Q6J("ngIf", !P.isLoading) }, directives: [_.O5, x.O], styles: ["[_ngcontent-%COMP%]:root{--progress-bar-percentage: 0%;--progress-bar-color: #3f9af5}.user-plan-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;align-items:center;justify-content:center;grid-gap:4px;gap:4px}.user-plan-container[_ngcontent-%COMP%]   .user-plan-tag-container[_ngcontent-%COMP%]{border-radius:16px;padding:4px 8px;display:flex;width:-moz-fit-content;width:fit-content;background-color:#3f9af533}.user-plan-container[_ngcontent-%COMP%]   .user-plan-tag-container[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:12px;color:#3f9af5;line-height:1.2}.user-plan-container[_ngcontent-%COMP%]   .progress-bar-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;position:relative;width:40px;height:40px}.user-plan-container[_ngcontent-%COMP%]   .progress-bar-container[_ngcontent-%COMP%]   .progress-bar[_ngcontent-%COMP%]{width:36px;height:36px;border-radius:50%;background:radial-gradient(closest-side,white 80%,transparent 80% 100%),conic-gradient(var(--progress-bar-color) var(--progress-bar-percentage),#ebf3f5 0)}.user-plan-container[_ngcontent-%COMP%]   .progress-bar-container[_ngcontent-%COMP%]   .progress-bar[_ngcontent-%COMP%]   progress[_ngcontent-%COMP%]{visibility:hidden;height:0;width:0}.user-plan-container[_ngcontent-%COMP%]   .progress-bar-container[_ngcontent-%COMP%]   .progress-bar-percentage[_ngcontent-%COMP%]{position:absolute;font-size:12px;color:#3f9af5}"] }), he = (0, O.gn)([(0, k.c)(void 0)], he); var q, j, De = I(2555); (j = q || (q = {}))[j.MyAccount = 0] = "MyAccount", j[j.Billing = 1] = "Billing", j[j.TermsOfUse = 2] = "TermsOfUse", j[j.HowDoWeKnow = 3] = "HowDoWeKnow", j[j.LogOut = 4] = "LogOut"; var tt = I(5936), Le = I(7305); const st = ["actionsMenu"]; function We(j, G) { if (1 & j && a._UZ(0, "ngx-avatar", 5), 2 & j) { const P = a.oxw(); a.Q6J("gravatarId", P.userEmail)("name", P.userEmail) } } function ze(j, G) { 1 & j && a._UZ(0, "cls-spinner", 6) } function bt(j, G) { if (1 & j) { const P = a.EpF(); a.ynx(0), a.TgZ(1, "a", 10), a.NdJ("click", function () { a.CHM(P); const ee = a.oxw(2); return ee.triggerMenuItemAction(ee.eUserMenuActions.MyAccount) }), a._UZ(2, "img", 16), a.TgZ(3, "span", 12), a._uU(4, "My Account"), a.qZA(), a.qZA(), a._UZ(5, "div", 13), a.BQk() } } function Q(j, G) { if (1 & j) { const P = a.EpF(); a.ynx(0), a.TgZ(1, "a", 10), a.NdJ("click", function () { a.CHM(P); const ee = a.oxw(2); return ee.triggerMenuItemAction(ee.eUserMenuActions.Billing) }), a._UZ(2, "img", 16), a.TgZ(3, "span", 12), a._uU(4, "Billing"), a.qZA(), a.qZA(), a._UZ(5, "div", 13), a.BQk() } } function fe(j, G) { if (1 & j) { const P = a.EpF(); a.TgZ(0, "div", 7, 8), a.YNc(2, bt, 6, 0, "ng-container", 9), a.TgZ(3, "a", 10), a.NdJ("click", function () { a.CHM(P); const ee = a.oxw(); return ee.triggerMenuItemAction(ee.eUserMenuActions.TermsOfUse) }), a._UZ(4, "img", 11), a.TgZ(5, "span", 12), a._uU(6, "Terms of use"), a.qZA(), a.qZA(), a._UZ(7, "div", 13), a.TgZ(8, "a", 10), a.NdJ("click", function () { a.CHM(P); const ee = a.oxw(); return ee.triggerMenuItemAction(ee.eUserMenuActions.HowDoWeKnow) }), a._UZ(9, "img", 14), a.TgZ(10, "span", 12), a._uU(11, "How do we know?"), a.qZA(), a.qZA(), a._UZ(12, "div", 13), a.YNc(13, Q, 6, 0, "ng-container", 9), a.TgZ(14, "a", 10), a.NdJ("click", function () { a.CHM(P); const ee = a.oxw(); return ee.triggerMenuItemAction(ee.eUserMenuActions.LogOut) }), a._UZ(15, "img", 15), a.TgZ(16, "span", 12), a._uU(17, "Log out"), a.qZA(), a.qZA(), a.qZA() } if (2 & j) { const P = a.oxw(); a.xp6(2), a.Q6J("ngIf", P.user && P.user.emailAddress), a.xp6(11), a.Q6J("ngIf", P.user && P.user.emailAddress && !P.isOrganizationMember) } } class Be { constructor(G) { this._authService = G, this.toggleMenu = !1, this.eUserMenuActions = q } get userEmail() { return this.user ? this.user.emailAddress ? this.user.emailAddress : "Guest" : "" } ngOnInit() { } triggerMenuItemAction(G) { return (0, O.mG)(this, void 0, void 0, function* () { let P; switch (G) { case q.MyAccount: P = `${De.N.identityWebsite}/personal-information`; break; case q.Billing: P = `${De.N.identityWebsite}/billing`; break; case q.TermsOfUse: P = "https://copyleaks.com/legal/termsofuse"; break; case q.HowDoWeKnow: P = "https://help.copyleaks.com/kb-search-results?term=Ai+Content+detector"; break; case q.LogOut: P = `${De.N.dashboardWebsite}/login-redirect?isLogout=true`, yield this._authService.logoutAsync(); break; default: return }chrome.tabs.create({ url: P }) }) } clickout(G) { var P, se, ee, gt; "menu-toggle-button" != (null === (ee = null === (se = null === (P = null == G ? void 0 : G.target.parentElement) || void 0 === P ? void 0 : P.parentElement) || void 0 === se ? void 0 : se.parentElement) || void 0 === ee ? void 0 : ee.id) && this.toggleMenu && ((null === (gt = this.actionsMenu) || void 0 === gt ? void 0 : gt.nativeElement.contains(G.target)) || (this.toggleMenu = !1)) } } Be.\u0275fac = function (G) { return new (G || Be)(a.Y36(tt.l)) }, Be.\u0275cmp = a.Xpm({ type: Be, selectors: [["app-user-menu"]], viewQuery: function (G, P) { if (1 & G && a.Gf(st, 5), 2 & G) { let se; a.iGM(se = a.CRH()) && (P.actionsMenu = se.first) } }, hostBindings: function (G, P) { 1 & G && a.NdJ("click", function (ee) { return P.clickout(ee) }, !1, a.evT) }, inputs: { user: "user", isOrganizationMember: "isOrganizationMember" }, decls: 5, vars: 3, consts: [[1, "user-menu-container"], ["id", "menu-toggle-button", 1, "user-avatar-btn", 3, "click"], ["size", "32", 3, "gravatarId", "name", 4, "ngIf"], ["width", "20px", 4, "ngIf"], ["class", "user-menu", 4, "ngIf"], ["size", "32", 3, "gravatarId", "name"], ["width", "20px"], [1, "user-menu"], ["actionsMenu", ""], [4, "ngIf"], [1, "menu-item", 3, "click"], ["src", "assets/icons/terms-of-use-icon.png"], [1, "menu-item-txt"], [1, "menu-item-divider"], ["src", "assets/icons/question-mark-icon.png", 2, "width", "14px", "margin-left", "1px"], ["src", "assets/icons/log-out-icon.png"], ["src", "assets/icons/my-account-icon.png"]], template: function (G, P) { 1 & G && (a.TgZ(0, "div", 0), a.TgZ(1, "button", 1), a.NdJ("click", function () { return P.toggleMenu = !0 }), a.YNc(2, We, 1, 2, "ngx-avatar", 2), a.YNc(3, ze, 1, 0, "cls-spinner", 3), a.qZA(), a.YNc(4, fe, 18, 2, "div", 4), a.qZA()), 2 & G && (a.xp6(2), a.Q6J("ngIf", P.userEmail), a.xp6(1), a.Q6J("ngIf", !P.user), a.xp6(1), a.Q6J("ngIf", P.toggleMenu)) }, directives: [_.O5, Le.Ao, x.O], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;justify-content:center}.user-menu-container[_ngcontent-%COMP%]{position:relative;height:32px}.user-menu-container[_ngcontent-%COMP%]   .user-avatar-btn[_ngcontent-%COMP%]{width:32px;height:32px;padding:0;cursor:pointer;border:none;background:none}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]{position:absolute;width:181px;right:0;top:40px;box-shadow:0 3px 6px #00000029;border-radius:8px;grid-gap:0px;gap:0px;background-color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]   .menu-item[_ngcontent-%COMP%]{background-color:#fff;cursor:pointer;display:flex;flex-direction:row;align-items:center;justify-content:flex-start;color:#000;width:100%;padding:8px 16px;box-sizing:border-box;text-decoration:none}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]   .menu-item[_ngcontent-%COMP%]   .menu-item-txt[_ngcontent-%COMP%]{font-size:14px;color:#040f21;font-weight:500;margin-left:16px}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]   .menu-item[_ngcontent-%COMP%]:first-of-type{border-radius:8px 8px 0 0}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]   .menu-item[_ngcontent-%COMP%]:last-of-type{border-radius:0 0 8px 8px}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]   .menu-item[_ngcontent-%COMP%]:hover{background-color:#f0f5f9}.user-menu-container[_ngcontent-%COMP%]   .user-menu[_ngcontent-%COMP%]   .menu-item-divider[_ngcontent-%COMP%]{border-top:1px solid #f0f5f9;width:80%}"] }); class Me { constructor() { } ngOnInit() { } goToLink() { chrome.tabs.create({ url: "https://college.neu.edu.ph/login/index.php" }) } } Me.\u0275fac = function (G) { return new (G || Me) }, Me.\u0275cmp = a.Xpm({ type: Me, selectors: [["app-ext-header"]], inputs: { user: "user", isOrganizationMember: "isOrganizationMember" }, decls: 9, vars: 2, consts: [[1, "header-container"], [1, "logo-title-container"], ["width", "175px", "height", "40px", "src", "assets/images/NeuLogo.jpg", "alt", "dashboard-logo", 2, "", "", 3, ""], [1, "title-container"], [1, "title"], [1, "user-info-container"], [3, "user", "isOrganizationMember"]], template: function (G, P) { 1 & G && (a.TgZ(0, "div", 0), a.TgZ(1, "div", 1), a.TgZ(2, "img", 2), a.NdJ("click", function () { return P.goToLink() }), a.qZA(), a.TgZ(3, "div", 3), a.TgZ(4, "span", 4), a._uU(5, "AI Content Detector"), a.qZA(), a.qZA(), a.qZA(), a.TgZ(6, "div", 5), a._UZ(7, "app-user-plan"), a._UZ(8, "app-user-menu", 6), a.qZA(), a.qZA()), 2 & G && (a.xp6(8), a.Q6J("user", P.user)("isOrganizationMember", P.isOrganizationMember)) }, directives: [he, Be], styles: [".header-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;place-content:center space-between}.header-container[_ngcontent-%COMP%]   .logo-title-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;place-content:center center;grid-gap:63px;gap:63px}.header-container[_ngcontent-%COMP%]   .logo-title-container[_ngcontent-%COMP%]   .title-container[_ngcontent-%COMP%]{display:flex;align-items:flex-start;justify-content:flex-start;flex-direction:row;grid-gap:10px;gap:10px;margin-top:2px}.header-container[_ngcontent-%COMP%]   .logo-title-container[_ngcontent-%COMP%]   .title-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-size:16px;color:#3f9af5;font-weight:610;line-height:2.2}.header-container[_ngcontent-%COMP%]   .logo-title-container[_ngcontent-%COMP%]   .title-container[_ngcontent-%COMP%]   .beta-tag[_ngcontent-%COMP%]{font-size:15px;color:#3f9af5}.header-container[_ngcontent-%COMP%]   .user-info-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;align-items:center;justify-content:center;grid-gap:8px;gap:8px}"] }) }, 7072: (Ae, J, I) => { "use strict"; I.d(J, { X: () => si }); var a = I(8267), O = I(7305), k = I(5658), o = I(4001); class v { } v.\u0275fac = function (s) { return new (s || v) }, v.\u0275mod = o.oAB({ type: v }), v.\u0275inj = o.cJS({ imports: [[a.ez, O.Fx, k.F]] }); var y = I(8824), _ = I(4635), x = I(3019), F = I(3238), te = I(4314); let ce, oe = 1; const he = {}; function De(l) { return l in he && (delete he[l], !0) } const q = { setImmediate(l) { const s = oe++; return he[s] = !0, ce || (ce = Promise.resolve()), ce.then(() => De(s) && l()), s }, clearImmediate(l) { De(l) } }, { setImmediate: Le, clearImmediate: st } = q, We = { setImmediate(...l) { const { delegate: s } = We; return ((null == s ? void 0 : s.setImmediate) || Le)(...l) }, clearImmediate(l) { const { delegate: s } = We; return ((null == s ? void 0 : s.clearImmediate) || st)(l) }, delegate: void 0 }; class ze extends te.o { constructor(s, i) { super(s, i), this.scheduler = s, this.work = i } requestAsyncId(s, i, d = 0) { return null !== d && d > 0 ? super.requestAsyncId(s, i, d) : (s.actions.push(this), s._scheduled || (s._scheduled = We.setImmediate(s.flush.bind(s, void 0)))) } recycleAsyncId(s, i, d = 0) { var f; if (null != d ? d > 0 : this.delay > 0) return super.recycleAsyncId(s, i, d); const { actions: w } = s; null != i && (null === (f = w[w.length - 1]) || void 0 === f ? void 0 : f.id) !== i && (We.clearImmediate(i), s._scheduled === i && (s._scheduled = void 0)) } } var bt = I(3544); class Q extends bt.v { flush(s) { this._active = !0; const i = this._scheduled; this._scheduled = void 0; const { actions: d } = this; let f; s = s || d.shift(); do { if (f = s.execute(s.state, s.delay)) break } while ((s = d[0]) && s.id === i && d.shift()); if (this._active = !1, f) { for (; (s = d[0]) && s.id === i && d.shift();)s.unsubscribe(); throw f } } } const fe = new Q(ze); var Me = I(8433), j = I(3957), G = I(4243), P = I(8639), se = I(9512), ee = I(424); const gt = ["addListener", "removeListener"], N = ["addEventListener", "removeEventListener"], W = ["on", "off"]; function de(l, s, i, d) { if ((0, se.m)(i) && (d = i, i = void 0), d) return de(l, s, i).pipe((0, ee.Z)(d)); const [f, w] = function (l) { return (0, se.m)(l.addEventListener) && (0, se.m)(l.removeEventListener) }(l) ? N.map(T => le => l[T](s, le, i)) : function (l) { return (0, se.m)(l.addListener) && (0, se.m)(l.removeListener) }(l) ? gt.map(V(l, s)) : function (l) { return (0, se.m)(l.on) && (0, se.m)(l.off) }(l) ? W.map(V(l, s)) : []; if (!f && (0, P.z)(l)) return (0, G.z)(T => de(T, s, i))((0, j.Xf)(l)); if (!f) throw new TypeError("Invalid event target"); return new _.y(T => { const le = (...Ne) => T.next(1 < Ne.length ? Ne : Ne[0]); return f(le), () => w(le) }) } function V(l, s) { return i => d => l[i](s, d) } function Ue(l) { for (let s in l) { let i = l[s] || ""; switch (s) { case "display": l.display = "flex" === i ? ["-webkit-flex", "flex"] : "inline-flex" === i ? ["-webkit-inline-flex", "inline-flex"] : i; break; case "align-items": case "align-self": case "align-content": case "flex": case "flex-basis": case "flex-flow": case "flex-grow": case "flex-shrink": case "flex-wrap": case "justify-content": l["-webkit-" + s] = i; break; case "flex-direction": i = i || "row", l["-webkit-flex-direction"] = i, l["flex-direction"] = i; break; case "order": l.order = l["-webkit-" + s] = isNaN(+i) ? "0" : i } } return l } const Jt = "inline", Dt = ["row", "column", "row-reverse", "column-reverse"]; function qs(l) { let [s, i, d] = Zs(l); return function (l, s = null, i = !1) { return { display: i ? "inline-flex" : "flex", "box-sizing": "border-box", "flex-direction": l, "flex-wrap": s || null } }(s, i, d) } function Zs(l) { l = l ? l.toLowerCase() : ""; let [s, i, d] = l.split(" "); return Dt.find(f => f === s) || (s = Dt[0]), i === Jt && (i = d !== Jt ? d : "", d = Jt), [s, es(i), !!d] } function vs(l) { let [s] = Zs(l); return s.indexOf("row") > -1 } function es(l) { if (l) switch (l.toLowerCase()) { case "reverse": case "wrap-reverse": case "reverse-wrap": l = "wrap-reverse"; break; case "no": case "none": case "nowrap": l = "nowrap"; break; default: l = "wrap" }return l } function It(l, ...s) { if (null == l) throw TypeError("Cannot convert undefined or null to object"); for (let i of s) if (null != i) for (let d in i) i.hasOwnProperty(d) && (l[d] = i[d]); return l } var ts = I(1569), Fi = I(5309), Js = I(2014), en = I(1278), $i = I(2407), As = I(6567), tn = I(7529); const ii = { provide: o.tb, useFactory: function (l, s) { return () => { if ((0, a.NF)(s)) { const i = Array.from(l.querySelectorAll(`[class*=${nn}]`)), d = /\bflex-layout-.+?\b/g; i.forEach(f => { f.classList.contains(`${nn}ssr`) && f.parentNode ? f.parentNode.removeChild(f) : f.className.replace(d, "") }) } } }, deps: [a.K0, o.Lbi], multi: !0 }, nn = "flex-layout-"; class Ve { } Ve.\u0275fac = function (s) { return new (s || Ve) }, Ve.\u0275mod = o.oAB({ type: Ve }), Ve.\u0275inj = o.cJS({ providers: [ii] }); class nt { constructor(s = !1, i = "all", d = "", f = "", w = 0) { this.matches = s, this.mediaQuery = i, this.mqAlias = d, this.suffix = f, this.priority = w, this.property = "" } clone() { return new nt(this.matches, this.mediaQuery, this.mqAlias, this.suffix) } } class Tt { constructor() { this.stylesheet = new Map } addStyleToElement(s, i, d) { const f = this.stylesheet.get(s); f ? f.set(i, d) : this.stylesheet.set(s, new Map([[i, d]])) } clearStyles() { this.stylesheet.clear() } getStyleForElement(s, i) { const d = this.stylesheet.get(s); let f = ""; if (d) { const w = d.get(i); ("number" == typeof w || "string" == typeof w) && (f = w + "") } return f } } Tt.\u0275fac = function (s) { return new (s || Tt) }, Tt.\u0275prov = o.Yz7({ token: Tt, factory: Tt.\u0275fac, providedIn: "root" }); const Mn = { addFlexToParent: !0, addOrientationBps: !1, disableDefaultBps: !1, disableVendorPrefixes: !1, serverLoaded: !1, useColumnBasisZero: !0, printWithBreakpoints: [], mediaTriggerAutoRestore: !0, ssrObserveBreakpoints: [] }, Ye = new o.OlP("Flex Layout token, config options for the library", { providedIn: "root", factory: () => Mn }), ss = new o.OlP("FlexLayoutServerLoaded", { providedIn: "root", factory: () => !1 }), St = new o.OlP("Flex Layout token, collect all breakpoints into one provider", { providedIn: "root", factory: () => null }); function Rs(l, s) { return l = l ? l.clone() : new nt, s && (l.mqAlias = s.alias, l.mediaQuery = s.mediaQuery, l.suffix = s.suffix, l.priority = s.priority), l } class Se { constructor() { this.shouldCache = !0 } sideEffect(s, i, d) { } } class ie { constructor(s, i, d, f) { this._serverStylesheet = s, this._serverModuleLoaded = i, this._platformId = d, this.layoutConfig = f } applyStyleToElement(s, i, d = null) { let f = {}; "string" == typeof i && (f[i] = d, i = f), f = this.layoutConfig.disableVendorPrefixes ? i : Ue(i), this._applyMultiValueStyleToElement(f, s) } applyStyleToElements(s, i = []) { const d = this.layoutConfig.disableVendorPrefixes ? s : Ue(s); i.forEach(f => { this._applyMultiValueStyleToElement(d, f) }) } getFlowDirection(s) { const i = "flex-direction"; let d = this.lookupStyle(s, i); return [d || "row", this.lookupInlineStyle(s, i) || (0, a.PM)(this._platformId) && this._serverModuleLoaded ? d : ""] } hasWrap(s) { return "wrap" === this.lookupStyle(s, "flex-wrap") } lookupAttributeValue(s, i) { return s.getAttribute(i) || "" } lookupInlineStyle(s, i) { return (0, a.NF)(this._platformId) ? s.style.getPropertyValue(i) : this._getServerStyle(s, i) } lookupStyle(s, i, d = !1) { let f = ""; return s && ((f = this.lookupInlineStyle(s, i)) || ((0, a.NF)(this._platformId) ? d || (f = getComputedStyle(s).getPropertyValue(i)) : this._serverModuleLoaded && (f = this._serverStylesheet.getStyleForElement(s, i)))), f ? f.trim() : "" } _applyMultiValueStyleToElement(s, i) { Object.keys(s).sort().forEach(d => { const f = s[d], w = Array.isArray(f) ? f : [f]; w.sort(); for (let T of w) T = T ? T + "" : "", (0, a.NF)(this._platformId) || !this._serverModuleLoaded ? (0, a.NF)(this._platformId) ? i.style.setProperty(d, T) : this._setServerStyle(i, d, T) : this._serverStylesheet.addStyleToElement(i, d, T) }) } _setServerStyle(s, i, d) { i = i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); const f = this._readStyleAttribute(s); f[i] = d || "", this._writeStyleAttribute(s, f) } _getServerStyle(s, i) { return this._readStyleAttribute(s)[i] || "" } _readStyleAttribute(s) { const i = {}, d = s.getAttribute("style"); if (d) { const f = d.split(/;+/g); for (let w = 0; w < f.length; w++) { const T = f[w].trim(); if (T.length > 0) { const le = T.indexOf(":"); if (-1 === le) throw new Error(`Invalid CSS style: ${T}`); i[T.substr(0, le).trim()] = T.substr(le + 1).trim() } } } return i } _writeStyleAttribute(s, i) { let d = ""; for (const f in i) i[f] && (d += f + ":" + i[f] + ";"); s.setAttribute("style", d) } } function qe(l, s) { const i = l && l.priority || 0; return (s && s.priority || 0) - i } function Bs(l, s) { return (l.priority || 0) - (s.priority || 0) } ie.\u0275fac = function (s) { return new (s || ie)(o.LFG(Tt), o.LFG(ss), o.LFG(o.Lbi), o.LFG(Ye)) }, ie.\u0275prov = o.Yz7({ token: ie, factory: ie.\u0275fac, providedIn: "root" }); class ft { constructor(s, i, d) { this._zone = s, this._platformId = i, this._document = d, this.source = new y.X(new nt(!0)), this.registry = new Map, this.pendingRemoveListenerFns = [], this._observable$ = this.source.asObservable() } get activations() { const s = []; return this.registry.forEach((i, d) => { i.matches && s.push(d) }), s } isActive(s) { const i = this.registry.get(s); return i ? i.matches : this.registerQuery(s).some(d => d.matches) } observe(s, i = !1) { if (s && s.length) { const d = this._observable$.pipe((0, ts.h)(w => !i || s.indexOf(w.mediaQuery) > -1)), f = new _.y(w => { const T = this.registerQuery(s); if (T.length) { const le = T.pop(); T.forEach(Ne => { w.next(Ne) }), this.source.next(le) } w.complete() }); return (0, x.T)(f, d) } return this._observable$ } registerQuery(s) { const i = Array.isArray(s) ? s : [s], d = []; return function (l, s) { const i = l.filter(d => !rn[d]); if (i.length > 0) { const d = i.join(", "); try { const f = s.createElement("style"); if (f.setAttribute("type", "text/css"), !f.styleSheet) { const w = `\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${d} {.fx-query-test{ }}\n`; f.appendChild(s.createTextNode(w)) } s.head.appendChild(f), i.forEach(w => rn[w] = f) } catch (f) { console.error(f) } } }(i, this._document), i.forEach(f => { const w = le => { this._zone.run(() => this.source.next(new nt(le.matches, f))) }; let T = this.registry.get(f); T || (T = this.buildMQL(f), T.addListener(w), this.pendingRemoveListenerFns.push(() => T.removeListener(w)), this.registry.set(f, T)), T.matches && d.push(new nt(!0, f)) }), d } ngOnDestroy() { let s; for (; s = this.pendingRemoveListenerFns.pop();)s() } buildMQL(s) { return function (l, s) { return s && window.matchMedia("all").addListener ? window.matchMedia(l) : { matches: "all" === l || "" === l, media: l, addListener: () => { }, removeListener: () => { }, onchange: null, addEventListener() { }, removeEventListener() { }, dispatchEvent: () => !1 } }(s, (0, a.NF)(this._platformId)) } } ft.\u0275fac = function (s) { return new (s || ft)(o.LFG(o.R0b), o.LFG(o.Lbi), o.LFG(a.K0)) }, ft.\u0275prov = o.Yz7({ token: ft, factory: ft.\u0275fac, providedIn: "root" }); const rn = {}; const an = [{ alias: "xs", mediaQuery: "screen and (min-width: 0px) and (max-width: 599.98px)", priority: 1e3 }, { alias: "sm", mediaQuery: "screen and (min-width: 600px) and (max-width: 959.98px)", priority: 900 }, { alias: "md", mediaQuery: "screen and (min-width: 960px) and (max-width: 1279.98px)", priority: 800 }, { alias: "lg", mediaQuery: "screen and (min-width: 1280px) and (max-width: 1919.98px)", priority: 700 }, { alias: "xl", mediaQuery: "screen and (min-width: 1920px) and (max-width: 4999.98px)", priority: 600 }, { alias: "lt-sm", overlapping: !0, mediaQuery: "screen and (max-width: 599.98px)", priority: 950 }, { alias: "lt-md", overlapping: !0, mediaQuery: "screen and (max-width: 959.98px)", priority: 850 }, { alias: "lt-lg", overlapping: !0, mediaQuery: "screen and (max-width: 1279.98px)", priority: 750 }, { alias: "lt-xl", overlapping: !0, priority: 650, mediaQuery: "screen and (max-width: 1919.98px)" }, { alias: "gt-xs", overlapping: !0, mediaQuery: "screen and (min-width: 600px)", priority: -950 }, { alias: "gt-sm", overlapping: !0, mediaQuery: "screen and (min-width: 960px)", priority: -850 }, { alias: "gt-md", overlapping: !0, mediaQuery: "screen and (min-width: 1280px)", priority: -750 }, { alias: "gt-lg", overlapping: !0, mediaQuery: "screen and (min-width: 1920px)", priority: -650 }], oi = "(orientation: portrait) and (max-width: 599.98px)", ln = "(orientation: landscape) and (max-width: 959.98px)", ai = "(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)", Dn = "(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)", In = "(orientation: portrait) and (min-width: 840px)", $e = "(orientation: landscape) and (min-width: 1280px)", pt = { HANDSET: `${oi}, ${ln}`, TABLET: `${ai} , ${Dn}`, WEB: `${In}, ${$e} `, HANDSET_PORTRAIT: `${oi}`, TABLET_PORTRAIT: `${ai} `, WEB_PORTRAIT: `${In}`, HANDSET_LANDSCAPE: `${ln}`, TABLET_LANDSCAPE: `${Dn}`, WEB_LANDSCAPE: `${$e}` }, cn = [{ alias: "handset", priority: 2e3, mediaQuery: pt.HANDSET }, { alias: "handset.landscape", priority: 2e3, mediaQuery: pt.HANDSET_LANDSCAPE }, { alias: "handset.portrait", priority: 2e3, mediaQuery: pt.HANDSET_PORTRAIT }, { alias: "tablet", priority: 2100, mediaQuery: pt.TABLET }, { alias: "tablet.landscape", priority: 2100, mediaQuery: pt.TABLET_LANDSCAPE }, { alias: "tablet.portrait", priority: 2100, mediaQuery: pt.TABLET_PORTRAIT }, { alias: "web", priority: 2200, mediaQuery: pt.WEB, overlapping: !0 }, { alias: "web.landscape", priority: 2200, mediaQuery: pt.WEB_LANDSCAPE, overlapping: !0 }, { alias: "web.portrait", priority: 2200, mediaQuery: pt.WEB_PORTRAIT, overlapping: !0 }], Oi = /(\.|-|_)/g; function Li(l) { let s = l.length > 0 ? l.charAt(0) : "", i = l.length > 1 ? l.slice(1) : ""; return s.toUpperCase() + i } function dn(l) { return l.forEach(s => { s.suffix || (s.suffix = function (l) { return l.replace(Oi, "|").split("|").map(Li).join("") }(s.alias), s.overlapping = !!s.overlapping) }), l } const li = new o.OlP("Token (@angular/flex-layout) Breakpoints", { providedIn: "root", factory: () => { const l = (0, o.f3M)(St), s = (0, o.f3M)(Ye), i = [].concat.apply([], (l || []).map(f => Array.isArray(f) ? f : [f])); return function (l, s = []) { const i = {}; return l.forEach(d => { i[d.alias] = d }), s.forEach(d => { i[d.alias] ? It(i[d.alias], d) : i[d.alias] = d }), dn(Object.keys(i).map(d => i[d])) }((s.disableDefaultBps ? [] : an).concat(s.addOrientationBps ? cn : []), i) } }); class mt { constructor(s) { this.findByMap = new Map, this.items = [...s].sort(Bs) } findByAlias(s) { return s ? this.findWithPredicate(s, i => i.alias == s) : null } findByQuery(s) { return this.findWithPredicate(s, i => i.mediaQuery == s) } get overlappings() { return this.items.filter(s => 1 == s.overlapping) } get aliases() { return this.items.map(s => s.alias) } get suffixes() { return this.items.map(s => s.suffix ? s.suffix : "") } findWithPredicate(s, i) { let d = this.findByMap.get(s); return d || (d = this.items.find(i) || null, this.findByMap.set(s, d)), d || null } } mt.\u0275fac = function (s) { return new (s || mt)(o.LFG(li)) }, mt.\u0275prov = o.Yz7({ token: mt, factory: mt.\u0275fac, providedIn: "root" }); const bs = "print", Tn = { alias: bs, mediaQuery: bs, priority: 1e3 }; class Bt { constructor(s, i, d) { this.breakpoints = s, this.layoutConfig = i, this._document = d, this.registeredBeforeAfterPrintHooks = !1, this.isPrintingBeforeAfterEvent = !1, this.beforePrintEventListeners = [], this.afterPrintEventListeners = [], this.isPrinting = !1, this.queue = new Ri, this.deactivations = [] } withPrintQuery(s) { return [...s, bs] } isPrintEvent(s) { return s.mediaQuery.startsWith(bs) } get printAlias() { return this.layoutConfig.printWithBreakpoints || [] } get printBreakPoints() { return this.printAlias.map(s => this.breakpoints.findByAlias(s)).filter(s => null !== s) } getEventBreakpoints({ mediaQuery: s }) { const i = this.breakpoints.findByQuery(s); return (i ? [...this.printBreakPoints, i] : this.printBreakPoints).sort(qe) } updateEvent(s) { let i = this.breakpoints.findByQuery(s.mediaQuery); return this.isPrintEvent(s) && (i = this.getEventBreakpoints(s)[0], s.mediaQuery = i ? i.mediaQuery : ""), Rs(s, i) } registerBeforeAfterPrintHooks(s) { if (!this._document.defaultView || this.registeredBeforeAfterPrintHooks) return; this.registeredBeforeAfterPrintHooks = !0; const i = () => { this.isPrinting || (this.isPrintingBeforeAfterEvent = !0, this.startPrinting(s, this.getEventBreakpoints(new nt(!0, bs))), s.updateStyles()) }, d = () => { this.isPrintingBeforeAfterEvent = !1, this.isPrinting && (this.stopPrinting(s), s.updateStyles()) }; this._document.defaultView.addEventListener("beforeprint", i), this._document.defaultView.addEventListener("afterprint", d), this.beforePrintEventListeners.push(i), this.afterPrintEventListeners.push(d) } interceptEvents(s) { return this.registerBeforeAfterPrintHooks(s), i => { this.isPrintEvent(i) ? i.matches && !this.isPrinting ? (this.startPrinting(s, this.getEventBreakpoints(i)), s.updateStyles()) : !i.matches && this.isPrinting && !this.isPrintingBeforeAfterEvent && (this.stopPrinting(s), s.updateStyles()) : this.collectActivations(i) } } blockPropagation() { return s => !(this.isPrinting || this.isPrintEvent(s)) } startPrinting(s, i) { this.isPrinting = !0, s.activatedBreakpoints = this.queue.addPrintBreakpoints(i) } stopPrinting(s) { s.activatedBreakpoints = this.deactivations, this.deactivations = [], this.queue.clear(), this.isPrinting = !1 } collectActivations(s) { if (!this.isPrinting || this.isPrintingBeforeAfterEvent) if (s.matches) this.isPrintingBeforeAfterEvent || (this.deactivations = []); else { const i = this.breakpoints.findByQuery(s.mediaQuery); i && (this.deactivations.push(i), this.deactivations.sort(qe)) } } ngOnDestroy() { this._document.defaultView && (this.beforePrintEventListeners.forEach(s => this._document.defaultView.removeEventListener("beforeprint", s)), this.afterPrintEventListeners.forEach(s => this._document.defaultView.removeEventListener("afterprint", s))) } } Bt.\u0275fac = function (s) { return new (s || Bt)(o.LFG(mt), o.LFG(Ye), o.LFG(a.K0)) }, Bt.\u0275prov = o.Yz7({ token: Bt, factory: Bt.\u0275fac, providedIn: "root" }); class Ri { constructor() { this.printBreakpoints = [] } addPrintBreakpoints(s) { return s.push(Tn), s.sort(qe), s.forEach(i => this.addBreakpoint(i)), this.printBreakpoints } addBreakpoint(s) { var l; s && void 0 === this.printBreakpoints.find(d => d.mediaQuery === s.mediaQuery) && (this.printBreakpoints = (l = s) && l.mediaQuery.startsWith(bs) ? [s, ...this.printBreakpoints] : [...this.printBreakpoints, s]) } clear() { this.printBreakpoints = [] } } class me { constructor(s, i, d) { this.matchMedia = s, this.breakpoints = i, this.hook = d, this.activatedBreakpoints = [], this.elementMap = new Map, this.elementKeyMap = new WeakMap, this.watcherMap = new WeakMap, this.updateMap = new WeakMap, this.clearMap = new WeakMap, this.subject = new F.x, this.observeActivations() } get activatedAlias() { return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : "" } onMediaChange(s) { const i = this.findByQuery(s.mediaQuery); i && ((s = Rs(s, i)).matches && -1 === this.activatedBreakpoints.indexOf(i) ? (this.activatedBreakpoints.push(i), this.activatedBreakpoints.sort(qe), this.updateStyles()) : !s.matches && -1 !== this.activatedBreakpoints.indexOf(i) && (this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(i), 1), this.activatedBreakpoints.sort(qe), this.updateStyles())) } init(s, i, d, f, w = []) { ci(this.updateMap, s, i, d), ci(this.clearMap, s, i, f), this.buildElementKeyMap(s, i), this.watchExtraTriggers(s, i, w) } getValue(s, i, d) { const f = this.elementMap.get(s); if (f) { const w = void 0 !== d ? f.get(d) : this.getActivatedValues(f, i); if (w) return w.get(i) } } hasValue(s, i) { const d = this.elementMap.get(s); if (d) { const f = this.getActivatedValues(d, i); if (f) return void 0 !== f.get(i) || !1 } return !1 } setValue(s, i, d, f) { let w = this.elementMap.get(s); if (w) { const le = (w.get(f) || new Map).set(i, d); w.set(f, le), this.elementMap.set(s, w) } else w = (new Map).set(f, (new Map).set(i, d)), this.elementMap.set(s, w); const T = this.getValue(s, i); void 0 !== T && this.updateElement(s, i, T) } trackValue(s, i) { return this.subject.asObservable().pipe((0, ts.h)(d => d.element === s && d.key === i)) } updateStyles() { this.elementMap.forEach((s, i) => { const d = new Set(this.elementKeyMap.get(i)); let f = this.getActivatedValues(s); f && f.forEach((w, T) => { this.updateElement(i, T, w), d.delete(T) }), d.forEach(w => { if (f = this.getActivatedValues(s, w), f) { const T = f.get(w); this.updateElement(i, w, T) } else this.clearElement(i, w) }) }) } clearElement(s, i) { const d = this.clearMap.get(s); if (d) { const f = d.get(i); f && (f(), this.subject.next({ element: s, key: i, value: "" })) } } updateElement(s, i, d) { const f = this.updateMap.get(s); if (f) { const w = f.get(i); w && (w(d), this.subject.next({ element: s, key: i, value: d })) } } releaseElement(s) { const i = this.watcherMap.get(s); i && (i.forEach(f => f.unsubscribe()), this.watcherMap.delete(s)); const d = this.elementMap.get(s); d && (d.forEach((f, w) => d.delete(w)), this.elementMap.delete(s)) } triggerUpdate(s, i) { const d = this.elementMap.get(s); if (d) { const f = this.getActivatedValues(d, i); f && (i ? this.updateElement(s, i, f.get(i)) : f.forEach((w, T) => this.updateElement(s, T, w))) } } buildElementKeyMap(s, i) { let d = this.elementKeyMap.get(s); d || (d = new Set, this.elementKeyMap.set(s, d)), d.add(i) } watchExtraTriggers(s, i, d) { if (d && d.length) { let f = this.watcherMap.get(s); if (f || (f = new Map, this.watcherMap.set(s, f)), !f.get(i)) { const T = (0, x.T)(...d).subscribe(() => { const le = this.getValue(s, i); this.updateElement(s, i, le) }); f.set(i, T) } } } findByQuery(s) { return this.breakpoints.findByQuery(s) } getActivatedValues(s, i) { for (let f = 0; f < this.activatedBreakpoints.length; f++) { const w = this.activatedBreakpoints[f], T = s.get(w.alias); if (T && (void 0 === i || T.has(i) && null != T.get(i))) return T } const d = s.get(""); return void 0 === i || d && d.has(i) ? d : void 0 } observeActivations() { const i = this.breakpoints.items.map(d => d.mediaQuery); this.matchMedia.observe(this.hook.withPrintQuery(i)).pipe((0, Fi.b)(this.hook.interceptEvents(this)), (0, ts.h)(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this)) } } function ci(l, s, i, d) { if (void 0 !== d) { let f = l.get(s); f || (f = new Map, l.set(s, f)), f.set(i, d) } } me.\u0275fac = function (s) { return new (s || me)(o.LFG(ft), o.LFG(mt), o.LFG(Bt)) }, me.\u0275prov = o.Yz7({ token: me, factory: me.\u0275fac, providedIn: "root" }); class _e { constructor(s, i, d, f) { this.elementRef = s, this.styleBuilder = i, this.styler = d, this.marshal = f, this.DIRECTIVE_KEY = "", this.inputs = [], this.mru = {}, this.destroySubject = new F.x, this.styleCache = new Map } get parentElement() { return this.elementRef.nativeElement.parentElement } get nativeElement() { return this.elementRef.nativeElement } get activatedValue() { return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY) } set activatedValue(s) { this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, s, this.marshal.activatedAlias) } ngOnChanges(s) { Object.keys(s).forEach(i => { if (-1 !== this.inputs.indexOf(i)) { const d = i.split(".").slice(1).join("."), f = s[i].currentValue; this.setValue(f, d) } }) } ngOnDestroy() { this.destroySubject.next(), this.destroySubject.complete(), this.marshal.releaseElement(this.nativeElement) } init(s = []) { this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), s) } addStyles(s, i) { const d = this.styleBuilder, f = d.shouldCache; let w = this.styleCache.get(s); (!w || !f) && (w = d.buildStyles(s, i), f && this.styleCache.set(s, w)), this.mru = be({}, w), this.applyStyleToElement(w), d.sideEffect(s, w, i) } clearStyles() { Object.keys(this.mru).forEach(s => { this.mru[s] = "" }), this.applyStyleToElement(this.mru), this.mru = {} } triggerUpdate() { this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY) } getFlexFlowDirection(s, i = !1) { if (s) { const [d, f] = this.styler.getFlowDirection(s); if (!f && i) { const w = qs(d), T = [s]; this.styler.applyStyleToElements(w, T) } return d.trim() } return "row" } hasWrap(s) { return this.styler.hasWrap(s) } applyStyleToElement(s, i, d = this.nativeElement) { this.styler.applyStyleToElement(d, s, i) } setValue(s, i) { this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, s, i) } updateWithValue(s) { this.currentValue !== s && (this.addStyles(s), this.currentValue = s) } } _e.\u0275fac = function (s) { return new (s || _e)(o.Y36(o.SBq), o.Y36(Se), o.Y36(ie), o.Y36(me)) }, _e.\u0275dir = o.lG2({ type: _e, features: [o.TTD] }); class Ft extends ft { constructor(s, i, d, f) { super(s, i, d), this._breakpoints = f, this.autoRegisterQueries = !0, this.useOverlaps = !1 } clearAll() { this.registry.forEach(s => { s.destroy() }), this.registry.clear(), this.useOverlaps = !1 } activate(s, i = !1) { return i = i || this.useOverlaps, s = this._validateQuery(s), (i || !this.isActive(s)) && (this._deactivateAll(), this._registerMediaQuery(s), this._activateWithOverlaps(s, i)), this.hasActivated } _validateQuery(s) { const i = this._breakpoints.findByAlias(s); return i && i.mediaQuery || s } _activateWithOverlaps(s, i) { if (i) { const d = this._breakpoints.findByQuery(s), f = d ? d.alias : "unknown"; switch (f) { case "lg": this._activateByAlias(["lt-xl"]); break; case "md": this._activateByAlias(["lt-xl", "lt-lg"]); break; case "sm": this._activateByAlias(["lt-xl", "lt-lg", "lt-md"]); break; case "xs": this._activateByAlias(["lt-xl", "lt-lg", "lt-md", "lt-sm"]) }switch (f) { case "xl": this._activateByAlias(["gt-lg", "gt-md", "gt-sm", "gt-xs"]); break; case "lg": this._activateByAlias(["gt-md", "gt-sm", "gt-xs"]); break; case "md": this._activateByAlias(["gt-sm", "gt-xs"]); break; case "sm": this._activateByAlias(["gt-xs"]) } } return this._activateByQuery(s) } _activateByAlias(s) { s.forEach(d => { const f = this._breakpoints.findByAlias(d); this._activateByQuery(f ? f.mediaQuery : d) }) } _activateByQuery(s) { !this.registry.has(s) && this.autoRegisterQueries && this._registerMediaQuery(s); const i = this.registry.get(s); return i && !this.isActive(s) && this.registry.set(s, i.activate()), this.hasActivated } _deactivateAll() { return this.registry.forEach(s => { s.deactivate() }), this } _registerMediaQuery(s) { !this.registry.has(s) && this.autoRegisterQueries && this.registerQuery(s) } buildMQL(s) { return new Pi(s) } get hasActivated() { return this.activations.length > 0 } } Ft.\u0275fac = function (s) { return new (s || Ft)(o.LFG(o.R0b), o.LFG(o.Lbi), o.LFG(a.K0), o.LFG(mt)) }, Ft.\u0275prov = o.Yz7({ token: Ft, factory: Ft.\u0275fac }); class Pi { constructor(s) { this._mediaQuery = s, this._isActive = !1, this._listeners = [], this.onchange = null } get matches() { return this._isActive } get media() { return this._mediaQuery } destroy() { this.deactivate(), this._listeners = [] } activate() { return this._isActive || (this._isActive = !0, this._listeners.forEach(s => { s.call(this, { matches: this.matches, media: this.media }) })), this } deactivate() { return this._isActive && (this._isActive = !1, this._listeners.forEach(s => { s.call(this, { matches: this.matches, media: this.media }) })), this } addListener(s) { -1 === this._listeners.indexOf(s) && this._listeners.push(s), this._isActive && s.call(this, { matches: this.matches, media: this.media }) } removeListener(s) { } addEventListener(s, i, d) { } removeEventListener(s, i, d) { } dispatchEvent(s) { return !1 } } class ns { constructor(s, i, d) { this.breakpoints = s, this.matchMedia = i, this.hook = d, this.filterOverlaps = !1, this.destroyed$ = new F.x, this._media$ = this.watchActivations(), this.media$ = this._media$.pipe((0, ts.h)(f => f.length > 0), (0, Js.U)(f => f[0])) } ngOnDestroy() { this.destroyed$.next(), this.destroyed$.complete() } asObservable() { return this._media$ } isActive(s) { return function (l) { return l.map(s => s.split(",")).reduce((s, i) => s.concat(i)).map(s => s.trim()) }((l = s, Array.isArray(l) ? l : [l])).some(d => { const f = function (l, s) { const i = s.findByAlias(l) || s.findByQuery(l); return i ? i.mediaQuery : null }(d, this.breakpoints); return null !== f && this.matchMedia.isActive(f) }); var l } watchActivations() { const s = this.breakpoints.items.map(i => i.mediaQuery); return this.buildObservable(s) } buildObservable(s) { return this.matchMedia.observe(this.hook.withPrintQuery(s)).pipe((0, ts.h)(f => f.matches), (0, en.b)(0, fe), (0, $i.w)(f => (0, Me.of)(this.findAllActivations())), (0, Js.U)(f => this.filterOverlaps ? f.filter(w => { const T = this.breakpoints.findByQuery(w.mediaQuery); return !T || !T.overlapping }) : f), (0, ts.h)(f => f.filter(T => T.mediaQuery.length > 0).length > 0), (0, As.R)(this.destroyed$)) } findAllActivations() { return this.matchMedia.activations.map(d => new nt(!0, d)).map(d => this.hook.isPrintEvent(d) ? this.hook.updateEvent(d) : d).map(d => Rs(d, this.breakpoints.findByQuery(d.mediaQuery))).sort(qe) } } ns.\u0275fac = function (s) { return new (s || ns)(o.LFG(mt), o.LFG(ft), o.LFG(Bt)) }, ns.\u0275prov = o.Yz7({ token: ns, factory: ns.\u0275fac, providedIn: "root" }); class Ps { constructor(s, i, d, f, w) { this.breakpoints = s, this.matchMedia = i, this.layoutConfig = d, this._platformId = f, this._document = w, this.hasCachedRegistryMatches = !1, this.originalActivations = [], this.originalRegistry = new Map } activate(s) { s = s.map(i => i.trim()), this.saveActivations(), this.deactivateAll(), this.setActivations(s), this.prepareAutoRestore() } restore() { if (this.hasCachedRegistryMatches) { const s = d => d.mediaQuery, i = this.originalActivations.map(s); try { this.deactivateAll(), this.restoreRegistryMatches(), this.setActivations(i) } finally { this.originalActivations = [], this.resizeSubscription && this.resizeSubscription.unsubscribe() } } } prepareAutoRestore() { if ((0, a.NF)(this._platformId) && this._document && this.layoutConfig.mediaTriggerAutoRestore) { const d = de(window, "resize").pipe((0, tn.q)(1)); this.resizeSubscription = d.subscribe(this.restore.bind(this)) } } deactivateAll() { const s = this.currentActivations; this.forceRegistryMatches(s, !1), this.simulateMediaChanges(s, !1) } saveActivations() { if (!this.hasCachedRegistryMatches) { const s = d => new nt(!0, d), i = d => Rs(d, this.breakpoints.findByQuery(d.mediaQuery)); this.originalActivations = this.currentActivations.map(s).map(i).sort(qe), this.cacheRegistryMatches() } } setActivations(s) { this.originalRegistry && this.forceRegistryMatches(s, !0), this.simulateMediaChanges(s) } simulateMediaChanges(s, i = !0) { s.map(w => { const T = this.breakpoints, le = T.findByAlias(w) || T.findByQuery(w); return le ? le.mediaQuery : w }).forEach(w => this.emitChangeEvent(i, w)) } forceRegistryMatches(s, i) { const d = new Map; s.forEach(f => { d.set(f, { matches: i }) }), this.matchMedia.registry = d } cacheRegistryMatches() { const s = this.originalRegistry; s.clear(), this.matchMedia.registry.forEach((i, d) => { s.set(d, i) }), this.hasCachedRegistryMatches = !0 } restoreRegistryMatches() { const s = this.matchMedia.registry; s.clear(), this.originalRegistry.forEach((i, d) => { s.set(d, i) }), this.originalRegistry.clear(), this.hasCachedRegistryMatches = !1 } emitChangeEvent(s, i) { this.matchMedia.source.next(new nt(s, i)) } get currentActivations() { return this.matchMedia.activations } } function di(l, s = "1", i = "1") { let d = [s, i, l], f = l.indexOf("calc"); if (f > 0) { d[2] = ui(l.substring(f).trim()); let w = l.substr(0, f).trim().split(" "); 2 == w.length && (d[0] = w[0], d[1] = w[1]) } else if (0 == f) d[2] = ui(l.trim()); else { let w = l.split(" "); d = 3 === w.length ? w : [s, i, l] } return d } function ui(l) { return l.replace(/[\s]/g, "").replace(/[\/\*\+\-]/g, " $& ") } Ps.\u0275fac = function (s) { return new (s || Ps)(o.LFG(mt), o.LFG(ft), o.LFG(Ye), o.LFG(o.Lbi), o.LFG(a.K0)) }, Ps.\u0275prov = o.Yz7({ token: Ps, factory: Ps.\u0275fac, providedIn: "root" }); var yt = I(2871), On = I(6219); class is extends Se { buildStyles(s) { return { content: s ? `url(${s})` : "" } } } is.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(is)))(i || is) } }(), is.\u0275prov = o.Yz7({ token: is, factory: is.\u0275fac, providedIn: "root" }); class Pt extends _e { constructor(s, i, d, f, w, T) { super(s, i, d, f), this.platformId = w, this.serverModuleLoaded = T, this.DIRECTIVE_KEY = "img-src", this.defaultSrc = "", this.styleCache = Ln, this.init(), this.setValue(this.nativeElement.getAttribute("src") || "", ""), (0, a.PM)(this.platformId) && this.serverModuleLoaded && this.nativeElement.setAttribute("src", "") } set src(s) { this.defaultSrc = s, this.setValue(this.defaultSrc, "") } updateWithValue(s) { const i = s || this.defaultSrc; (0, a.PM)(this.platformId) && this.serverModuleLoaded ? this.addStyles(i) : this.nativeElement.setAttribute("src", i) } } Pt.\u0275fac = function (s) { return new (s || Pt)(o.Y36(o.SBq), o.Y36(is), o.Y36(ie), o.Y36(me), o.Y36(o.Lbi), o.Y36(ss)) }, Pt.\u0275dir = o.lG2({ type: Pt, inputs: { src: "src" }, features: [o.qOj] }); const Ln = new Map, gn = ["src.xs", "src.sm", "src.md", "src.lg", "src.xl", "src.lt-sm", "src.lt-md", "src.lt-lg", "src.lt-xl", "src.gt-xs", "src.gt-sm", "src.gt-md", "src.gt-lg"]; class rs extends Pt { constructor() { super(...arguments), this.inputs = gn } } rs.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(rs)))(i || rs) } }(), rs.\u0275dir = o.lG2({ type: rs, selectors: [["img", "src.xs", ""], ["img", "src.sm", ""], ["img", "src.md", ""], ["img", "src.lg", ""], ["img", "src.xl", ""], ["img", "src.lt-sm", ""], ["img", "src.lt-md", ""], ["img", "src.lt-lg", ""], ["img", "src.lt-xl", ""], ["img", "src.gt-xs", ""], ["img", "src.gt-sm", ""], ["img", "src.gt-md", ""], ["img", "src.gt-lg", ""]], inputs: { "src.xs": "src.xs", "src.sm": "src.sm", "src.md": "src.md", "src.lg": "src.lg", "src.xl": "src.xl", "src.lt-sm": "src.lt-sm", "src.lt-md": "src.lt-md", "src.lt-lg": "src.lt-lg", "src.lt-xl": "src.lt-xl", "src.gt-xs": "src.gt-xs", "src.gt-sm": "src.gt-sm", "src.gt-md": "src.gt-md", "src.gt-lg": "src.gt-lg" }, features: [o.qOj] }); class Gs extends _e { constructor(s, i, d, f, w, T, le) { super(s, null, i, d), this.ngClassInstance = le, this.DIRECTIVE_KEY = "ngClass", this.ngClassInstance || (this.ngClassInstance = new a.mk(f, w, s, T)), this.init(), this.setValue("", "") } set klass(s) { this.ngClassInstance.klass = s, this.setValue(s, "") } updateWithValue(s) { this.ngClassInstance.ngClass = s, this.ngClassInstance.ngDoCheck() } ngDoCheck() { this.ngClassInstance.ngDoCheck() } } Gs.\u0275fac = function (s) { return new (s || Gs)(o.Y36(o.SBq), o.Y36(ie), o.Y36(me), o.Y36(o.ZZ4), o.Y36(o.aQg), o.Y36(o.Qsj), o.Y36(a.mk, 10)) }, Gs.\u0275dir = o.lG2({ type: Gs, inputs: { klass: ["class", "klass"] }, features: [o.qOj] }); const ji = ["ngClass", "ngClass.xs", "ngClass.sm", "ngClass.md", "ngClass.lg", "ngClass.xl", "ngClass.lt-sm", "ngClass.lt-md", "ngClass.lt-lg", "ngClass.lt-xl", "ngClass.gt-xs", "ngClass.gt-sm", "ngClass.gt-md", "ngClass.gt-lg"]; class Ns extends Gs { constructor() { super(...arguments), this.inputs = ji } } Ns.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Ns)))(i || Ns) } }(), Ns.\u0275dir = o.lG2({ type: Ns, selectors: [["", "ngClass", ""], ["", "ngClass.xs", ""], ["", "ngClass.sm", ""], ["", "ngClass.md", ""], ["", "ngClass.lg", ""], ["", "ngClass.xl", ""], ["", "ngClass.lt-sm", ""], ["", "ngClass.lt-md", ""], ["", "ngClass.lt-lg", ""], ["", "ngClass.lt-xl", ""], ["", "ngClass.gt-xs", ""], ["", "ngClass.gt-sm", ""], ["", "ngClass.gt-md", ""], ["", "ngClass.gt-lg", ""]], inputs: { ngClass: "ngClass", "ngClass.xs": "ngClass.xs", "ngClass.sm": "ngClass.sm", "ngClass.md": "ngClass.md", "ngClass.lg": "ngClass.lg", "ngClass.xl": "ngClass.xl", "ngClass.lt-sm": "ngClass.lt-sm", "ngClass.lt-md": "ngClass.lt-md", "ngClass.lt-lg": "ngClass.lt-lg", "ngClass.lt-xl": "ngClass.lt-xl", "ngClass.gt-xs": "ngClass.gt-xs", "ngClass.gt-sm": "ngClass.gt-sm", "ngClass.gt-md": "ngClass.gt-md", "ngClass.gt-lg": "ngClass.gt-lg" }, features: [o.qOj] }); class os extends Se { buildStyles(s, i) { return { display: "true" === s ? i.display || (i.isServer ? "initial" : "") : "none" } } } os.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(os)))(i || os) } }(), os.\u0275prov = o.Yz7({ token: os, factory: os.\u0275fac, providedIn: "root" }); class zs extends _e { constructor(s, i, d, f, w, T, le) { super(s, i, d, f), this.layoutConfig = w, this.platformId = T, this.serverModuleLoaded = le, this.DIRECTIVE_KEY = "show-hide", this.display = "", this.hasLayout = !1, this.hasFlexChild = !1 } ngAfterViewInit() { this.trackExtraTriggers(); const s = Array.from(this.nativeElement.children); for (let d = 0; d < s.length; d++)if (this.marshal.hasValue(s[d], "flex")) { this.hasFlexChild = !0; break } kn.has(this.nativeElement) ? this.display = kn.get(this.nativeElement) : (this.display = this.getDisplayStyle(), kn.set(this.nativeElement, this.display)), this.init(); const i = this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY, ""); void 0 === i || "" === i ? this.setValue(!0, "") : this.triggerUpdate() } ngOnChanges(s) { Object.keys(s).forEach(i => { if (-1 !== this.inputs.indexOf(i)) { const d = i.split("."), f = d.slice(1).join("."), w = s[i].currentValue; let T = "" === w || 0 !== w && (0, yt.Ig)(w); "fxHide" === d[0] && (T = !T), this.setValue(T, f) } }) } trackExtraTriggers() { this.hasLayout = this.marshal.hasValue(this.nativeElement, "layout"), ["layout", "layout-align"].forEach(s => { this.marshal.trackValue(this.nativeElement, s).pipe((0, As.R)(this.destroySubject)).subscribe(this.triggerUpdate.bind(this)) }) } getDisplayStyle() { return this.hasLayout || this.hasFlexChild && this.layoutConfig.addFlexToParent ? "flex" : this.styler.lookupStyle(this.nativeElement, "display", !0) } updateWithValue(s = !0) { if ("" === s) return; const i = (0, a.PM)(this.platformId); this.addStyles(s ? "true" : "false", { display: this.display, isServer: i }), i && this.serverModuleLoaded && this.nativeElement.style.setProperty("display", ""), this.marshal.triggerUpdate(this.parentElement, "layout-gap") } } zs.\u0275fac = function (s) { return new (s || zs)(o.Y36(o.SBq), o.Y36(os), o.Y36(ie), o.Y36(me), o.Y36(Ye), o.Y36(o.Lbi), o.Y36(ss)) }, zs.\u0275dir = o.lG2({ type: zs, features: [o.qOj, o.TTD] }); const kn = new WeakMap, gi = ["fxShow", "fxShow.print", "fxShow.xs", "fxShow.sm", "fxShow.md", "fxShow.lg", "fxShow.xl", "fxShow.lt-sm", "fxShow.lt-md", "fxShow.lt-lg", "fxShow.lt-xl", "fxShow.gt-xs", "fxShow.gt-sm", "fxShow.gt-md", "fxShow.gt-lg", "fxHide", "fxHide.print", "fxHide.xs", "fxHide.sm", "fxHide.md", "fxHide.lg", "fxHide.xl", "fxHide.lt-sm", "fxHide.lt-md", "fxHide.lt-lg", "fxHide.lt-xl", "fxHide.gt-xs", "fxHide.gt-sm", "fxHide.gt-md", "fxHide.gt-lg"]; class Gt extends zs { constructor() { super(...arguments), this.inputs = gi } } Gt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Gt)))(i || Gt) } }(), Gt.\u0275dir = o.lG2({ type: Gt, selectors: [["", "fxShow", ""], ["", "fxShow.print", ""], ["", "fxShow.xs", ""], ["", "fxShow.sm", ""], ["", "fxShow.md", ""], ["", "fxShow.lg", ""], ["", "fxShow.xl", ""], ["", "fxShow.lt-sm", ""], ["", "fxShow.lt-md", ""], ["", "fxShow.lt-lg", ""], ["", "fxShow.lt-xl", ""], ["", "fxShow.gt-xs", ""], ["", "fxShow.gt-sm", ""], ["", "fxShow.gt-md", ""], ["", "fxShow.gt-lg", ""], ["", "fxHide", ""], ["", "fxHide.print", ""], ["", "fxHide.xs", ""], ["", "fxHide.sm", ""], ["", "fxHide.md", ""], ["", "fxHide.lg", ""], ["", "fxHide.xl", ""], ["", "fxHide.lt-sm", ""], ["", "fxHide.lt-md", ""], ["", "fxHide.lt-lg", ""], ["", "fxHide.lt-xl", ""], ["", "fxHide.gt-xs", ""], ["", "fxHide.gt-sm", ""], ["", "fxHide.gt-md", ""], ["", "fxHide.gt-lg", ""]], inputs: { fxShow: "fxShow", "fxShow.print": "fxShow.print", "fxShow.xs": "fxShow.xs", "fxShow.sm": "fxShow.sm", "fxShow.md": "fxShow.md", "fxShow.lg": "fxShow.lg", "fxShow.xl": "fxShow.xl", "fxShow.lt-sm": "fxShow.lt-sm", "fxShow.lt-md": "fxShow.lt-md", "fxShow.lt-lg": "fxShow.lt-lg", "fxShow.lt-xl": "fxShow.lt-xl", "fxShow.gt-xs": "fxShow.gt-xs", "fxShow.gt-sm": "fxShow.gt-sm", "fxShow.gt-md": "fxShow.gt-md", "fxShow.gt-lg": "fxShow.gt-lg", fxHide: "fxHide", "fxHide.print": "fxHide.print", "fxHide.xs": "fxHide.xs", "fxHide.sm": "fxHide.sm", "fxHide.md": "fxHide.md", "fxHide.lg": "fxHide.lg", "fxHide.xl": "fxHide.xl", "fxHide.lt-sm": "fxHide.lt-sm", "fxHide.lt-md": "fxHide.lt-md", "fxHide.lt-lg": "fxHide.lt-lg", "fxHide.lt-xl": "fxHide.lt-xl", "fxHide.gt-xs": "fxHide.gt-xs", "fxHide.gt-sm": "fxHide.gt-sm", "fxHide.gt-md": "fxHide.gt-md", "fxHide.gt-lg": "fxHide.gt-lg" }, features: [o.qOj] }); class fi { constructor(s, i, d = !0) { this.key = s, this.value = i, this.key = d ? s.replace(/['"]/g, "").trim() : s.trim(), this.value = d ? i.replace(/['"]/g, "").trim() : i.trim(), this.value = this.value.replace(/;/, "") } } function Bn(l) { let s = typeof l; return "object" === s ? l.constructor === Array ? "array" : l.constructor === Set ? "set" : "object" : s } function Pn(l, s) { let i = []; return "set" === Bn(l) ? l.forEach(d => i.push(d)) : Object.keys(l).forEach(d => { i.push(`${d}:${l[d]}`) }), function (l, s) { return l.map(fn).filter(d => !!d).map(d => (s && (d.value = s(d.value)), d)).reduce(Gn, {}) }(i, s) } function fn(l) { const [s, ...i] = l.split(":"); return new fi(s, i.join(":")) } function Gn(l, s) { return s.key && (l[s.key] = s.value), l } class Es extends _e { constructor(s, i, d, f, w, T, le, Ne, Ws) { super(s, null, i, d), this.sanitizer = f, this.ngStyleInstance = le, this.DIRECTIVE_KEY = "ngStyle", this.ngStyleInstance || (this.ngStyleInstance = new a.PC(s, w, T)), this.init(); const Xt = this.nativeElement.getAttribute("style") || ""; this.fallbackStyles = this.buildStyleMap(Xt), this.isServer = Ne && (0, a.PM)(Ws) } updateWithValue(s) { const i = this.buildStyleMap(s); this.ngStyleInstance.ngStyle = be(be({}, this.fallbackStyles), i), this.isServer && this.applyStyleToElement(i), this.ngStyleInstance.ngDoCheck() } clearStyles() { this.ngStyleInstance.ngStyle = this.fallbackStyles, this.ngStyleInstance.ngDoCheck() } buildStyleMap(s) { const i = d => this.sanitizer.sanitize(o.q3G.STYLE, d) || ""; if (s) switch (Bn(s)) { case "string": return pn(function (l, s = ";") { return String(l).trim().split(s).map(i => i.trim()).filter(i => "" !== i) }(s), i); case "array": return pn(s, i); default: return Pn(s, i) }return {} } ngDoCheck() { this.ngStyleInstance.ngDoCheck() } } Es.\u0275fac = function (s) { return new (s || Es)(o.Y36(o.SBq), o.Y36(ie), o.Y36(me), o.Y36(On.H7), o.Y36(o.aQg), o.Y36(o.Qsj), o.Y36(a.PC, 10), o.Y36(ss), o.Y36(o.Lbi)) }, Es.\u0275dir = o.lG2({ type: Es, features: [o.qOj] }); const Nn = ["ngStyle", "ngStyle.xs", "ngStyle.sm", "ngStyle.md", "ngStyle.lg", "ngStyle.xl", "ngStyle.lt-sm", "ngStyle.lt-md", "ngStyle.lt-lg", "ngStyle.lt-xl", "ngStyle.gt-xs", "ngStyle.gt-sm", "ngStyle.gt-md", "ngStyle.gt-lg"]; class xe extends Es { constructor() { super(...arguments), this.inputs = Nn } } function pn(l, s) { return l.map(fn).filter(d => !!d).map(d => (s && (d.value = s(d.value)), d)).reduce(Gn, {}) } xe.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(xe)))(i || xe) } }(), xe.\u0275dir = o.lG2({ type: xe, selectors: [["", "ngStyle", ""], ["", "ngStyle.xs", ""], ["", "ngStyle.sm", ""], ["", "ngStyle.md", ""], ["", "ngStyle.lg", ""], ["", "ngStyle.xl", ""], ["", "ngStyle.lt-sm", ""], ["", "ngStyle.lt-md", ""], ["", "ngStyle.lt-lg", ""], ["", "ngStyle.lt-xl", ""], ["", "ngStyle.gt-xs", ""], ["", "ngStyle.gt-sm", ""], ["", "ngStyle.gt-md", ""], ["", "ngStyle.gt-lg", ""]], inputs: { ngStyle: "ngStyle", "ngStyle.xs": "ngStyle.xs", "ngStyle.sm": "ngStyle.sm", "ngStyle.md": "ngStyle.md", "ngStyle.lg": "ngStyle.lg", "ngStyle.xl": "ngStyle.xl", "ngStyle.lt-sm": "ngStyle.lt-sm", "ngStyle.lt-md": "ngStyle.lt-md", "ngStyle.lt-lg": "ngStyle.lt-lg", "ngStyle.lt-xl": "ngStyle.lt-xl", "ngStyle.gt-xs": "ngStyle.gt-xs", "ngStyle.gt-sm": "ngStyle.gt-sm", "ngStyle.gt-md": "ngStyle.gt-md", "ngStyle.gt-lg": "ngStyle.gt-lg" }, features: [o.qOj] }); class Ke { } Ke.\u0275fac = function (s) { return new (s || Ke) }, Ke.\u0275mod = o.oAB({ type: Ke }), Ke.\u0275inj = o.cJS({ imports: [[Ve]] }); var Et = I(6093); class rt extends Se { buildStyles(s) { return qs(s) } } rt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(rt)))(i || rt) } }(), rt.\u0275prov = o.Yz7({ token: rt, factory: rt.\u0275fac, providedIn: "root" }); const as = ["fxLayout", "fxLayout.xs", "fxLayout.sm", "fxLayout.md", "fxLayout.lg", "fxLayout.xl", "fxLayout.lt-sm", "fxLayout.lt-md", "fxLayout.lt-lg", "fxLayout.lt-xl", "fxLayout.gt-xs", "fxLayout.gt-sm", "fxLayout.gt-md", "fxLayout.gt-lg"]; class Nt extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "layout", this.styleCache = ls, this.init() } } Nt.\u0275fac = function (s) { return new (s || Nt)(o.Y36(o.SBq), o.Y36(ie), o.Y36(rt), o.Y36(me)) }, Nt.\u0275dir = o.lG2({ type: Nt, features: [o.qOj] }); class _t extends Nt { constructor() { super(...arguments), this.inputs = as } } _t.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(_t)))(i || _t) } }(), _t.\u0275dir = o.lG2({ type: _t, selectors: [["", "fxLayout", ""], ["", "fxLayout.xs", ""], ["", "fxLayout.sm", ""], ["", "fxLayout.md", ""], ["", "fxLayout.lg", ""], ["", "fxLayout.xl", ""], ["", "fxLayout.lt-sm", ""], ["", "fxLayout.lt-md", ""], ["", "fxLayout.lt-lg", ""], ["", "fxLayout.lt-xl", ""], ["", "fxLayout.gt-xs", ""], ["", "fxLayout.gt-sm", ""], ["", "fxLayout.gt-md", ""], ["", "fxLayout.gt-lg", ""]], inputs: { fxLayout: "fxLayout", "fxLayout.xs": "fxLayout.xs", "fxLayout.sm": "fxLayout.sm", "fxLayout.md": "fxLayout.md", "fxLayout.lg": "fxLayout.lg", "fxLayout.xl": "fxLayout.xl", "fxLayout.lt-sm": "fxLayout.lt-sm", "fxLayout.lt-md": "fxLayout.lt-md", "fxLayout.lt-lg": "fxLayout.lt-lg", "fxLayout.lt-xl": "fxLayout.lt-xl", "fxLayout.gt-xs": "fxLayout.gt-xs", "fxLayout.gt-sm": "fxLayout.gt-sm", "fxLayout.gt-md": "fxLayout.gt-md", "fxLayout.gt-lg": "fxLayout.gt-lg" }, features: [o.qOj] }); const ls = new Map, mn = { "margin-left": null, "margin-right": null, "margin-top": null, "margin-bottom": null }; class zt extends Se { constructor(s) { super(), this._styler = s } buildStyles(s, i) { return s.endsWith(ds) ? function (l, s) { const [i, d] = l.split(" "), w = Ws => `-${Ws}`; let T = "0px", le = w(d || i), Ne = "0px"; return "rtl" === s ? Ne = w(i) : T = w(i), { margin: `0px ${T} ${le} ${Ne}` } }(s = s.slice(0, s.indexOf(ds)), i.directionality) : {} } sideEffect(s, i, d) { const f = d.items; if (s.endsWith(ds)) { const w = function (l, s) { const [i, d] = l.split(" "); let w = "0px", le = "0px"; return "rtl" === s ? le = i : w = i, { padding: `0px ${w} ${d || i} ${le}` } }(s = s.slice(0, s.indexOf(ds)), d.directionality); this._styler.applyStyleToElements(w, d.items) } else { const w = f.pop(), T = function (l, s) { const i = je(s.directionality, s.layout), d = be({}, mn); return d[i] = l, d }(s, d); this._styler.applyStyleToElements(T, f), this._styler.applyStyleToElements(mn, [w]) } } } zt.\u0275fac = function (s) { return new (s || zt)(o.LFG(ie)) }, zt.\u0275prov = o.Yz7({ token: zt, factory: zt.\u0275fac, providedIn: "root" }); const cs = ["fxLayoutGap", "fxLayoutGap.xs", "fxLayoutGap.sm", "fxLayoutGap.md", "fxLayoutGap.lg", "fxLayoutGap.xl", "fxLayoutGap.lt-sm", "fxLayoutGap.lt-md", "fxLayoutGap.lt-lg", "fxLayoutGap.lt-xl", "fxLayoutGap.gt-xs", "fxLayoutGap.gt-sm", "fxLayoutGap.gt-md", "fxLayoutGap.gt-lg"]; class Pe extends _e { constructor(s, i, d, f, w, T) { super(s, w, f, T), this.zone = i, this.directionality = d, this.styleUtils = f, this.layout = "row", this.DIRECTIVE_KEY = "layout-gap", this.observerSubject = new F.x; const le = [this.directionality.change, this.observerSubject.asObservable()]; this.init(le), this.marshal.trackValue(this.nativeElement, "layout").pipe((0, As.R)(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)) } get childrenNodes() { const s = this.nativeElement.children, i = []; for (let d = s.length; d--;)i[d] = s[d]; return i } ngAfterContentInit() { this.buildChildObservable(), this.triggerUpdate() } ngOnDestroy() { super.ngOnDestroy(), this.observer && this.observer.disconnect() } onLayoutChange(s) { const d = s.value.split(" "); this.layout = d[0], Dt.find(f => f === this.layout) || (this.layout = "row"), this.triggerUpdate() } updateWithValue(s) { const i = this.childrenNodes.filter(d => 1 === d.nodeType && this.willDisplay(d)).sort((d, f) => { const w = +this.styler.lookupStyle(d, "order"), T = +this.styler.lookupStyle(f, "order"); return isNaN(w) || isNaN(T) || w === T ? 0 : w > T ? 1 : -1 }); if (i.length > 0) { const d = this.directionality.value, f = this.layout; "row" === f && "rtl" === d ? this.styleCache = ws : "row" === f && "rtl" !== d ? this.styleCache = yn : "column" === f && "rtl" === d ? this.styleCache = Us : "column" === f && "rtl" !== d && (this.styleCache = yi), this.addStyles(s, { directionality: d, items: i, layout: f }) } } clearStyles() { const s = Object.keys(this.mru).length > 0, i = s ? "padding" : je(this.directionality.value, this.layout); s && super.clearStyles(), this.styleUtils.applyStyleToElements({ [i]: "" }, this.childrenNodes) } willDisplay(s) { const i = this.marshal.getValue(s, "show-hide"); return !0 === i || void 0 === i && "none" !== this.styleUtils.lookupStyle(s, "display") } buildChildObservable() { this.zone.runOutsideAngular(() => { "undefined" != typeof MutationObserver && (this.observer = new MutationObserver(s => { s.some(d => d.addedNodes && d.addedNodes.length > 0 || d.removedNodes && d.removedNodes.length > 0) && this.observerSubject.next() }), this.observer.observe(this.nativeElement, { childList: !0 })) }) } } Pe.\u0275fac = function (s) { return new (s || Pe)(o.Y36(o.SBq), o.Y36(o.R0b), o.Y36(Et.Is), o.Y36(ie), o.Y36(zt), o.Y36(me)) }, Pe.\u0275dir = o.lG2({ type: Pe, features: [o.qOj] }); class we extends Pe { constructor() { super(...arguments), this.inputs = cs } } we.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(we)))(i || we) } }(), we.\u0275dir = o.lG2({ type: we, selectors: [["", "fxLayoutGap", ""], ["", "fxLayoutGap.xs", ""], ["", "fxLayoutGap.sm", ""], ["", "fxLayoutGap.md", ""], ["", "fxLayoutGap.lg", ""], ["", "fxLayoutGap.xl", ""], ["", "fxLayoutGap.lt-sm", ""], ["", "fxLayoutGap.lt-md", ""], ["", "fxLayoutGap.lt-lg", ""], ["", "fxLayoutGap.lt-xl", ""], ["", "fxLayoutGap.gt-xs", ""], ["", "fxLayoutGap.gt-sm", ""], ["", "fxLayoutGap.gt-md", ""], ["", "fxLayoutGap.gt-lg", ""]], inputs: { fxLayoutGap: "fxLayoutGap", "fxLayoutGap.xs": "fxLayoutGap.xs", "fxLayoutGap.sm": "fxLayoutGap.sm", "fxLayoutGap.md": "fxLayoutGap.md", "fxLayoutGap.lg": "fxLayoutGap.lg", "fxLayoutGap.xl": "fxLayoutGap.xl", "fxLayoutGap.lt-sm": "fxLayoutGap.lt-sm", "fxLayoutGap.lt-md": "fxLayoutGap.lt-md", "fxLayoutGap.lt-lg": "fxLayoutGap.lt-lg", "fxLayoutGap.lt-xl": "fxLayoutGap.lt-xl", "fxLayoutGap.gt-xs": "fxLayoutGap.gt-xs", "fxLayoutGap.gt-sm": "fxLayoutGap.gt-sm", "fxLayoutGap.gt-md": "fxLayoutGap.gt-md", "fxLayoutGap.gt-lg": "fxLayoutGap.gt-lg" }, features: [o.qOj] }); const ws = new Map, Us = new Map, yn = new Map, yi = new Map, ds = " grid"; function je(l, s) { switch (s) { case "column": return "margin-bottom"; case "column-reverse": return "margin-top"; default: return "rtl" === l ? "margin-left" : "margin-right"; case "row-reverse": return "rtl" === l ? "margin-right" : "margin-left" } } class us extends Se { constructor(s) { super(), this.layoutConfig = s } buildStyles(s, i) { let [d, f, ...w] = s.split(" "), T = w.join(" "); const le = i.direction.indexOf("column") > -1 ? "column" : "row", Ne = vs(le) ? "max-width" : "max-height", Ws = vs(le) ? "min-width" : "min-height", Xt = String(T).indexOf("calc") > -1, Er = Xt || "auto" === T, wr = String(T).indexOf("%") > -1 && !Xt, Cr = String(T).indexOf("px") > -1 || String(T).indexOf("rem") > -1 || String(T).indexOf("em") > -1 || String(T).indexOf("vw") > -1 || String(T).indexOf("vh") > -1; let Ti = Xt || Cr; d = "0" == d ? 0 : d, f = "0" == f ? 0 : f; const er = !d && !f; let Re = {}; const ni = { "max-width": null, "max-height": null, "min-width": null, "min-height": null }; switch (T || "") { case "": const Mr = !1 !== this.layoutConfig.useColumnBasisZero; T = "row" === le ? "0%" : Mr ? "0.000000001px" : "auto"; break; case "initial": case "nogrow": d = 0, T = "auto"; break; case "grow": T = "100%"; break; case "noshrink": f = 0, T = "auto"; break; case "auto": break; case "none": d = 0, f = 0, T = "auto"; break; default: !Ti && !wr && !isNaN(T) && (T += "%"), "0%" === T && (Ti = !0), "0px" === T && (T = "0%"), Re = It(ni, Xt ? { "flex-grow": d, "flex-shrink": f, "flex-basis": Ti ? T : "100%" } : { flex: `${d} ${f} ${Ti ? T : "100%"}` }) }return Re.flex || Re["flex-grow"] || (Re = It(ni, Xt ? { "flex-grow": d, "flex-shrink": f, "flex-basis": T } : { flex: `${d} ${f} ${T}` })), "0%" !== T && "0px" !== T && "0.000000001px" !== T && "auto" !== T && (Re[Ws] = er || Ti && d ? T : null, Re[Ne] = er || !Er && f ? T : null), Re[Ws] || Re[Ne] ? i.hasWrap && (Re[Xt ? "flex-basis" : "flex"] = Re[Ne] ? Xt ? Re[Ne] : `${d} ${f} ${Re[Ne]}` : Xt ? Re[Ws] : `${d} ${f} ${Re[Ws]}`) : Re = It(ni, Xt ? { "flex-grow": d, "flex-shrink": f, "flex-basis": T } : { flex: `${d} ${f} ${T}` }), It(Re, { "box-sizing": "border-box" }) } } us.\u0275fac = function (s) { return new (s || us)(o.LFG(Ye)) }, us.\u0275prov = o.Yz7({ token: us, factory: us.\u0275fac, providedIn: "root" }); const zn = ["fxFlex", "fxFlex.xs", "fxFlex.sm", "fxFlex.md", "fxFlex.lg", "fxFlex.xl", "fxFlex.lt-sm", "fxFlex.lt-md", "fxFlex.lt-lg", "fxFlex.lt-xl", "fxFlex.gt-xs", "fxFlex.gt-sm", "fxFlex.gt-md", "fxFlex.gt-lg"]; class hs extends _e { constructor(s, i, d, f, w) { super(s, f, i, w), this.layoutConfig = d, this.marshal = w, this.DIRECTIVE_KEY = "flex", this.direction = void 0, this.wrap = void 0, this.flexGrow = "1", this.flexShrink = "1", this.init() } get shrink() { return this.flexShrink } set shrink(s) { this.flexShrink = s || "1", this.triggerReflow() } get grow() { return this.flexGrow } set grow(s) { this.flexGrow = s || "1", this.triggerReflow() } ngOnInit() { this.parentElement && (this.marshal.trackValue(this.parentElement, "layout").pipe((0, As.R)(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)), this.marshal.trackValue(this.nativeElement, "layout-align").pipe((0, As.R)(this.destroySubject)).subscribe(this.triggerReflow.bind(this))) } onLayoutChange(s) { const d = s.value.split(" "); this.direction = d[0], this.wrap = void 0 !== d[1] && "wrap" === d[1], this.triggerUpdate() } updateWithValue(s) { const i = !1 !== this.layoutConfig.addFlexToParent; void 0 === this.direction && (this.direction = this.getFlexFlowDirection(this.parentElement, i)), void 0 === this.wrap && (this.wrap = this.hasWrap(this.parentElement)); const d = this.direction, f = d.startsWith("row"), w = this.wrap; f && w ? this.styleCache = Vs : f && !w ? this.styleCache = Un : !f && w ? this.styleCache = xi : !f && !w && (this.styleCache = Ut); const le = di(String(s).replace(";", ""), this.flexGrow, this.flexShrink); this.addStyles(le.join(" "), { direction: d, hasWrap: w }) } triggerReflow() { const s = this.activatedValue; if (void 0 !== s) { const i = di(s + "", this.flexGrow, this.flexShrink); this.marshal.updateElement(this.nativeElement, this.DIRECTIVE_KEY, i.join(" ")) } } } hs.\u0275fac = function (s) { return new (s || hs)(o.Y36(o.SBq), o.Y36(ie), o.Y36(Ye), o.Y36(us), o.Y36(me)) }, hs.\u0275dir = o.lG2({ type: hs, inputs: { shrink: ["fxShrink", "shrink"], grow: ["fxGrow", "grow"] }, features: [o.qOj] }); class wt extends hs { constructor() { super(...arguments), this.inputs = zn } } wt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(wt)))(i || wt) } }(), wt.\u0275dir = o.lG2({ type: wt, selectors: [["", "fxFlex", ""], ["", "fxFlex.xs", ""], ["", "fxFlex.sm", ""], ["", "fxFlex.md", ""], ["", "fxFlex.lg", ""], ["", "fxFlex.xl", ""], ["", "fxFlex.lt-sm", ""], ["", "fxFlex.lt-md", ""], ["", "fxFlex.lt-lg", ""], ["", "fxFlex.lt-xl", ""], ["", "fxFlex.gt-xs", ""], ["", "fxFlex.gt-sm", ""], ["", "fxFlex.gt-md", ""], ["", "fxFlex.gt-lg", ""]], inputs: { fxFlex: "fxFlex", "fxFlex.xs": "fxFlex.xs", "fxFlex.sm": "fxFlex.sm", "fxFlex.md": "fxFlex.md", "fxFlex.lg": "fxFlex.lg", "fxFlex.xl": "fxFlex.xl", "fxFlex.lt-sm": "fxFlex.lt-sm", "fxFlex.lt-md": "fxFlex.lt-md", "fxFlex.lt-lg": "fxFlex.lt-lg", "fxFlex.lt-xl": "fxFlex.lt-xl", "fxFlex.gt-xs": "fxFlex.gt-xs", "fxFlex.gt-sm": "fxFlex.gt-sm", "fxFlex.gt-md": "fxFlex.gt-md", "fxFlex.gt-lg": "fxFlex.gt-lg" }, features: [o.qOj] }); const Un = new Map, Ut = new Map, Vs = new Map, xi = new Map; class Vt extends Se { buildStyles(s) { return { order: s && parseInt(s, 10) || "" } } } Vt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Vt)))(i || Vt) } }(), Vt.\u0275prov = o.Yz7({ token: Vt, factory: Vt.\u0275fac, providedIn: "root" }); const Vn = ["fxFlexOrder", "fxFlexOrder.xs", "fxFlexOrder.sm", "fxFlexOrder.md", "fxFlexOrder.lg", "fxFlexOrder.xl", "fxFlexOrder.lt-sm", "fxFlexOrder.lt-md", "fxFlexOrder.lt-lg", "fxFlexOrder.lt-xl", "fxFlexOrder.gt-xs", "fxFlexOrder.gt-sm", "fxFlexOrder.gt-md", "fxFlexOrder.gt-lg"]; class xt extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "flex-order", this.styleCache = Ys, this.init() } } xt.\u0275fac = function (s) { return new (s || xt)(o.Y36(o.SBq), o.Y36(ie), o.Y36(Vt), o.Y36(me)) }, xt.\u0275dir = o.lG2({ type: xt, features: [o.qOj] }); const Ys = new Map; class Yt extends xt { constructor() { super(...arguments), this.inputs = Vn } } Yt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Yt)))(i || Yt) } }(), Yt.\u0275dir = o.lG2({ type: Yt, selectors: [["", "fxFlexOrder", ""], ["", "fxFlexOrder.xs", ""], ["", "fxFlexOrder.sm", ""], ["", "fxFlexOrder.md", ""], ["", "fxFlexOrder.lg", ""], ["", "fxFlexOrder.xl", ""], ["", "fxFlexOrder.lt-sm", ""], ["", "fxFlexOrder.lt-md", ""], ["", "fxFlexOrder.lt-lg", ""], ["", "fxFlexOrder.lt-xl", ""], ["", "fxFlexOrder.gt-xs", ""], ["", "fxFlexOrder.gt-sm", ""], ["", "fxFlexOrder.gt-md", ""], ["", "fxFlexOrder.gt-lg", ""]], inputs: { fxFlexOrder: "fxFlexOrder", "fxFlexOrder.xs": "fxFlexOrder.xs", "fxFlexOrder.sm": "fxFlexOrder.sm", "fxFlexOrder.md": "fxFlexOrder.md", "fxFlexOrder.lg": "fxFlexOrder.lg", "fxFlexOrder.xl": "fxFlexOrder.xl", "fxFlexOrder.lt-sm": "fxFlexOrder.lt-sm", "fxFlexOrder.lt-md": "fxFlexOrder.lt-md", "fxFlexOrder.lt-lg": "fxFlexOrder.lt-lg", "fxFlexOrder.lt-xl": "fxFlexOrder.lt-xl", "fxFlexOrder.gt-xs": "fxFlexOrder.gt-xs", "fxFlexOrder.gt-sm": "fxFlexOrder.gt-sm", "fxFlexOrder.gt-md": "fxFlexOrder.gt-md", "fxFlexOrder.gt-lg": "fxFlexOrder.gt-lg" }, features: [o.qOj] }); class $t extends Se { buildStyles(s, i) { "" === s && (s = "0"); const d = String(s).indexOf("%") > -1; !(String(s).indexOf("px") > -1) && !d && !isNaN(+s) && (s += "%"); const w = i.isRtl ? "margin-right" : "margin-left"; return vs(i.layout) ? { [w]: `${s}` } : { "margin-top": `${s}` } } } $t.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z($t)))(i || $t) } }(), $t.\u0275prov = o.Yz7({ token: $t, factory: $t.\u0275fac, providedIn: "root" }); const vi = ["fxFlexOffset", "fxFlexOffset.xs", "fxFlexOffset.sm", "fxFlexOffset.md", "fxFlexOffset.lg", "fxFlexOffset.xl", "fxFlexOffset.lt-sm", "fxFlexOffset.lt-md", "fxFlexOffset.lt-lg", "fxFlexOffset.lt-xl", "fxFlexOffset.gt-xs", "fxFlexOffset.gt-sm", "fxFlexOffset.gt-md", "fxFlexOffset.gt-lg"]; class at extends _e { constructor(s, i, d, f, w) { super(s, d, w, f), this.directionality = i, this.DIRECTIVE_KEY = "flex-offset", this.init([this.directionality.change]), this.parentElement && this.marshal.trackValue(this.parentElement, "layout-gap").pipe((0, As.R)(this.destroySubject)).subscribe(this.triggerUpdate.bind(this)) } updateWithValue(s = "") { const i = this.getFlexFlowDirection(this.parentElement, !0), d = "rtl" === this.directionality.value; "row" === i && d ? this.styleCache = Cs : "row" !== i || d ? "column" === i && d ? this.styleCache = _n : "column" === i && !d && (this.styleCache = $n) : this.styleCache = Ai, this.addStyles(s + "", { layout: i, isRtl: d }) } } at.\u0275fac = function (s) { return new (s || at)(o.Y36(o.SBq), o.Y36(Et.Is), o.Y36($t), o.Y36(me), o.Y36(ie)) }, at.\u0275dir = o.lG2({ type: at, features: [o.qOj] }); class Ot extends at { constructor() { super(...arguments), this.inputs = vi } } Ot.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Ot)))(i || Ot) } }(), Ot.\u0275dir = o.lG2({ type: Ot, selectors: [["", "fxFlexOffset", ""], ["", "fxFlexOffset.xs", ""], ["", "fxFlexOffset.sm", ""], ["", "fxFlexOffset.md", ""], ["", "fxFlexOffset.lg", ""], ["", "fxFlexOffset.xl", ""], ["", "fxFlexOffset.lt-sm", ""], ["", "fxFlexOffset.lt-md", ""], ["", "fxFlexOffset.lt-lg", ""], ["", "fxFlexOffset.lt-xl", ""], ["", "fxFlexOffset.gt-xs", ""], ["", "fxFlexOffset.gt-sm", ""], ["", "fxFlexOffset.gt-md", ""], ["", "fxFlexOffset.gt-lg", ""]], inputs: { fxFlexOffset: "fxFlexOffset", "fxFlexOffset.xs": "fxFlexOffset.xs", "fxFlexOffset.sm": "fxFlexOffset.sm", "fxFlexOffset.md": "fxFlexOffset.md", "fxFlexOffset.lg": "fxFlexOffset.lg", "fxFlexOffset.xl": "fxFlexOffset.xl", "fxFlexOffset.lt-sm": "fxFlexOffset.lt-sm", "fxFlexOffset.lt-md": "fxFlexOffset.lt-md", "fxFlexOffset.lt-lg": "fxFlexOffset.lt-lg", "fxFlexOffset.lt-xl": "fxFlexOffset.lt-xl", "fxFlexOffset.gt-xs": "fxFlexOffset.gt-xs", "fxFlexOffset.gt-sm": "fxFlexOffset.gt-sm", "fxFlexOffset.gt-md": "fxFlexOffset.gt-md", "fxFlexOffset.gt-lg": "fxFlexOffset.gt-lg" }, features: [o.qOj] }); const Cs = new Map, _n = new Map, Ai = new Map, $n = new Map; class Xe extends Se { buildStyles(s) { const i = {}; switch (s = s || "stretch") { case "start": i["align-self"] = "flex-start"; break; case "end": i["align-self"] = "flex-end"; break; default: i["align-self"] = s }return i } } Xe.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Xe)))(i || Xe) } }(), Xe.\u0275prov = o.Yz7({ token: Xe, factory: Xe.\u0275fac, providedIn: "root" }); const Kt = ["fxFlexAlign", "fxFlexAlign.xs", "fxFlexAlign.sm", "fxFlexAlign.md", "fxFlexAlign.lg", "fxFlexAlign.xl", "fxFlexAlign.lt-sm", "fxFlexAlign.lt-md", "fxFlexAlign.lt-lg", "fxFlexAlign.lt-xl", "fxFlexAlign.gt-xs", "fxFlexAlign.gt-sm", "fxFlexAlign.gt-md", "fxFlexAlign.gt-lg"]; class Ms extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "flex-align", this.styleCache = Kn, this.init() } } Ms.\u0275fac = function (s) { return new (s || Ms)(o.Y36(o.SBq), o.Y36(ie), o.Y36(Xe), o.Y36(me)) }, Ms.\u0275dir = o.lG2({ type: Ms, features: [o.qOj] }); const Kn = new Map; class Je extends Ms { constructor() { super(...arguments), this.inputs = Kt } } Je.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Je)))(i || Je) } }(), Je.\u0275dir = o.lG2({ type: Je, selectors: [["", "fxFlexAlign", ""], ["", "fxFlexAlign.xs", ""], ["", "fxFlexAlign.sm", ""], ["", "fxFlexAlign.md", ""], ["", "fxFlexAlign.lg", ""], ["", "fxFlexAlign.xl", ""], ["", "fxFlexAlign.lt-sm", ""], ["", "fxFlexAlign.lt-md", ""], ["", "fxFlexAlign.lt-lg", ""], ["", "fxFlexAlign.lt-xl", ""], ["", "fxFlexAlign.gt-xs", ""], ["", "fxFlexAlign.gt-sm", ""], ["", "fxFlexAlign.gt-md", ""], ["", "fxFlexAlign.gt-lg", ""]], inputs: { fxFlexAlign: "fxFlexAlign", "fxFlexAlign.xs": "fxFlexAlign.xs", "fxFlexAlign.sm": "fxFlexAlign.sm", "fxFlexAlign.md": "fxFlexAlign.md", "fxFlexAlign.lg": "fxFlexAlign.lg", "fxFlexAlign.xl": "fxFlexAlign.xl", "fxFlexAlign.lt-sm": "fxFlexAlign.lt-sm", "fxFlexAlign.lt-md": "fxFlexAlign.lt-md", "fxFlexAlign.lt-lg": "fxFlexAlign.lt-lg", "fxFlexAlign.lt-xl": "fxFlexAlign.lt-xl", "fxFlexAlign.gt-xs": "fxFlexAlign.gt-xs", "fxFlexAlign.gt-sm": "fxFlexAlign.gt-sm", "fxFlexAlign.gt-md": "fxFlexAlign.gt-md", "fxFlexAlign.gt-lg": "fxFlexAlign.gt-lg" }, features: [o.qOj] }); const $s = { margin: 0, width: "100%", height: "100%", "min-width": "100%", "min-height": "100%" }; class jt extends Se { buildStyles(s) { return $s } } jt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(jt)))(i || jt) } }(), jt.\u0275prov = o.Yz7({ token: jt, factory: jt.\u0275fac, providedIn: "root" }); class Lt extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.styleCache = Ht, this.addStyles("") } } Lt.\u0275fac = function (s) { return new (s || Lt)(o.Y36(o.SBq), o.Y36(ie), o.Y36(jt), o.Y36(me)) }, Lt.\u0275dir = o.lG2({ type: Lt, selectors: [["", "fxFill", ""], ["", "fxFlexFill", ""]], features: [o.qOj] }); const Ht = new Map; class Ct extends Se { buildStyles(s, i) { const d = {}, [f, w] = s.split(" "); switch (f) { case "center": d["justify-content"] = "center"; break; case "space-around": d["justify-content"] = "space-around"; break; case "space-between": d["justify-content"] = "space-between"; break; case "space-evenly": d["justify-content"] = "space-evenly"; break; case "end": case "flex-end": d["justify-content"] = "flex-end"; break; default: d["justify-content"] = "flex-start" }switch (w) { case "start": case "flex-start": d["align-items"] = d["align-content"] = "flex-start"; break; case "center": d["align-items"] = d["align-content"] = "center"; break; case "end": case "flex-end": d["align-items"] = d["align-content"] = "flex-end"; break; case "space-between": d["align-content"] = "space-between", d["align-items"] = "stretch"; break; case "space-around": d["align-content"] = "space-around", d["align-items"] = "stretch"; break; case "baseline": d["align-content"] = "stretch", d["align-items"] = "baseline"; break; default: d["align-items"] = d["align-content"] = "stretch" }return It(d, { display: i.inline ? "inline-flex" : "flex", "flex-direction": i.layout, "box-sizing": "border-box", "max-width": "stretch" === w ? vs(i.layout) ? null : "100%" : null, "max-height": "stretch" === w && vs(i.layout) ? "100%" : null }) } } Ct.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Ct)))(i || Ct) } }(), Ct.\u0275prov = o.Yz7({ token: Ct, factory: Ct.\u0275fac, providedIn: "root" }); const xn = ["fxLayoutAlign", "fxLayoutAlign.xs", "fxLayoutAlign.sm", "fxLayoutAlign.md", "fxLayoutAlign.lg", "fxLayoutAlign.xl", "fxLayoutAlign.lt-sm", "fxLayoutAlign.lt-md", "fxLayoutAlign.lt-lg", "fxLayoutAlign.lt-xl", "fxLayoutAlign.gt-xs", "fxLayoutAlign.gt-sm", "fxLayoutAlign.gt-md", "fxLayoutAlign.gt-lg"]; class Qt extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "layout-align", this.layout = "row", this.inline = !1, this.init(), this.marshal.trackValue(this.nativeElement, "layout").pipe((0, As.R)(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)) } updateWithValue(s) { const i = this.layout || "row", d = this.inline; "row" === i && d ? this.styleCache = Qn : "row" !== i || d ? "row-reverse" === i && d ? this.styleCache = Wn : "row-reverse" !== i || d ? "column" === i && d ? this.styleCache = Ks : "column" !== i || d ? "column-reverse" === i && d ? this.styleCache = ps : "column-reverse" === i && !d && (this.styleCache = Hn) : this.styleCache = Wt : this.styleCache = jn : this.styleCache = fs, this.addStyles(s, { layout: i, inline: d }) } onLayoutChange(s) { const i = s.value.split(" "); this.layout = i[0], this.inline = s.value.includes("inline"), Dt.find(d => d === this.layout) || (this.layout = "row"), this.triggerUpdate() } } Qt.\u0275fac = function (s) { return new (s || Qt)(o.Y36(o.SBq), o.Y36(ie), o.Y36(Ct), o.Y36(me)) }, Qt.\u0275dir = o.lG2({ type: Qt, features: [o.qOj] }); class He extends Qt { constructor() { super(...arguments), this.inputs = xn } } He.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(He)))(i || He) } }(), He.\u0275dir = o.lG2({ type: He, selectors: [["", "fxLayoutAlign", ""], ["", "fxLayoutAlign.xs", ""], ["", "fxLayoutAlign.sm", ""], ["", "fxLayoutAlign.md", ""], ["", "fxLayoutAlign.lg", ""], ["", "fxLayoutAlign.xl", ""], ["", "fxLayoutAlign.lt-sm", ""], ["", "fxLayoutAlign.lt-md", ""], ["", "fxLayoutAlign.lt-lg", ""], ["", "fxLayoutAlign.lt-xl", ""], ["", "fxLayoutAlign.gt-xs", ""], ["", "fxLayoutAlign.gt-sm", ""], ["", "fxLayoutAlign.gt-md", ""], ["", "fxLayoutAlign.gt-lg", ""]], inputs: { fxLayoutAlign: "fxLayoutAlign", "fxLayoutAlign.xs": "fxLayoutAlign.xs", "fxLayoutAlign.sm": "fxLayoutAlign.sm", "fxLayoutAlign.md": "fxLayoutAlign.md", "fxLayoutAlign.lg": "fxLayoutAlign.lg", "fxLayoutAlign.xl": "fxLayoutAlign.xl", "fxLayoutAlign.lt-sm": "fxLayoutAlign.lt-sm", "fxLayoutAlign.lt-md": "fxLayoutAlign.lt-md", "fxLayoutAlign.lt-lg": "fxLayoutAlign.lt-lg", "fxLayoutAlign.lt-xl": "fxLayoutAlign.lt-xl", "fxLayoutAlign.gt-xs": "fxLayoutAlign.gt-xs", "fxLayoutAlign.gt-sm": "fxLayoutAlign.gt-sm", "fxLayoutAlign.gt-md": "fxLayoutAlign.gt-md", "fxLayoutAlign.gt-lg": "fxLayoutAlign.gt-lg" }, features: [o.qOj] }); const fs = new Map, Wt = new Map, jn = new Map, Hn = new Map, Qn = new Map, Ks = new Map, Wn = new Map, ps = new Map; class ms { } ms.\u0275fac = function (s) { return new (s || ms) }, ms.\u0275mod = o.oAB({ type: ms }), ms.\u0275inj = o.cJS({ imports: [[Ve, Et.vT]] }); const Ds = "stretch", vn = "stretch"; class Qe extends Se { buildStyles(s) { return function (l = "") { const s = {}, [i, d] = l.split(" "); switch (i) { case "end": s["justify-self"] = "end"; break; case "center": s["justify-self"] = "center"; break; case "stretch": s["justify-self"] = "stretch"; break; case "start": s["justify-self"] = "start"; break; default: s["justify-self"] = Ds }switch (d) { case "end": s["align-self"] = "end"; break; case "center": s["align-self"] = "center"; break; case "stretch": s["align-self"] = "stretch"; break; case "start": s["align-self"] = "start"; break; default: s["align-self"] = vn }return s }(s || Ds) } } Qe.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Qe)))(i || Qe) } }(), Qe.\u0275prov = o.Yz7({ token: Qe, factory: Qe.\u0275fac, providedIn: "root" }); class Is extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-align", this.styleCache = Ei, this.init() } } Is.\u0275fac = function (s) { return new (s || Is)(o.Y36(o.SBq), o.Y36(Qe), o.Y36(ie), o.Y36(me)) }, Is.\u0275dir = o.lG2({ type: Is, features: [o.qOj] }); const Ei = new Map, et = ["gdGridAlign", "gdGridAlign.xs", "gdGridAlign.sm", "gdGridAlign.md", "gdGridAlign.lg", "gdGridAlign.xl", "gdGridAlign.lt-sm", "gdGridAlign.lt-md", "gdGridAlign.lt-lg", "gdGridAlign.lt-xl", "gdGridAlign.gt-xs", "gdGridAlign.gt-sm", "gdGridAlign.gt-md", "gdGridAlign.gt-lg"]; class ys extends Is { constructor() { super(...arguments), this.inputs = et } } ys.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(ys)))(i || ys) } }(), ys.\u0275dir = o.lG2({ type: ys, selectors: [["", "gdGridAlign", ""], ["", "gdGridAlign.xs", ""], ["", "gdGridAlign.sm", ""], ["", "gdGridAlign.md", ""], ["", "gdGridAlign.lg", ""], ["", "gdGridAlign.xl", ""], ["", "gdGridAlign.lt-sm", ""], ["", "gdGridAlign.lt-md", ""], ["", "gdGridAlign.lt-lg", ""], ["", "gdGridAlign.lt-xl", ""], ["", "gdGridAlign.gt-xs", ""], ["", "gdGridAlign.gt-sm", ""], ["", "gdGridAlign.gt-md", ""], ["", "gdGridAlign.gt-lg", ""]], inputs: { gdGridAlign: "gdGridAlign", "gdGridAlign.xs": "gdGridAlign.xs", "gdGridAlign.sm": "gdGridAlign.sm", "gdGridAlign.md": "gdGridAlign.md", "gdGridAlign.lg": "gdGridAlign.lg", "gdGridAlign.xl": "gdGridAlign.xl", "gdGridAlign.lt-sm": "gdGridAlign.lt-sm", "gdGridAlign.lt-md": "gdGridAlign.lt-md", "gdGridAlign.lt-lg": "gdGridAlign.lt-lg", "gdGridAlign.lt-xl": "gdGridAlign.lt-xl", "gdGridAlign.gt-xs": "gdGridAlign.gt-xs", "gdGridAlign.gt-sm": "gdGridAlign.gt-sm", "gdGridAlign.gt-md": "gdGridAlign.gt-md", "gdGridAlign.gt-lg": "gdGridAlign.gt-lg" }, features: [o.qOj] }); const An = "start", kt = "stretch"; class vt extends Se { buildStyles(s, i) { return function (l, s) { const i = {}, [d, f] = l.split(" "); switch (d) { case "center": i["align-content"] = "center"; break; case "space-around": i["align-content"] = "space-around"; break; case "space-between": i["align-content"] = "space-between"; break; case "space-evenly": i["align-content"] = "space-evenly"; break; case "end": i["align-content"] = "end"; break; case "start": i["align-content"] = "start"; break; case "stretch": i["align-content"] = "stretch"; break; default: i["align-content"] = An }switch (f) { case "start": i["align-items"] = "start"; break; case "center": i["align-items"] = "center"; break; case "end": i["align-items"] = "end"; break; case "stretch": i["align-items"] = "stretch"; break; default: i["align-items"] = kt }return i.display = s ? "inline-grid" : "grid", i }(s || `start ${kt}`, i.inline) } } vt.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(vt)))(i || vt) } }(), vt.\u0275prov = o.Yz7({ token: vt, factory: vt.\u0275fac, providedIn: "root" }); class u extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-align-columns", this._inline = !1, this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? t : e, this.addStyles(s, { inline: this.inline }) } } u.\u0275fac = function (s) { return new (s || u)(o.Y36(o.SBq), o.Y36(vt), o.Y36(ie), o.Y36(me)) }, u.\u0275dir = o.lG2({ type: u, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const e = new Map, t = new Map, r = ["gdAlignColumns", "gdAlignColumns.xs", "gdAlignColumns.sm", "gdAlignColumns.md", "gdAlignColumns.lg", "gdAlignColumns.xl", "gdAlignColumns.lt-sm", "gdAlignColumns.lt-md", "gdAlignColumns.lt-lg", "gdAlignColumns.lt-xl", "gdAlignColumns.gt-xs", "gdAlignColumns.gt-sm", "gdAlignColumns.gt-md", "gdAlignColumns.gt-lg"]; class g extends u { constructor() { super(...arguments), this.inputs = r } } g.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(g)))(i || g) } }(), g.\u0275dir = o.lG2({ type: g, selectors: [["", "gdAlignColumns", ""], ["", "gdAlignColumns.xs", ""], ["", "gdAlignColumns.sm", ""], ["", "gdAlignColumns.md", ""], ["", "gdAlignColumns.lg", ""], ["", "gdAlignColumns.xl", ""], ["", "gdAlignColumns.lt-sm", ""], ["", "gdAlignColumns.lt-md", ""], ["", "gdAlignColumns.lt-lg", ""], ["", "gdAlignColumns.lt-xl", ""], ["", "gdAlignColumns.gt-xs", ""], ["", "gdAlignColumns.gt-sm", ""], ["", "gdAlignColumns.gt-md", ""], ["", "gdAlignColumns.gt-lg", ""]], inputs: { gdAlignColumns: "gdAlignColumns", "gdAlignColumns.xs": "gdAlignColumns.xs", "gdAlignColumns.sm": "gdAlignColumns.sm", "gdAlignColumns.md": "gdAlignColumns.md", "gdAlignColumns.lg": "gdAlignColumns.lg", "gdAlignColumns.xl": "gdAlignColumns.xl", "gdAlignColumns.lt-sm": "gdAlignColumns.lt-sm", "gdAlignColumns.lt-md": "gdAlignColumns.lt-md", "gdAlignColumns.lt-lg": "gdAlignColumns.lt-lg", "gdAlignColumns.lt-xl": "gdAlignColumns.lt-xl", "gdAlignColumns.gt-xs": "gdAlignColumns.gt-xs", "gdAlignColumns.gt-sm": "gdAlignColumns.gt-sm", "gdAlignColumns.gt-md": "gdAlignColumns.gt-md", "gdAlignColumns.gt-lg": "gdAlignColumns.gt-lg" }, features: [o.qOj] }); const b = "start", E = "stretch"; class D extends Se { buildStyles(s, i) { return function (l, s) { const i = {}, [d, f] = l.split(" "); switch (d) { case "center": case "space-around": case "space-between": case "space-evenly": case "end": case "start": case "stretch": i["justify-content"] = d; break; default: i["justify-content"] = b }switch (f) { case "start": case "center": case "end": case "stretch": i["justify-items"] = f; break; default: i["justify-items"] = E }return i.display = s ? "inline-grid" : "grid", i }(s || `${b} ${E}`, i.inline) } } D.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(D)))(i || D) } }(), D.\u0275prov = o.Yz7({ token: D, factory: D.\u0275fac, providedIn: "root" }); class R extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-align-rows", this._inline = !1, this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? X : U, this.addStyles(s, { inline: this.inline }) } } R.\u0275fac = function (s) { return new (s || R)(o.Y36(o.SBq), o.Y36(D), o.Y36(ie), o.Y36(me)) }, R.\u0275dir = o.lG2({ type: R, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const U = new Map, X = new Map, ne = ["gdAlignRows", "gdAlignRows.xs", "gdAlignRows.sm", "gdAlignRows.md", "gdAlignRows.lg", "gdAlignRows.xl", "gdAlignRows.lt-sm", "gdAlignRows.lt-md", "gdAlignRows.lt-lg", "gdAlignRows.lt-xl", "gdAlignRows.gt-xs", "gdAlignRows.gt-sm", "gdAlignRows.gt-md", "gdAlignRows.gt-lg"]; class K extends R { constructor() { super(...arguments), this.inputs = ne } } K.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(K)))(i || K) } }(), K.\u0275dir = o.lG2({ type: K, selectors: [["", "gdAlignRows", ""], ["", "gdAlignRows.xs", ""], ["", "gdAlignRows.sm", ""], ["", "gdAlignRows.md", ""], ["", "gdAlignRows.lg", ""], ["", "gdAlignRows.xl", ""], ["", "gdAlignRows.lt-sm", ""], ["", "gdAlignRows.lt-md", ""], ["", "gdAlignRows.lt-lg", ""], ["", "gdAlignRows.lt-xl", ""], ["", "gdAlignRows.gt-xs", ""], ["", "gdAlignRows.gt-sm", ""], ["", "gdAlignRows.gt-md", ""], ["", "gdAlignRows.gt-lg", ""]], inputs: { gdAlignRows: "gdAlignRows", "gdAlignRows.xs": "gdAlignRows.xs", "gdAlignRows.sm": "gdAlignRows.sm", "gdAlignRows.md": "gdAlignRows.md", "gdAlignRows.lg": "gdAlignRows.lg", "gdAlignRows.xl": "gdAlignRows.xl", "gdAlignRows.lt-sm": "gdAlignRows.lt-sm", "gdAlignRows.lt-md": "gdAlignRows.lt-md", "gdAlignRows.lt-lg": "gdAlignRows.lt-lg", "gdAlignRows.lt-xl": "gdAlignRows.lt-xl", "gdAlignRows.gt-xs": "gdAlignRows.gt-xs", "gdAlignRows.gt-sm": "gdAlignRows.gt-sm", "gdAlignRows.gt-md": "gdAlignRows.gt-md", "gdAlignRows.gt-lg": "gdAlignRows.gt-lg" }, features: [o.qOj] }); class ue extends Se { buildStyles(s) { return { "grid-area": s || "auto" } } } ue.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(ue)))(i || ue) } }(), ue.\u0275prov = o.Yz7({ token: ue, factory: ue.\u0275fac, providedIn: "root" }); class Ie extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "grid-area", this.styleCache = Fe, this.init() } } Ie.\u0275fac = function (s) { return new (s || Ie)(o.Y36(o.SBq), o.Y36(ie), o.Y36(ue), o.Y36(me)) }, Ie.\u0275dir = o.lG2({ type: Ie, features: [o.qOj] }); const Fe = new Map, _s = ["gdArea", "gdArea.xs", "gdArea.sm", "gdArea.md", "gdArea.lg", "gdArea.xl", "gdArea.lt-sm", "gdArea.lt-md", "gdArea.lt-lg", "gdArea.lt-xl", "gdArea.gt-xs", "gdArea.gt-sm", "gdArea.gt-md", "gdArea.gt-lg"]; class Ce extends Ie { constructor() { super(...arguments), this.inputs = _s } } Ce.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Ce)))(i || Ce) } }(), Ce.\u0275dir = o.lG2({ type: Ce, selectors: [["", "gdArea", ""], ["", "gdArea.xs", ""], ["", "gdArea.sm", ""], ["", "gdArea.md", ""], ["", "gdArea.lg", ""], ["", "gdArea.xl", ""], ["", "gdArea.lt-sm", ""], ["", "gdArea.lt-md", ""], ["", "gdArea.lt-lg", ""], ["", "gdArea.lt-xl", ""], ["", "gdArea.gt-xs", ""], ["", "gdArea.gt-sm", ""], ["", "gdArea.gt-md", ""], ["", "gdArea.gt-lg", ""]], inputs: { gdArea: "gdArea", "gdArea.xs": "gdArea.xs", "gdArea.sm": "gdArea.sm", "gdArea.md": "gdArea.md", "gdArea.lg": "gdArea.lg", "gdArea.xl": "gdArea.xl", "gdArea.lt-sm": "gdArea.lt-sm", "gdArea.lt-md": "gdArea.lt-md", "gdArea.lt-lg": "gdArea.lt-lg", "gdArea.lt-xl": "gdArea.lt-xl", "gdArea.gt-xs": "gdArea.gt-xs", "gdArea.gt-sm": "gdArea.gt-sm", "gdArea.gt-md": "gdArea.gt-md", "gdArea.gt-lg": "gdArea.gt-lg" }, features: [o.qOj] }); class ke extends Se { buildStyles(s, i) { const d = (s || "none").split("|").map(f => `"${f.trim()}"`); return { display: i.inline ? "inline-grid" : "grid", "grid-template-areas": d.join(" ") } } } ke.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(ke)))(i || ke) } }(), ke.\u0275prov = o.Yz7({ token: ke, factory: ke.\u0275fac, providedIn: "root" }); class xs extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "grid-areas", this._inline = !1, this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? ct : Ts, this.addStyles(s, { inline: this.inline }) } } xs.\u0275fac = function (s) { return new (s || xs)(o.Y36(o.SBq), o.Y36(ie), o.Y36(ke), o.Y36(me)) }, xs.\u0275dir = o.lG2({ type: xs, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const Ts = new Map, ct = new Map, qt = ["gdAreas", "gdAreas.xs", "gdAreas.sm", "gdAreas.md", "gdAreas.lg", "gdAreas.xl", "gdAreas.lt-sm", "gdAreas.lt-md", "gdAreas.lt-lg", "gdAreas.lt-xl", "gdAreas.gt-xs", "gdAreas.gt-sm", "gdAreas.gt-md", "gdAreas.gt-lg"]; class B extends xs { constructor() { super(...arguments), this.inputs = qt } } B.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(B)))(i || B) } }(), B.\u0275dir = o.lG2({ type: B, selectors: [["", "gdAreas", ""], ["", "gdAreas.xs", ""], ["", "gdAreas.sm", ""], ["", "gdAreas.md", ""], ["", "gdAreas.lg", ""], ["", "gdAreas.xl", ""], ["", "gdAreas.lt-sm", ""], ["", "gdAreas.lt-md", ""], ["", "gdAreas.lt-lg", ""], ["", "gdAreas.lt-xl", ""], ["", "gdAreas.gt-xs", ""], ["", "gdAreas.gt-sm", ""], ["", "gdAreas.gt-md", ""], ["", "gdAreas.gt-lg", ""]], inputs: { gdAreas: "gdAreas", "gdAreas.xs": "gdAreas.xs", "gdAreas.sm": "gdAreas.sm", "gdAreas.md": "gdAreas.md", "gdAreas.lg": "gdAreas.lg", "gdAreas.xl": "gdAreas.xl", "gdAreas.lt-sm": "gdAreas.lt-sm", "gdAreas.lt-md": "gdAreas.lt-md", "gdAreas.lt-lg": "gdAreas.lt-lg", "gdAreas.lt-xl": "gdAreas.lt-xl", "gdAreas.gt-xs": "gdAreas.gt-xs", "gdAreas.gt-sm": "gdAreas.gt-sm", "gdAreas.gt-md": "gdAreas.gt-md", "gdAreas.gt-lg": "gdAreas.gt-lg" }, features: [o.qOj] }); class H extends Se { buildStyles(s, i) { let [d, f] = (s || "initial").split(" "); return "column" !== d && "row" !== d && "dense" !== d && (d = "row"), f = "dense" === f && "dense" !== d ? " dense" : "", { display: i.inline ? "inline-grid" : "grid", "grid-auto-flow": d + f } } } H.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(H)))(i || H) } }(), H.\u0275prov = o.Yz7({ token: H, factory: H.\u0275fac, providedIn: "root" }); class re extends _e { constructor(s, i, d, f) { super(s, i, d, f), this._inline = !1, this.DIRECTIVE_KEY = "grid-auto", this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? dt : Ee, this.addStyles(s, { inline: this.inline }) } } re.\u0275fac = function (s) { return new (s || re)(o.Y36(o.SBq), o.Y36(H), o.Y36(ie), o.Y36(me)) }, re.\u0275dir = o.lG2({ type: re, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const Ee = new Map, dt = new Map, Oe = ["gdAuto", "gdAuto.xs", "gdAuto.sm", "gdAuto.md", "gdAuto.lg", "gdAuto.xl", "gdAuto.lt-sm", "gdAuto.lt-md", "gdAuto.lt-lg", "gdAuto.lt-xl", "gdAuto.gt-xs", "gdAuto.gt-sm", "gdAuto.gt-md", "gdAuto.gt-lg"]; class ye extends re { constructor() { super(...arguments), this.inputs = Oe } } ye.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(ye)))(i || ye) } }(), ye.\u0275dir = o.lG2({ type: ye, selectors: [["", "gdAuto", ""], ["", "gdAuto.xs", ""], ["", "gdAuto.sm", ""], ["", "gdAuto.md", ""], ["", "gdAuto.lg", ""], ["", "gdAuto.xl", ""], ["", "gdAuto.lt-sm", ""], ["", "gdAuto.lt-md", ""], ["", "gdAuto.lt-lg", ""], ["", "gdAuto.lt-xl", ""], ["", "gdAuto.gt-xs", ""], ["", "gdAuto.gt-sm", ""], ["", "gdAuto.gt-md", ""], ["", "gdAuto.gt-lg", ""]], inputs: { gdAuto: "gdAuto", "gdAuto.xs": "gdAuto.xs", "gdAuto.sm": "gdAuto.sm", "gdAuto.md": "gdAuto.md", "gdAuto.lg": "gdAuto.lg", "gdAuto.xl": "gdAuto.xl", "gdAuto.lt-sm": "gdAuto.lt-sm", "gdAuto.lt-md": "gdAuto.lt-md", "gdAuto.lt-lg": "gdAuto.lt-lg", "gdAuto.lt-xl": "gdAuto.lt-xl", "gdAuto.gt-xs": "gdAuto.gt-xs", "gdAuto.gt-sm": "gdAuto.gt-sm", "gdAuto.gt-md": "gdAuto.gt-md", "gdAuto.gt-lg": "gdAuto.gt-lg" }, features: [o.qOj] }); class Te extends Se { buildStyles(s) { return { "grid-column": s || "auto" } } } Te.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Te)))(i || Te) } }(), Te.\u0275prov = o.Yz7({ token: Te, factory: Te.\u0275fac, providedIn: "root" }); class Rt extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-column", this.styleCache = bn, this.init() } } Rt.\u0275fac = function (s) { return new (s || Rt)(o.Y36(o.SBq), o.Y36(Te), o.Y36(ie), o.Y36(me)) }, Rt.\u0275dir = o.lG2({ type: Rt, features: [o.qOj] }); const bn = new Map, ut = ["gdColumn", "gdColumn.xs", "gdColumn.sm", "gdColumn.md", "gdColumn.lg", "gdColumn.xl", "gdColumn.lt-sm", "gdColumn.lt-md", "gdColumn.lt-lg", "gdColumn.lt-xl", "gdColumn.gt-xs", "gdColumn.gt-sm", "gdColumn.gt-md", "gdColumn.gt-lg"]; class n extends Rt { constructor() { super(...arguments), this.inputs = ut } } n.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(n)))(i || n) } }(), n.\u0275dir = o.lG2({ type: n, selectors: [["", "gdColumn", ""], ["", "gdColumn.xs", ""], ["", "gdColumn.sm", ""], ["", "gdColumn.md", ""], ["", "gdColumn.lg", ""], ["", "gdColumn.xl", ""], ["", "gdColumn.lt-sm", ""], ["", "gdColumn.lt-md", ""], ["", "gdColumn.lt-lg", ""], ["", "gdColumn.lt-xl", ""], ["", "gdColumn.gt-xs", ""], ["", "gdColumn.gt-sm", ""], ["", "gdColumn.gt-md", ""], ["", "gdColumn.gt-lg", ""]], inputs: { gdColumn: "gdColumn", "gdColumn.xs": "gdColumn.xs", "gdColumn.sm": "gdColumn.sm", "gdColumn.md": "gdColumn.md", "gdColumn.lg": "gdColumn.lg", "gdColumn.xl": "gdColumn.xl", "gdColumn.lt-sm": "gdColumn.lt-sm", "gdColumn.lt-md": "gdColumn.lt-md", "gdColumn.lt-lg": "gdColumn.lt-lg", "gdColumn.lt-xl": "gdColumn.lt-xl", "gdColumn.gt-xs": "gdColumn.gt-xs", "gdColumn.gt-sm": "gdColumn.gt-sm", "gdColumn.gt-md": "gdColumn.gt-md", "gdColumn.gt-lg": "gdColumn.gt-lg" }, features: [o.qOj] }); class C extends Se { buildStyles(s, i) { let d = !1; (s = s || "none").endsWith("!") && (s = s.substring(0, s.indexOf("!")), d = !0); const f = { display: i.inline ? "inline-grid" : "grid", "grid-auto-columns": "", "grid-template-columns": "" }; return f[d ? "grid-auto-columns" : "grid-template-columns"] = s, f } } C.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(C)))(i || C) } }(), C.\u0275prov = o.Yz7({ token: C, factory: C.\u0275fac, providedIn: "root" }); class z extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-columns", this._inline = !1, this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? ht : ge, this.addStyles(s, { inline: this.inline }) } } z.\u0275fac = function (s) { return new (s || z)(o.Y36(o.SBq), o.Y36(C), o.Y36(ie), o.Y36(me)) }, z.\u0275dir = o.lG2({ type: z, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const ge = new Map, ht = new Map, Sn = ["gdColumns", "gdColumns.xs", "gdColumns.sm", "gdColumns.md", "gdColumns.lg", "gdColumns.xl", "gdColumns.lt-sm", "gdColumns.lt-md", "gdColumns.lt-lg", "gdColumns.lt-xl", "gdColumns.gt-xs", "gdColumns.gt-sm", "gdColumns.gt-md", "gdColumns.gt-lg"]; class Ge extends z { constructor() { super(...arguments), this.inputs = Sn } } Ge.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Ge)))(i || Ge) } }(), Ge.\u0275dir = o.lG2({ type: Ge, selectors: [["", "gdColumns", ""], ["", "gdColumns.xs", ""], ["", "gdColumns.sm", ""], ["", "gdColumns.md", ""], ["", "gdColumns.lg", ""], ["", "gdColumns.xl", ""], ["", "gdColumns.lt-sm", ""], ["", "gdColumns.lt-md", ""], ["", "gdColumns.lt-lg", ""], ["", "gdColumns.lt-xl", ""], ["", "gdColumns.gt-xs", ""], ["", "gdColumns.gt-sm", ""], ["", "gdColumns.gt-md", ""], ["", "gdColumns.gt-lg", ""]], inputs: { gdColumns: "gdColumns", "gdColumns.xs": "gdColumns.xs", "gdColumns.sm": "gdColumns.sm", "gdColumns.md": "gdColumns.md", "gdColumns.lg": "gdColumns.lg", "gdColumns.xl": "gdColumns.xl", "gdColumns.lt-sm": "gdColumns.lt-sm", "gdColumns.lt-md": "gdColumns.lt-md", "gdColumns.lt-lg": "gdColumns.lt-lg", "gdColumns.lt-xl": "gdColumns.lt-xl", "gdColumns.gt-xs": "gdColumns.gt-xs", "gdColumns.gt-sm": "gdColumns.gt-sm", "gdColumns.gt-md": "gdColumns.gt-md", "gdColumns.gt-lg": "gdColumns.gt-lg" }, features: [o.qOj] }); class Ls extends Se { buildStyles(s, i) { return { display: i.inline ? "inline-grid" : "grid", "grid-gap": s || "0" } } } Ls.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Ls)))(i || Ls) } }(), Ls.\u0275prov = o.Yz7({ token: Ls, factory: Ls.\u0275fac, providedIn: "root" }); class Mi extends _e { constructor(s, i, d, f) { super(s, d, i, f), this.DIRECTIVE_KEY = "grid-gap", this._inline = !1, this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? rr : ir, this.addStyles(s, { inline: this.inline }) } } Mi.\u0275fac = function (s) { return new (s || Mi)(o.Y36(o.SBq), o.Y36(ie), o.Y36(Ls), o.Y36(me)) }, Mi.\u0275dir = o.lG2({ type: Mi, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const ir = new Map, rr = new Map, or = ["gdGap", "gdGap.xs", "gdGap.sm", "gdGap.md", "gdGap.lg", "gdGap.xl", "gdGap.lt-sm", "gdGap.lt-md", "gdGap.lt-lg", "gdGap.lt-xl", "gdGap.gt-xs", "gdGap.gt-sm", "gdGap.gt-md", "gdGap.gt-lg"]; class qn extends Mi { constructor() { super(...arguments), this.inputs = or } } qn.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(qn)))(i || qn) } }(), qn.\u0275dir = o.lG2({ type: qn, selectors: [["", "gdGap", ""], ["", "gdGap.xs", ""], ["", "gdGap.sm", ""], ["", "gdGap.md", ""], ["", "gdGap.lg", ""], ["", "gdGap.xl", ""], ["", "gdGap.lt-sm", ""], ["", "gdGap.lt-md", ""], ["", "gdGap.lt-lg", ""], ["", "gdGap.lt-xl", ""], ["", "gdGap.gt-xs", ""], ["", "gdGap.gt-sm", ""], ["", "gdGap.gt-md", ""], ["", "gdGap.gt-lg", ""]], inputs: { gdGap: "gdGap", "gdGap.xs": "gdGap.xs", "gdGap.sm": "gdGap.sm", "gdGap.md": "gdGap.md", "gdGap.lg": "gdGap.lg", "gdGap.xl": "gdGap.xl", "gdGap.lt-sm": "gdGap.lt-sm", "gdGap.lt-md": "gdGap.lt-md", "gdGap.lt-lg": "gdGap.lt-lg", "gdGap.lt-xl": "gdGap.lt-xl", "gdGap.gt-xs": "gdGap.gt-xs", "gdGap.gt-sm": "gdGap.gt-sm", "gdGap.gt-md": "gdGap.gt-md", "gdGap.gt-lg": "gdGap.gt-lg" }, features: [o.qOj] }); class En extends Se { buildStyles(s) { return { "grid-row": s || "auto" } } } En.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(En)))(i || En) } }(), En.\u0275prov = o.Yz7({ token: En, factory: En.\u0275fac, providedIn: "root" }); class Di extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-row", this.styleCache = lr, this.init() } } Di.\u0275fac = function (s) { return new (s || Di)(o.Y36(o.SBq), o.Y36(En), o.Y36(ie), o.Y36(me)) }, Di.\u0275dir = o.lG2({ type: Di, features: [o.qOj] }); const lr = new Map, cr = ["gdRow", "gdRow.xs", "gdRow.sm", "gdRow.md", "gdRow.lg", "gdRow.xl", "gdRow.lt-sm", "gdRow.lt-md", "gdRow.lt-lg", "gdRow.lt-xl", "gdRow.gt-xs", "gdRow.gt-sm", "gdRow.gt-md", "gdRow.gt-lg"]; class Zn extends Di { constructor() { super(...arguments), this.inputs = cr } } Zn.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Zn)))(i || Zn) } }(), Zn.\u0275dir = o.lG2({ type: Zn, selectors: [["", "gdRow", ""], ["", "gdRow.xs", ""], ["", "gdRow.sm", ""], ["", "gdRow.md", ""], ["", "gdRow.lg", ""], ["", "gdRow.xl", ""], ["", "gdRow.lt-sm", ""], ["", "gdRow.lt-md", ""], ["", "gdRow.lt-lg", ""], ["", "gdRow.lt-xl", ""], ["", "gdRow.gt-xs", ""], ["", "gdRow.gt-sm", ""], ["", "gdRow.gt-md", ""], ["", "gdRow.gt-lg", ""]], inputs: { gdRow: "gdRow", "gdRow.xs": "gdRow.xs", "gdRow.sm": "gdRow.sm", "gdRow.md": "gdRow.md", "gdRow.lg": "gdRow.lg", "gdRow.xl": "gdRow.xl", "gdRow.lt-sm": "gdRow.lt-sm", "gdRow.lt-md": "gdRow.lt-md", "gdRow.lt-lg": "gdRow.lt-lg", "gdRow.lt-xl": "gdRow.lt-xl", "gdRow.gt-xs": "gdRow.gt-xs", "gdRow.gt-sm": "gdRow.gt-sm", "gdRow.gt-md": "gdRow.gt-md", "gdRow.gt-lg": "gdRow.gt-lg" }, features: [o.qOj] }); class wn extends Se { buildStyles(s, i) { let d = !1; (s = s || "none").endsWith("!") && (s = s.substring(0, s.indexOf("!")), d = !0); const f = { display: i.inline ? "inline-grid" : "grid", "grid-auto-rows": "", "grid-template-rows": "" }; return f[d ? "grid-auto-rows" : "grid-template-rows"] = s, f } } wn.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(wn)))(i || wn) } }(), wn.\u0275prov = o.Yz7({ token: wn, factory: wn.\u0275fac, providedIn: "root" }); class Ii extends _e { constructor(s, i, d, f) { super(s, i, d, f), this.DIRECTIVE_KEY = "grid-rows", this._inline = !1, this.init() } get inline() { return this._inline } set inline(s) { this._inline = (0, yt.Ig)(s) } updateWithValue(s) { this.styleCache = this.inline ? hr : ur, this.addStyles(s, { inline: this.inline }) } } Ii.\u0275fac = function (s) { return new (s || Ii)(o.Y36(o.SBq), o.Y36(wn), o.Y36(ie), o.Y36(me)) }, Ii.\u0275dir = o.lG2({ type: Ii, inputs: { inline: ["gdInline", "inline"] }, features: [o.qOj] }); const ur = new Map, hr = new Map, gr = ["gdRows", "gdRows.xs", "gdRows.sm", "gdRows.md", "gdRows.lg", "gdRows.xl", "gdRows.lt-sm", "gdRows.lt-md", "gdRows.lt-lg", "gdRows.lt-xl", "gdRows.gt-xs", "gdRows.gt-sm", "gdRows.gt-md", "gdRows.gt-lg"]; class Xn extends Ii { constructor() { super(...arguments), this.inputs = gr } } Xn.\u0275fac = function () { let l; return function (i) { return (l || (l = o.n5z(Xn)))(i || Xn) } }(), Xn.\u0275dir = o.lG2({ type: Xn, selectors: [["", "gdRows", ""], ["", "gdRows.xs", ""], ["", "gdRows.sm", ""], ["", "gdRows.md", ""], ["", "gdRows.lg", ""], ["", "gdRows.xl", ""], ["", "gdRows.lt-sm", ""], ["", "gdRows.lt-md", ""], ["", "gdRows.lt-lg", ""], ["", "gdRows.lt-xl", ""], ["", "gdRows.gt-xs", ""], ["", "gdRows.gt-sm", ""], ["", "gdRows.gt-md", ""], ["", "gdRows.gt-lg", ""]], inputs: { gdRows: "gdRows", "gdRows.xs": "gdRows.xs", "gdRows.sm": "gdRows.sm", "gdRows.md": "gdRows.md", "gdRows.lg": "gdRows.lg", "gdRows.xl": "gdRows.xl", "gdRows.lt-sm": "gdRows.lt-sm", "gdRows.lt-md": "gdRows.lt-md", "gdRows.lt-lg": "gdRows.lt-lg", "gdRows.lt-xl": "gdRows.lt-xl", "gdRows.gt-xs": "gdRows.gt-xs", "gdRows.gt-sm": "gdRows.gt-sm", "gdRows.gt-md": "gdRows.gt-md", "gdRows.gt-lg": "gdRows.gt-lg" }, features: [o.qOj] }); class Cn { } Cn.\u0275fac = function (s) { return new (s || Cn) }, Cn.\u0275mod = o.oAB({ type: Cn }), Cn.\u0275inj = o.cJS({ imports: [[Ve]] }); new o.GfV("13.0.0-beta.36"); class Qs { constructor(s, i) { (0, a.PM)(i) && !s && console.warn("Warning: Flex Layout loaded on the server without FlexLayoutServerModule") } static withConfig(s, i = []) { return { ngModule: Qs, providers: s.serverLoaded ? [{ provide: Ye, useValue: be(be({}, Mn), s) }, { provide: St, useValue: i, multi: !0 }, { provide: ss, useValue: !0 }] : [{ provide: Ye, useValue: be(be({}, Mn), s) }, { provide: St, useValue: i, multi: !0 }] } } } Qs.\u0275fac = function (s) { return new (s || Qs)(o.LFG(ss), o.LFG(o.Lbi)) }, Qs.\u0275mod = o.oAB({ type: Qs }), Qs.\u0275inj = o.cJS({ imports: [[ms, Ke, Cn], ms, Ke, Cn] }); var Qi = I(3174), Wi = I(573), Xi = I(9474); function fr(l, s) { if (1 & l && (o.O4$(), o._UZ(0, "circle", 3)), 2 & l) { const i = o.oxw(); o.Udp("animation-name", "mat-progress-spinner-stroke-rotate-" + i._spinnerAnimationLabel)("stroke-dashoffset", i._getStrokeDashOffset(), "px")("stroke-dasharray", i._getStrokeCircumference(), "px")("stroke-width", i._getCircleStrokeWidth(), "%"), o.uIk("r", i._getCircleRadius()) } } function pr(l, s) { if (1 & l && (o.O4$(), o._UZ(0, "circle", 3)), 2 & l) { const i = o.oxw(); o.Udp("stroke-dashoffset", i._getStrokeDashOffset(), "px")("stroke-dasharray", i._getStrokeCircumference(), "px")("stroke-width", i._getCircleStrokeWidth(), "%"), o.uIk("r", i._getCircleRadius()) } } function mr(l, s) { if (1 & l && (o.O4$(), o._UZ(0, "circle", 3)), 2 & l) { const i = o.oxw(); o.Udp("animation-name", "mat-progress-spinner-stroke-rotate-" + i._spinnerAnimationLabel)("stroke-dashoffset", i._getStrokeDashOffset(), "px")("stroke-dasharray", i._getStrokeCircumference(), "px")("stroke-width", i._getCircleStrokeWidth(), "%"), o.uIk("r", i._getCircleRadius()) } } function yr(l, s) { if (1 & l && (o.O4$(), o._UZ(0, "circle", 3)), 2 & l) { const i = o.oxw(); o.Udp("stroke-dashoffset", i._getStrokeDashOffset(), "px")("stroke-dasharray", i._getStrokeCircumference(), "px")("stroke-width", i._getCircleStrokeWidth(), "%"), o.uIk("r", i._getCircleRadius()) } } const vr = (0, Qi.pj)(class { constructor(l) { this._elementRef = l } }, "primary"), Ji = new o.OlP("mat-progress-spinner-default-options", { providedIn: "root", factory: function () { return { diameter: 100 } } }); const br = "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n"; class ks extends vr { constructor(s, i, d, f, w) { super(s), this._document = d, this._diameter = 100, this._value = 0, this.mode = "determinate"; const T = ks._diameters; this._spinnerAnimationLabel = this._getSpinnerAnimationLabel(), T.has(d.head) || T.set(d.head, new Set([100])), this._noopAnimations = "NoopAnimations" === f && !!w && !w._forceAnimations, w && (w.diameter && (this.diameter = w.diameter), w.strokeWidth && (this.strokeWidth = w.strokeWidth)) } get diameter() { return this._diameter } set diameter(s) { this._diameter = (0, yt.su)(s), this._spinnerAnimationLabel = this._getSpinnerAnimationLabel(), this._styleRoot && this._attachStyleNode() } get strokeWidth() { return this._strokeWidth || this.diameter / 10 } set strokeWidth(s) { this._strokeWidth = (0, yt.su)(s) } get value() { return "determinate" === this.mode ? this._value : 0 } set value(s) { this._value = Math.max(0, Math.min(100, (0, yt.su)(s))) } ngOnInit() { const s = this._elementRef.nativeElement; this._styleRoot = (0, Wi.kV)(s) || this._document.head, this._attachStyleNode(), s.classList.add("mat-progress-spinner-indeterminate-animation") } _getCircleRadius() { return (this.diameter - 10) / 2 } _getViewBox() { const s = 2 * this._getCircleRadius() + this.strokeWidth; return `0 0 ${s} ${s}` } _getStrokeCircumference() { return 2 * Math.PI * this._getCircleRadius() } _getStrokeDashOffset() { return "determinate" === this.mode ? this._getStrokeCircumference() * (100 - this._value) / 100 : null } _getCircleStrokeWidth() { return this.strokeWidth / this.diameter * 100 } _attachStyleNode() { const s = this._styleRoot, i = this._diameter, d = ks._diameters; let f = d.get(s); if (!f || !f.has(i)) { const w = this._document.createElement("style"); w.setAttribute("mat-spinner-animation", this._spinnerAnimationLabel), w.textContent = this._getAnimationText(), s.appendChild(w), f || (f = new Set, d.set(s, f)), f.add(i) } } _getAnimationText() { const s = this._getStrokeCircumference(); return br.replace(/START_VALUE/g, "" + .95 * s).replace(/END_VALUE/g, "" + .2 * s).replace(/DIAMETER/g, `${this._spinnerAnimationLabel}`) } _getSpinnerAnimationLabel() { return this.diameter.toString().replace(".", "_") } } ks._diameters = new WeakMap, ks.\u0275fac = function (s) { return new (s || ks)(o.Y36(o.SBq), o.Y36(Wi.t4), o.Y36(a.K0, 8), o.Y36(Xi.Qb, 8), o.Y36(Ji)) }, ks.\u0275cmp = o.Xpm({ type: ks, selectors: [["mat-progress-spinner"]], hostAttrs: ["role", "progressbar", "tabindex", "-1", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function (s, i) { 2 & s && (o.uIk("aria-valuemin", "determinate" === i.mode ? 0 : null)("aria-valuemax", "determinate" === i.mode ? 100 : null)("aria-valuenow", "determinate" === i.mode ? i.value : null)("mode", i.mode), o.Udp("width", i.diameter, "px")("height", i.diameter, "px"), o.ekj("_mat-animation-noopable", i._noopAnimations)) }, inputs: { color: "color", diameter: "diameter", strokeWidth: "strokeWidth", mode: "mode", value: "value" }, exportAs: ["matProgressSpinner"], features: [o.qOj], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", "aria-hidden", "true", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function (s, i) { 1 & s && (o.O4$(), o.TgZ(0, "svg", 0), o.YNc(1, fr, 1, 9, "circle", 1), o.YNc(2, pr, 1, 7, "circle", 2), o.qZA()), 2 & s && (o.Udp("width", i.diameter, "px")("height", i.diameter, "px"), o.Q6J("ngSwitch", "indeterminate" === i.mode), o.uIk("viewBox", i._getViewBox()), o.xp6(1), o.Q6J("ngSwitchCase", !0), o.xp6(1), o.Q6J("ngSwitchCase", !1)) }, directives: [a.RF, a.n9], styles: [".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\n"], encapsulation: 2, changeDetection: 0 }); class Yi extends ks { constructor(s, i, d, f, w) { super(s, i, d, f, w), this.mode = "indeterminate" } } Yi.\u0275fac = function (s) { return new (s || Yi)(o.Y36(o.SBq), o.Y36(Wi.t4), o.Y36(a.K0, 8), o.Y36(Xi.Qb, 8), o.Y36(Ji)) }, Yi.\u0275cmp = o.Xpm({ type: Yi, selectors: [["mat-spinner"]], hostAttrs: ["role", "progressbar", "mode", "indeterminate", 1, "mat-spinner", "mat-progress-spinner"], hostVars: 6, hostBindings: function (s, i) { 2 & s && (o.Udp("width", i.diameter, "px")("height", i.diameter, "px"), o.ekj("_mat-animation-noopable", i._noopAnimations)) }, inputs: { color: "color" }, features: [o.qOj], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", "aria-hidden", "true", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function (s, i) { 1 & s && (o.O4$(), o.TgZ(0, "svg", 0), o.YNc(1, mr, 1, 9, "circle", 1), o.YNc(2, yr, 1, 7, "circle", 2), o.qZA()), 2 & s && (o.Udp("width", i.diameter, "px")("height", i.diameter, "px"), o.Q6J("ngSwitch", "indeterminate" === i.mode), o.uIk("viewBox", i._getViewBox()), o.xp6(1), o.Q6J("ngSwitchCase", !0), o.xp6(1), o.Q6J("ngSwitchCase", !1)) }, directives: [a.RF, a.n9], styles: [".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\n"], encapsulation: 2, changeDetection: 0 }); class Jn { } Jn.\u0275fac = function (s) { return new (s || Jn) }, Jn.\u0275mod = o.oAB({ type: Jn }), Jn.\u0275inj = o.cJS({ imports: [[Qi.BQ, a.ez], Qi.BQ] }); var Sr = I(548); class ei { } ei.\u0275fac = function (s) { return new (s || ei) }, ei.\u0275mod = o.oAB({ type: ei }), ei.\u0275inj = o.cJS({ providers: [Sr.j], imports: [[a.ez, Qs, Jn]] }); class ti { } ti.\u0275fac = function (s) { return new (s || ti) }, ti.\u0275mod = o.oAB({ type: ti }), ti.\u0275inj = o.cJS({ imports: [[a.ez, ei, k.F]] }); class si { } si.\u0275fac = function (s) { return new (s || si) }, si.\u0275mod = o.oAB({ type: si }), si.\u0275inj = o.cJS({ imports: [[a.ez, v, ti]] }) }, 7456: (Ae, J, I) => { "use strict"; I.d(J, { v: () => y }); var a = I(8806), O = I(8824), k = I(2555), o = I(4001), v = I(3981); class y { constructor(x) { this._http = x, this._userBalance$ = new O.X(null), this._userSubscription$ = new O.X(null) } get userBalance$() { return this._userBalance$ } get userBalance() { return this._userBalance$.value } get userSubscription$() { return this._userSubscription$ } get userSubscription() { return this._userSubscription$.value } getExtensionUserBalanceAsync(x = !0) { return (0, a.mG)(this, void 0, void 0, function* () { try { if (this.userBalance && !x) return this.userBalance; const F = yield this._http.get(`${k.N.extensionAPI}/v1/account/balance?force=${x}`).toPromise(); return this._userBalance$.next(F), this.userBalance } catch (F) { throw F } }) } getExtensionSubscriptionStateAsync() { return (0, a.mG)(this, void 0, void 0, function* () { try { return this.userSubscription ? this.userSubscription : yield this._http.get(`${k.N.extensionAPI}/v1/account/balance/subscription`).toPromise() } catch (x) { throw x } }) } getExtensionProductsPlansAsync() { return (0, a.mG)(this, void 0, void 0, function* () { try { return yield this._http.get(`${k.N.extensionAPI}/v1/pricing/plans`).toPromise() } catch (x) { throw x } }) } sendCreditsRequestToOwnerAsync() { return (0, a.mG)(this, void 0, void 0, function* () { try { return yield this._http.post(`${k.N.extensionAPI}/v1/credits-request-to-owner`, null).toPromise() } catch (x) { throw x } }) } } y.\u0275fac = function (x) { return new (x || y)(o.LFG(v.eN)) }, y.\u0275prov = o.Yz7({ token: y, factory: y.\u0275fac, providedIn: "root" }) }, 6093: (Ae, J, I) => { "use strict"; I.d(J, { vT: () => _, Is: () => v }); var a = I(4001), O = I(8267); const k = new a.OlP("cdk-dir-doc", { providedIn: "root", factory: function () { return (0, a.f3M)(O.K0) } }); class v { constructor(F) { if (this.value = "ltr", this.change = new a.vpe, F) { const te = F.body ? F.body.dir : null, oe = F.documentElement ? F.documentElement.dir : null, ce = te || oe; this.value = "ltr" === ce || "rtl" === ce ? ce : "ltr" } } ngOnDestroy() { this.change.complete() } } v.\u0275fac = function (F) { return new (F || v)(a.LFG(k, 8)) }, v.\u0275prov = a.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }); class y { constructor() { this._dir = "ltr", this._isInitialized = !1, this.change = new a.vpe } get dir() { return this._dir } set dir(F) { const te = this._dir, oe = F && F.toLowerCase(); this._rawDir = F, this._dir = "ltr" === oe || "rtl" === oe ? oe : "ltr", te !== this._dir && this._isInitialized && this.change.emit(this._dir) } get value() { return this.dir } ngAfterContentInit() { this._isInitialized = !0 } ngOnDestroy() { this.change.complete() } } y.\u0275fac = function (F) { return new (F || y) }, y.\u0275dir = a.lG2({ type: y, selectors: [["", "dir", ""]], hostVars: 1, hostBindings: function (F, te) { 2 & F && a.uIk("dir", te._rawDir) }, inputs: { dir: "dir" }, outputs: { change: "dirChange" }, exportAs: ["dir"], features: [a._Bn([{ provide: v, useExisting: y }])] }); class _ { } _.\u0275fac = function (F) { return new (F || _) }, _.\u0275mod = a.oAB({ type: _ }), _.\u0275inj = a.cJS({}) }, 2871: (Ae, J, I) => { "use strict"; I.d(J, { Ig: () => O, fI: () => _, su: () => k }); var a = I(4001); function O(F) { return null != F && "false" != `${F}` } function k(F, te = 0) { return function (F) { return !isNaN(parseFloat(F)) && !isNaN(Number(F)) }(F) ? Number(F) : te } function _(F) { return F instanceof a.SBq ? F.nativeElement : F } }, 573: (Ae, J, I) => { "use strict"; I.d(J, { t4: () => o, ud: () => v, sA: () => ze, ht: () => We, kV: () => st, Oy: () => bt, i$: () => oe }); var a = I(4001), O = I(8267); let k; try { k = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (Q) { k = !1 } class o { constructor(fe) { this._platformId = fe, this.isBrowser = this._platformId ? (0, O.NF)(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !k) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } o.\u0275fac = function (fe) { return new (fe || o)(a.LFG(a.Lbi)) }, o.\u0275prov = a.Yz7({ token: o, factory: o.\u0275fac, providedIn: "root" }); class v { } v.\u0275fac = function (fe) { return new (fe || v) }, v.\u0275mod = a.oAB({ type: v }), v.\u0275inj = a.cJS({}); let F, tt; function oe(Q) { return function () { if (null == F && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => F = !0 })) } finally { F = F || !1 } return F }() ? Q : !!Q.capture } function st(Q) { if (function () { if (null == tt) { const Q = "undefined" != typeof document ? document.head : null; tt = !(!Q || !Q.createShadowRoot && !Q.attachShadow) } return tt }()) { const fe = Q.getRootNode ? Q.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && fe instanceof ShadowRoot) return fe } return null } function We() { let Q = "undefined" != typeof document && document ? document.activeElement : null; for (; Q && Q.shadowRoot;) { const fe = Q.shadowRoot.activeElement; if (fe === Q) break; Q = fe } return Q } function ze(Q) { return Q.composedPath ? Q.composedPath()[0] : Q.target } function bt() { return "undefined" != typeof __karma__ && !!__karma__ || "undefined" != typeof jasmine && !!jasmine || "undefined" != typeof jest && !!jest || "undefined" != typeof Mocha && !!Mocha } }, 3174: (Ae, J, I) => { "use strict"; I.d(J, { BQ: () => et, pj: () => kt }); var a = I(4001), O = I(8267), k = I(8824), o = I(3238), v = I(8433); var fi = I(7529), Bn = I(1569); var mi = I(713), Pn = I(5191), fn = I(5308); function Es(S, n) { return S === n } var Nn = I(6567), it = I(2871), xe = I(573), pn = I(4635), Ni = I(1278); class Ke { create(n) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(n) } } Ke.\u0275fac = function (n) { return new (n || Ke) }, Ke.\u0275prov = a.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }); class Et { constructor(n) { this._mutationObserverFactory = n, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((n, c) => this._cleanupObserver(c)) } observe(n) { const c = (0, it.fI)(n); return new pn.y(p => { const z = this._observeElement(c).subscribe(p); return () => { z.unsubscribe(), this._unobserveElement(c) } }) } _observeElement(n) { if (this._observedElements.has(n)) this._observedElements.get(n).count++; else { const c = new o.x, p = this._mutationObserverFactory.create(C => c.next(C)); p && p.observe(n, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(n, { observer: p, stream: c, count: 1 }) } return this._observedElements.get(n).stream } _unobserveElement(n) { this._observedElements.has(n) && (this._observedElements.get(n).count--, this._observedElements.get(n).count || this._cleanupObserver(n)) } _cleanupObserver(n) { if (this._observedElements.has(n)) { const { observer: c, stream: p } = this._observedElements.get(n); c && c.disconnect(), p.complete(), this._observedElements.delete(n) } } } Et.\u0275fac = function (n) { return new (n || Et)(a.LFG(Ke)) }, Et.\u0275prov = a.Yz7({ token: Et, factory: Et.\u0275fac, providedIn: "root" }); class rt { constructor(n, c, p) { this._contentObserver = n, this._elementRef = c, this._ngZone = p, this.event = new a.vpe, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(n) { this._disabled = (0, it.Ig)(n), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(n) { this._debounce = (0, it.su)(n), this._subscribe() } ngAfterContentInit() { !this._currentSubscription && !this.disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const n = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? n.pipe((0, Ni.b)(this.debounce)) : n).subscribe(this.event) }) } _unsubscribe() { var n; null == (n = this._currentSubscription) || n.unsubscribe() } } rt.\u0275fac = function (n) { return new (n || rt)(a.Y36(Et), a.Y36(a.SBq), a.Y36(a.R0b)) }, rt.\u0275dir = a.lG2({ type: rt, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }); class as { } as.\u0275fac = function (n) { return new (n || as) }, as.\u0275mod = a.oAB({ type: as }), as.\u0275inj = a.cJS({ providers: [Ke] }); function ls(S, n) { return (S.getAttribute(n) || "").match(/\S+/g) || [] } const mn = "cdk-describedby-message-container", zt = "cdk-describedby-message", cs = "cdk-describedby-host"; let zi = 0; const Pe = new Map; let we = null; class ws { constructor(n) { this._document = n } describe(n, c, p) { if (!this._canBeDescribed(n, c)) return; const C = Us(c, p); "string" != typeof c ? (yn(c), Pe.set(C, { messageElement: c, referenceCount: 0 })) : Pe.has(C) || this._createMessageElement(c, p), this._isElementDescribedByMessage(n, C) || this._addMessageReference(n, C) } removeDescription(n, c, p) { if (!c || !this._isElementNode(n)) return; const C = Us(c, p); if (this._isElementDescribedByMessage(n, C) && this._removeMessageReference(n, C), "string" == typeof c) { const z = Pe.get(C); z && 0 === z.referenceCount && this._deleteMessageElement(C) } we && 0 === we.childNodes.length && this._deleteMessagesContainer() } ngOnDestroy() { const n = this._document.querySelectorAll(`[${cs}]`); for (let c = 0; c < n.length; c++)this._removeCdkDescribedByReferenceIds(n[c]), n[c].removeAttribute(cs); we && this._deleteMessagesContainer(), Pe.clear() } _createMessageElement(n, c) { const p = this._document.createElement("div"); yn(p), p.textContent = n, c && p.setAttribute("role", c), this._createMessagesContainer(), we.appendChild(p), Pe.set(Us(n, c), { messageElement: p, referenceCount: 0 }) } _deleteMessageElement(n) { var p; const c = Pe.get(n); null == (p = null == c ? void 0 : c.messageElement) || p.remove(), Pe.delete(n) } _createMessagesContainer() { if (!we) { const n = this._document.getElementById(mn); null == n || n.remove(), we = this._document.createElement("div"), we.id = mn, we.style.visibility = "hidden", we.classList.add("cdk-visually-hidden"), this._document.body.appendChild(we) } } _deleteMessagesContainer() { we && (we.remove(), we = null) } _removeCdkDescribedByReferenceIds(n) { const c = ls(n, "aria-describedby").filter(p => 0 != p.indexOf(zt)); n.setAttribute("aria-describedby", c.join(" ")) } _addMessageReference(n, c) { const p = Pe.get(c); (function (S, n, c) { const p = ls(S, n); p.some(C => C.trim() == c.trim()) || (p.push(c.trim()), S.setAttribute(n, p.join(" "))) })(n, "aria-describedby", p.messageElement.id), n.setAttribute(cs, ""), p.referenceCount++ } _removeMessageReference(n, c) { const p = Pe.get(c); p.referenceCount--, function (S, n, c) { const C = ls(S, n).filter(z => z != c.trim()); C.length ? S.setAttribute(n, C.join(" ")) : S.removeAttribute(n) }(n, "aria-describedby", p.messageElement.id), n.removeAttribute(cs) } _isElementDescribedByMessage(n, c) { const p = ls(n, "aria-describedby"), C = Pe.get(c), z = C && C.messageElement.id; return !!z && -1 != p.indexOf(z) } _canBeDescribed(n, c) { if (!this._isElementNode(n)) return !1; if (c && "object" == typeof c) return !0; const p = null == c ? "" : `${c}`.trim(), C = n.getAttribute("aria-label"); return !!p && (!C || C.trim() !== p) } _isElementNode(n) { return n.nodeType === this._document.ELEMENT_NODE } } function Us(S, n) { return "string" == typeof S ? `${n || ""}/${S}` : S } function yn(S) { S.id || (S.id = `${zt}-${zi++}`) } ws.\u0275fac = function (n) { return new (n || ws)(a.LFG(O.K0)) }, ws.\u0275prov = a.Yz7({ token: ws, factory: ws.\u0275fac, providedIn: "root" }); class je { constructor(n) { this._platform = n } isDisabled(n) { return n.hasAttribute("disabled") } isVisible(n) { return !!((S = n).offsetWidth || S.offsetHeight || "function" == typeof S.getClientRects && S.getClientRects().length) && "visible" === getComputedStyle(n).visibility; var S } isTabbable(n) { if (!this._platform.isBrowser) return !1; const c = function (S) { try { return S.frameElement } catch (n) { return null } }((S = n).ownerDocument && S.ownerDocument.defaultView || window); var S; if (c && (-1 === Vs(c) || !this.isVisible(c))) return !1; let p = n.nodeName.toLowerCase(), C = Vs(n); return n.hasAttribute("contenteditable") ? -1 !== C : !("iframe" === p || "object" === p || this._platform.WEBKIT && this._platform.IOS && !function (S) { let n = S.nodeName.toLowerCase(), c = "input" === n && S.type; return "text" === c || "password" === c || "select" === n || "textarea" === n }(n)) && ("audio" === p ? !!n.hasAttribute("controls") && -1 !== C : "video" === p ? -1 !== C && (null !== C || (this._platform.FIREFOX || n.hasAttribute("controls"))) : n.tabIndex >= 0) } isFocusable(n, c) { return !function (S) { return function (S) { return "input" == S.nodeName.toLowerCase() }(S) && "hidden" == S.type }(S = n) && (function (S) { let n = S.nodeName.toLowerCase(); return "input" === n || "select" === n || "button" === n || "textarea" === n }(S) || function (S) { return function (S) { return "a" == S.nodeName.toLowerCase() }(S) && S.hasAttribute("href") }(S) || S.hasAttribute("contenteditable") || Ut(S)) && !this.isDisabled(n) && ((null == c ? void 0 : c.ignoreVisibility) || this.isVisible(n)); var S } } function Ut(S) { if (!S.hasAttribute("tabindex") || void 0 === S.tabIndex) return !1; let n = S.getAttribute("tabindex"); return !(!n || isNaN(parseInt(n, 10))) } function Vs(S) { if (!Ut(S)) return null; const n = parseInt(S.getAttribute("tabindex") || "", 10); return isNaN(n) ? -1 : n } je.\u0275fac = function (n) { return new (n || je)(a.LFG(xe.t4)) }, je.\u0275prov = a.Yz7({ token: je, factory: je.\u0275fac, providedIn: "root" }); class Yn { constructor(n, c, p, C, z = !1) { this._element = n, this._checker = c, this._ngZone = p, this._document = C, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, z || this.attachAnchors() } get enabled() { return this._enabled } set enabled(n) { this._enabled = n, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(n, this._startAnchor), this._toggleAnchorTabIndex(n, this._endAnchor)) } destroy() { const n = this._startAnchor, c = this._endAnchor; n && (n.removeEventListener("focus", this.startAnchorListener), n.remove()), c && (c.removeEventListener("focus", this.endAnchorListener), c.remove()), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady(n) { return new Promise(c => { this._executeOnStable(() => c(this.focusInitialElement(n))) }) } focusFirstTabbableElementWhenReady(n) { return new Promise(c => { this._executeOnStable(() => c(this.focusFirstTabbableElement(n))) }) } focusLastTabbableElementWhenReady(n) { return new Promise(c => { this._executeOnStable(() => c(this.focusLastTabbableElement(n))) }) } _getRegionBoundary(n) { const c = this._element.querySelectorAll(`[cdk-focus-region-${n}], [cdkFocusRegion${n}], [cdk-focus-${n}]`); return "start" == n ? c.length ? c[0] : this._getFirstTabbableElement(this._element) : c.length ? c[c.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement(n) { const c = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (c) { if (!this._checker.isFocusable(c)) { const p = this._getFirstTabbableElement(c); return null == p || p.focus(n), !!p } return c.focus(n), !0 } return this.focusFirstTabbableElement(n) } focusFirstTabbableElement(n) { const c = this._getRegionBoundary("start"); return c && c.focus(n), !!c } focusLastTabbableElement(n) { const c = this._getRegionBoundary("end"); return c && c.focus(n), !!c } hasAttached() { return this._hasAttached } _getFirstTabbableElement(n) { if (this._checker.isFocusable(n) && this._checker.isTabbable(n)) return n; const c = n.children; for (let p = 0; p < c.length; p++) { const C = c[p].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(c[p]) : null; if (C) return C } return null } _getLastTabbableElement(n) { if (this._checker.isFocusable(n) && this._checker.isTabbable(n)) return n; const c = n.children; for (let p = c.length - 1; p >= 0; p--) { const C = c[p].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(c[p]) : null; if (C) return C } return null } _createAnchor() { const n = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, n), n.classList.add("cdk-visually-hidden"), n.classList.add("cdk-focus-trap-anchor"), n.setAttribute("aria-hidden", "true"), n } _toggleAnchorTabIndex(n, c) { n ? c.setAttribute("tabindex", "0") : c.removeAttribute("tabindex") } toggleAnchors(n) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(n, this._startAnchor), this._toggleAnchorTabIndex(n, this._endAnchor)) } _executeOnStable(n) { this._ngZone.isStable ? n() : this._ngZone.onStable.pipe((0, fi.q)(1)).subscribe(n) } } class xt { constructor(n, c, p) { this._checker = n, this._ngZone = c, this._document = p } create(n, c = !1) { return new Yn(n, this._checker, this._ngZone, this._document, c) } } xt.\u0275fac = function (n) { return new (n || xt)(a.LFG(je), a.LFG(a.R0b), a.LFG(O.K0)) }, xt.\u0275prov = a.Yz7({ token: xt, factory: xt.\u0275fac, providedIn: "root" }); class Ys { constructor(n, c, p) { this._elementRef = n, this._focusTrapFactory = c, this._previouslyFocusedElement = null, this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, !0) } get enabled() { return this.focusTrap.enabled } set enabled(n) { this.focusTrap.enabled = (0, it.Ig)(n) } get autoCapture() { return this._autoCapture } set autoCapture(n) { this._autoCapture = (0, it.Ig)(n) } ngOnDestroy() { this.focusTrap.destroy(), this._previouslyFocusedElement && (this._previouslyFocusedElement.focus(), this._previouslyFocusedElement = null) } ngAfterContentInit() { this.focusTrap.attachAnchors(), this.autoCapture && this._captureFocus() } ngDoCheck() { this.focusTrap.hasAttached() || this.focusTrap.attachAnchors() } ngOnChanges(n) { const c = n.autoCapture; c && !c.firstChange && this.autoCapture && this.focusTrap.hasAttached() && this._captureFocus() } _captureFocus() { this._previouslyFocusedElement = (0, xe.ht)(), this.focusTrap.focusInitialElementWhenReady() } } Ys.\u0275fac = function (n) { return new (n || Ys)(a.Y36(a.SBq), a.Y36(xt), a.Y36(O.K0)) }, Ys.\u0275dir = a.lG2({ type: Ys, selectors: [["", "cdkTrapFocus", ""]], inputs: { enabled: ["cdkTrapFocus", "enabled"], autoCapture: ["cdkTrapFocusAutoCapture", "autoCapture"] }, exportAs: ["cdkTrapFocus"], features: [a.TTD] }); class Yt extends Yn { constructor(n, c, p, C, z, ge, ht) { super(n, c, p, C, ht.defer), this._focusTrapManager = z, this._inertStrategy = ge, this._focusTrapManager.register(this) } get enabled() { return this._enabled } set enabled(n) { this._enabled = n, this._enabled ? this._focusTrapManager.register(this) : this._focusTrapManager.deregister(this) } destroy() { this._focusTrapManager.deregister(this), super.destroy() } _enable() { this._inertStrategy.preventFocus(this), this.toggleAnchors(!0) } _disable() { this._inertStrategy.allowFocus(this), this.toggleAnchors(!1) } } const $t = new a.OlP("FOCUS_TRAP_INERT_STRATEGY"); class vi { constructor() { this._listener = null } preventFocus(n) { this._listener && n._document.removeEventListener("focus", this._listener, !0), this._listener = c => this._trapFocus(n, c), n._ngZone.runOutsideAngular(() => { n._document.addEventListener("focus", this._listener, !0) }) } allowFocus(n) { !this._listener || (n._document.removeEventListener("focus", this._listener, !0), this._listener = null) } _trapFocus(n, c) { var z; const p = c.target, C = n._element; p && !C.contains(p) && !(null == (z = p.closest) ? void 0 : z.call(p, "div.cdk-overlay-pane")) && setTimeout(() => { n.enabled && !C.contains(n._document.activeElement) && n.focusFirstTabbableElement() }) } } class gs { constructor() { this._focusTrapStack = [] } register(n) { this._focusTrapStack = this._focusTrapStack.filter(p => p !== n); let c = this._focusTrapStack; c.length && c[c.length - 1]._disable(), c.push(n), n._enable() } deregister(n) { n._disable(); const c = this._focusTrapStack, p = c.indexOf(n); -1 !== p && (c.splice(p, 1), c.length && c[c.length - 1]._enable()) } } gs.\u0275fac = function (n) { return new (n || gs) }, gs.\u0275prov = a.Yz7({ token: gs, factory: gs.\u0275fac, providedIn: "root" }); class at { constructor(n, c, p, C, z) { this._checker = n, this._ngZone = c, this._focusTrapManager = p, this._document = C, this._inertStrategy = z || new vi } create(n, c = { defer: !1 }) { let p; return p = "boolean" == typeof c ? { defer: c } : c, new Yt(n, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, p) } } function Ot(S) { return 0 === S.offsetX && 0 === S.offsetY } function Cs(S) { const n = S.touches && S.touches[0] || S.changedTouches && S.changedTouches[0]; return !(!n || -1 !== n.identifier || null != n.radiusX && 1 !== n.radiusX || null != n.radiusY && 1 !== n.radiusY) } at.\u0275fac = function (n) { return new (n || at)(a.LFG(je), a.LFG(a.R0b), a.LFG(gs), a.LFG(O.K0), a.LFG($t, 8)) }, at.\u0275prov = a.Yz7({ token: at, factory: at.\u0275fac, providedIn: "root" }); const _n = new a.OlP("cdk-input-modality-detector-options"), Ai = { ignoreKeys: [18, 17, 224, 91, 16] }, Xe = (0, xe.i$)({ passive: !0, capture: !0 }); class Kt { constructor(n, c, p, C) { var S; this._platform = n, this._mostRecentTarget = null, this._modality = new k.X(null), this._lastTouchMs = 0, this._onKeydown = z => { var ge, ht; (null == (ht = null == (ge = this._options) ? void 0 : ge.ignoreKeys) ? void 0 : ht.some(Sn => Sn === z.keyCode)) || (this._modality.next("keyboard"), this._mostRecentTarget = (0, xe.sA)(z)) }, this._onMousedown = z => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(Ot(z) ? "keyboard" : "mouse"), this._mostRecentTarget = (0, xe.sA)(z)) }, this._onTouchstart = z => { Cs(z) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = (0, xe.sA)(z)) }, this._options = be(be({}, Ai), C), this.modalityDetected = this._modality.pipe((S = 1, (0, Bn.h)((n, c) => S <= c))), this.modalityChanged = this.modalityDetected.pipe(function (S, n = mi.y) { return S = null != S ? S : Es, (0, Pn.e)((c, p) => { let C, z = !0; c.subscribe((0, fn.x)(p, ge => { const ht = n(ge); (z || !S(C, ht)) && (z = !1, C = ht, p.next(ge)) })) }) }()), n.isBrowser && c.runOutsideAngular(() => { p.addEventListener("keydown", this._onKeydown, Xe), p.addEventListener("mousedown", this._onMousedown, Xe), p.addEventListener("touchstart", this._onTouchstart, Xe) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Xe), document.removeEventListener("mousedown", this._onMousedown, Xe), document.removeEventListener("touchstart", this._onTouchstart, Xe)) } } Kt.\u0275fac = function (n) { return new (n || Kt)(a.LFG(xe.t4), a.LFG(a.R0b), a.LFG(O.K0), a.LFG(_n, 8)) }, Kt.\u0275prov = a.Yz7({ token: Kt, factory: Kt.\u0275fac, providedIn: "root" }); const Vi = new a.OlP("liveAnnouncerElement", { providedIn: "root", factory: function () { return null } }); const Kn = new a.OlP("LIVE_ANNOUNCER_DEFAULT_OPTIONS"); class Je { constructor(n, c, p, C) { this._ngZone = c, this._defaultOptions = C, this._document = p, this._liveElement = n || this._createLiveElement() } announce(n, ...c) { const p = this._defaultOptions; let C, z; return 1 === c.length && "number" == typeof c[0] ? z = c[0] : [C, z] = c, this.clear(), clearTimeout(this._previousTimeout), C || (C = p && p.politeness ? p.politeness : "polite"), null == z && p && (z = p.duration), this._liveElement.setAttribute("aria-live", C), this._ngZone.runOutsideAngular(() => new Promise(ge => { clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = n, ge(), "number" == typeof z && (this._previousTimeout = setTimeout(() => this.clear(), z)) }, 100) })) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { var n; clearTimeout(this._previousTimeout), null == (n = this._liveElement) || n.remove(), this._liveElement = null } _createLiveElement() { const n = "cdk-live-announcer-element", c = this._document.getElementsByClassName(n), p = this._document.createElement("div"); for (let C = 0; C < c.length; C++)c[C].remove(); return p.classList.add(n), p.classList.add("cdk-visually-hidden"), p.setAttribute("aria-atomic", "true"), p.setAttribute("aria-live", "polite"), this._document.body.appendChild(p), p } } Je.\u0275fac = function (n) { return new (n || Je)(a.LFG(Vi, 8), a.LFG(a.R0b), a.LFG(O.K0), a.LFG(Kn, 8)) }, Je.\u0275prov = a.Yz7({ token: Je, factory: Je.\u0275fac, providedIn: "root" }); class $s { constructor(n, c, p, C) { this._elementRef = n, this._liveAnnouncer = c, this._contentObserver = p, this._ngZone = C, this._politeness = "polite" } get politeness() { return this._politeness } set politeness(n) { this._politeness = "off" === n || "assertive" === n ? n : "polite", "off" === this._politeness ? this._subscription && (this._subscription.unsubscribe(), this._subscription = null) : this._subscription || (this._subscription = this._ngZone.runOutsideAngular(() => this._contentObserver.observe(this._elementRef).subscribe(() => { const c = this._elementRef.nativeElement.textContent; c !== this._previousAnnouncedText && (this._liveAnnouncer.announce(c, this._politeness), this._previousAnnouncedText = c) }))) } ngOnDestroy() { this._subscription && this._subscription.unsubscribe() } } $s.\u0275fac = function (n) { return new (n || $s)(a.Y36(a.SBq), a.Y36(Je), a.Y36(Et), a.Y36(a.R0b)) }, $s.\u0275dir = a.lG2({ type: $s, selectors: [["", "cdkAriaLive", ""]], inputs: { politeness: ["cdkAriaLive", "politeness"] }, exportAs: ["cdkAriaLive"] }); const jt = new a.OlP("cdk-focus-monitor-default-options"), Lt = (0, xe.i$)({ passive: !0, capture: !0 }); class Ht { constructor(n, c, p, C, z) { this._ngZone = n, this._platform = c, this._inputModalityDetector = p, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new o.x, this._rootNodeFocusAndBlurListener = ge => { const ht = (0, xe.sA)(ge), Sn = "focus" === ge.type ? this._onFocus : this._onBlur; for (let Hs = ht; Hs; Hs = Hs.parentElement)Sn.call(this, ge, Hs) }, this._document = C, this._detectionMode = (null == z ? void 0 : z.detectionMode) || 0 } monitor(n, c = !1) { const p = (0, it.fI)(n); if (!this._platform.isBrowser || 1 !== p.nodeType) return (0, v.of)(null); const C = (0, xe.kV)(p) || this._getDocument(), z = this._elementInfo.get(p); if (z) return c && (z.checkChildren = !0), z.subject; const ge = { checkChildren: c, subject: new o.x, rootNode: C }; return this._elementInfo.set(p, ge), this._registerGlobalListeners(ge), ge.subject } stopMonitoring(n) { const c = (0, it.fI)(n), p = this._elementInfo.get(c); p && (p.subject.complete(), this._setClasses(c), this._elementInfo.delete(c), this._removeGlobalListeners(p)) } focusVia(n, c, p) { const C = (0, it.fI)(n); C === this._getDocument().activeElement ? this._getClosestElementsInfo(C).forEach(([ge, ht]) => this._originChanged(ge, c, ht)) : (this._setOrigin(c), "function" == typeof C.focus && C.focus(p)) } ngOnDestroy() { this._elementInfo.forEach((n, c) => this.stopMonitoring(c)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(n) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(n) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(n) { return 1 === this._detectionMode || !!(null == n ? void 0 : n.contains(this._inputModalityDetector._mostRecentTarget)) } _setClasses(n, c) { n.classList.toggle("cdk-focused", !!c), n.classList.toggle("cdk-touch-focused", "touch" === c), n.classList.toggle("cdk-keyboard-focused", "keyboard" === c), n.classList.toggle("cdk-mouse-focused", "mouse" === c), n.classList.toggle("cdk-program-focused", "program" === c) } _setOrigin(n, c = !1) { this._ngZone.runOutsideAngular(() => { if (this._origin = n, this._originFromTouchInteraction = "touch" === n && c, 0 === this._detectionMode) { clearTimeout(this._originTimeoutId); const p = this._originFromTouchInteraction ? 650 : 1; this._originTimeoutId = setTimeout(() => this._origin = null, p) } }) } _onFocus(n, c) { const p = this._elementInfo.get(c), C = (0, xe.sA)(n); !p || !p.checkChildren && c !== C || this._originChanged(c, this._getFocusOrigin(C), p) } _onBlur(n, c) { const p = this._elementInfo.get(c); !p || p.checkChildren && n.relatedTarget instanceof Node && c.contains(n.relatedTarget) || (this._setClasses(c), this._emitOrigin(p.subject, null)) } _emitOrigin(n, c) { this._ngZone.run(() => n.next(c)) } _registerGlobalListeners(n) { if (!this._platform.isBrowser) return; const c = n.rootNode, p = this._rootNodeFocusListenerCount.get(c) || 0; p || this._ngZone.runOutsideAngular(() => { c.addEventListener("focus", this._rootNodeFocusAndBlurListener, Lt), c.addEventListener("blur", this._rootNodeFocusAndBlurListener, Lt) }), this._rootNodeFocusListenerCount.set(c, p + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe((0, Nn.R)(this._stopInputModalityDetector)).subscribe(C => { this._setOrigin(C, !0) })) } _removeGlobalListeners(n) { const c = n.rootNode; if (this._rootNodeFocusListenerCount.has(c)) { const p = this._rootNodeFocusListenerCount.get(c); p > 1 ? this._rootNodeFocusListenerCount.set(c, p - 1) : (c.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Lt), c.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Lt), this._rootNodeFocusListenerCount.delete(c)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(n, c, p) { this._setClasses(n, c), this._emitOrigin(p.subject, c), this._lastFocusOrigin = c } _getClosestElementsInfo(n) { const c = []; return this._elementInfo.forEach((p, C) => { (C === n || p.checkChildren && C.contains(n)) && c.push([C, p]) }), c } } Ht.\u0275fac = function (n) { return new (n || Ht)(a.LFG(a.R0b), a.LFG(xe.t4), a.LFG(Kt), a.LFG(O.K0, 8), a.LFG(jt, 8)) }, Ht.\u0275prov = a.Yz7({ token: Ht, factory: Ht.\u0275fac, providedIn: "root" }); class Ct { constructor(n, c) { this._elementRef = n, this._focusMonitor = c, this.cdkFocusChange = new a.vpe } ngAfterViewInit() { const n = this._elementRef.nativeElement; this._monitorSubscription = this._focusMonitor.monitor(n, 1 === n.nodeType && n.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(c => this.cdkFocusChange.emit(c)) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._monitorSubscription && this._monitorSubscription.unsubscribe() } } Ct.\u0275fac = function (n) { return new (n || Ct)(a.Y36(a.SBq), a.Y36(Ht)) }, Ct.\u0275dir = a.lG2({ type: Ct, selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]], outputs: { cdkFocusChange: "cdkFocusChange" } }); const xn = "cdk-high-contrast-black-on-white", bi = "cdk-high-contrast-white-on-black", Qt = "cdk-high-contrast-active"; class He { constructor(n, c) { this._platform = n, this._document = c } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const n = this._document.createElement("div"); n.style.backgroundColor = "rgb(1,2,3)", n.style.position = "absolute", this._document.body.appendChild(n); const c = this._document.defaultView || window, p = c && c.getComputedStyle ? c.getComputedStyle(n) : null, C = (p && p.backgroundColor || "").replace(/ /g, ""); switch (n.remove(), C) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const n = this._document.body.classList; n.remove(Qt), n.remove(xn), n.remove(bi), this._hasCheckedHighContrastMode = !0; const c = this.getHighContrastMode(); 1 === c ? (n.add(Qt), n.add(xn)) : 2 === c && (n.add(Qt), n.add(bi)) } } } He.\u0275fac = function (n) { return new (n || He)(a.LFG(xe.t4), a.LFG(O.K0)) }, He.\u0275prov = a.Yz7({ token: He, factory: He.\u0275fac, providedIn: "root" }); class fs { constructor(n) { n._applyBodyHighContrastModeCssClasses() } } fs.\u0275fac = function (n) { return new (n || fs)(a.LFG(He)) }, fs.\u0275mod = a.oAB({ type: fs }), fs.\u0275inj = a.cJS({ imports: [[xe.ud, as]] }); var Wt = I(6093); new a.GfV("13.0.3"); var Hn = I(9474); const Qn = ["*", [["mat-option"], ["ng-container"]]]; function Wn(S, n) { if (1 & S && a._UZ(0, "mat-pseudo-checkbox", 4), 2 & S) { const c = a.oxw(); a.Q6J("state", c.selected ? "checked" : "unchecked")("disabled", c.disabled) } } function ps(S, n) { if (1 & S && (a.TgZ(0, "span", 5), a._uU(1), a.qZA()), 2 & S) { const c = a.oxw(); a.xp6(1), a.hij("(", c.group.label, ")") } } new a.GfV("13.0.3"); class Ds { } Ds.STANDARD_CURVE = "cubic-bezier(0.4,0.0,0.2,1)", Ds.DECELERATION_CURVE = "cubic-bezier(0.0,0.0,0.2,1)", Ds.ACCELERATION_CURVE = "cubic-bezier(0.4,0.0,1,1)", Ds.SHARP_CURVE = "cubic-bezier(0.4,0.0,0.6,1)"; class vn { } vn.COMPLEX = "375ms", vn.ENTERING = "225ms", vn.EXITING = "195ms"; new a.GfV("13.0.3"); const Ei = new a.OlP("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); class et { constructor(n, c, p) { this._sanityChecks = c, this._document = p, this._hasDoneGlobalChecks = !1, n._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(n) { return !(0, xe.Oy)() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[n]) } } function kt(S, n) { return class extends S { constructor(...c) { super(...c), this.defaultColor = n, this.color = n } get color() { return this._color } set color(c) { const p = c || this.defaultColor; p !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), p && this._elementRef.nativeElement.classList.add(`mat-${p}`), this._color = p) } } } et.\u0275fac = function (n) { return new (n || et)(a.LFG(He), a.LFG(Ei, 8), a.LFG(O.K0)) }, et.\u0275mod = a.oAB({ type: et }), et.\u0275inj = a.cJS({ imports: [[Wt.vT], Wt.vT] }); const r = new a.OlP("MAT_DATE_LOCALE", { providedIn: "root", factory: function () { return (0, a.f3M)(a.soG) } }); class g { constructor() { this._localeChanges = new o.x, this.localeChanges = this._localeChanges } getValidDateOrNull(n) { return this.isDateInstance(n) && this.isValid(n) ? n : null } deserialize(n) { return null == n || this.isDateInstance(n) && this.isValid(n) ? n : this.invalid() } setLocale(n) { this.locale = n, this._localeChanges.next() } compareDate(n, c) { return this.getYear(n) - this.getYear(c) || this.getMonth(n) - this.getMonth(c) || this.getDate(n) - this.getDate(c) } sameDate(n, c) { if (n && c) { let p = this.isValid(n), C = this.isValid(c); return p && C ? !this.compareDate(n, c) : p == C } return n == c } clampDate(n, c, p) { return c && this.compareDate(n, c) < 0 ? c : p && this.compareDate(n, p) > 0 ? p : n } } const m = new a.OlP("mat-date-formats"), b = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/; function E(S, n) { const c = Array(S); for (let p = 0; p < S; p++)c[p] = n(p); return c } class D extends g { constructor(n, c) { super(), this.useUtcForDisplay = !1, super.setLocale(n) } getYear(n) { return n.getFullYear() } getMonth(n) { return n.getMonth() } getDate(n) { return n.getDate() } getDayOfWeek(n) { return n.getDay() } getMonthNames(n) { const c = new Intl.DateTimeFormat(this.locale, { month: n, timeZone: "utc" }); return E(12, p => this._format(c, new Date(2017, p, 1))) } getDateNames() { const n = new Intl.DateTimeFormat(this.locale, { day: "numeric", timeZone: "utc" }); return E(31, c => this._format(n, new Date(2017, 0, c + 1))) } getDayOfWeekNames(n) { const c = new Intl.DateTimeFormat(this.locale, { weekday: n, timeZone: "utc" }); return E(7, p => this._format(c, new Date(2017, 0, p + 1))) } getYearName(n) { const c = new Intl.DateTimeFormat(this.locale, { year: "numeric", timeZone: "utc" }); return this._format(c, n) } getFirstDayOfWeek() { return 0 } getNumDaysInMonth(n) { return this.getDate(this._createDateWithOverflow(this.getYear(n), this.getMonth(n) + 1, 0)) } clone(n) { return new Date(n.getTime()) } createDate(n, c, p) { let C = this._createDateWithOverflow(n, c, p); return C.getMonth(), C } today() { return new Date } parse(n) { return "number" == typeof n ? new Date(n) : n ? new Date(Date.parse(n)) : null } format(n, c) { if (!this.isValid(n)) throw Error("NativeDateAdapter: Cannot format invalid date."); const p = new Intl.DateTimeFormat(this.locale, nr(be({}, c), { timeZone: "utc" })); return this._format(p, n) } addCalendarYears(n, c) { return this.addCalendarMonths(n, 12 * c) } addCalendarMonths(n, c) { let p = this._createDateWithOverflow(this.getYear(n), this.getMonth(n) + c, this.getDate(n)); return this.getMonth(p) != ((this.getMonth(n) + c) % 12 + 12) % 12 && (p = this._createDateWithOverflow(this.getYear(p), this.getMonth(p), 0)), p } addCalendarDays(n, c) { return this._createDateWithOverflow(this.getYear(n), this.getMonth(n), this.getDate(n) + c) } toIso8601(n) { return [n.getUTCFullYear(), this._2digit(n.getUTCMonth() + 1), this._2digit(n.getUTCDate())].join("-") } deserialize(n) { if ("string" == typeof n) { if (!n) return null; if (b.test(n)) { let c = new Date(n); if (this.isValid(c)) return c } } return super.deserialize(n) } isDateInstance(n) { return n instanceof Date } isValid(n) { return !isNaN(n.getTime()) } invalid() { return new Date(NaN) } _createDateWithOverflow(n, c, p) { const C = new Date; return C.setFullYear(n, c, p), C.setHours(0, 0, 0, 0), C } _2digit(n) { return ("00" + n).slice(-2) } _format(n, c) { const p = new Date; return p.setUTCFullYear(c.getFullYear(), c.getMonth(), c.getDate()), p.setUTCHours(c.getHours(), c.getMinutes(), c.getSeconds(), c.getMilliseconds()), n.format(p) } } D.\u0275fac = function (n) { return new (n || D)(a.LFG(r, 8), a.LFG(xe.t4)) }, D.\u0275prov = a.Yz7({ token: D, factory: D.\u0275fac }); class U { } U.\u0275fac = function (n) { return new (n || U) }, U.\u0275mod = a.oAB({ type: U }), U.\u0275inj = a.cJS({ providers: [{ provide: g, useClass: D }], imports: [[xe.ud]] }); class X { } X.\u0275fac = function (n) { return new (n || X) }, X.\u0275mod = a.oAB({ type: X }), X.\u0275inj = a.cJS({ providers: [{ provide: m, useValue: { parse: { dateInput: null }, display: { dateInput: { year: "numeric", month: "numeric", day: "numeric" }, monthYearLabel: { year: "numeric", month: "short" }, dateA11yLabel: { year: "numeric", month: "long", day: "numeric" }, monthYearA11yLabel: { year: "numeric", month: "long" } } } }], imports: [[U]] }); class ne { isErrorState(n, c) { return !!(n && n.invalid && (n.dirty || c && c.submitted)) } } ne.\u0275fac = function (n) { return new (n || ne) }, ne.\u0275prov = a.Yz7({ token: ne, factory: ne.\u0275fac }); class Y { isErrorState(n, c) { return !!(n && n.invalid && (n.touched || c && c.submitted)) } } Y.\u0275fac = function (n) { return new (n || Y) }, Y.\u0275prov = a.Yz7({ token: Y, factory: Y.\u0275fac, providedIn: "root" }); class K { } K.\u0275fac = function (n) { return new (n || K) }, K.\u0275dir = a.lG2({ type: K, selectors: [["", "mat-line", ""], ["", "matLine", ""]], hostAttrs: [1, "mat-line"] }); class ue { } ue.\u0275fac = function (n) { return new (n || ue) }, ue.\u0275mod = a.oAB({ type: ue }), ue.\u0275inj = a.cJS({ imports: [[et], et] }); class Ie { constructor(n, c, p) { this._renderer = n, this.element = c, this.config = p, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const Fe = { enterDuration: 225, exitDuration: 150 }, lt = (0, xe.i$)({ passive: !0 }), Ce = ["mousedown", "touchstart"], At = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class Mt { constructor(n, c, p, C) { this._target = n, this._ngZone = c, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, C.isBrowser && (this._containerElement = (0, it.fI)(p)) } fadeInRipple(n, c, p = {}) { const C = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), z = be(be({}, Fe), p.animation); p.centered && (n = C.left + C.width / 2, c = C.top + C.height / 2); const ge = p.radius || function (S, n, c) { const p = Math.max(Math.abs(S - c.left), Math.abs(S - c.right)), C = Math.max(Math.abs(n - c.top), Math.abs(n - c.bottom)); return Math.sqrt(p * p + C * C) }(n, c, C), ht = n - C.left, Sn = c - C.top, Hs = z.enterDuration, Ge = document.createElement("div"); var S; Ge.classList.add("mat-ripple-element"), Ge.style.left = ht - ge + "px", Ge.style.top = Sn - ge + "px", Ge.style.height = 2 * ge + "px", Ge.style.width = 2 * ge + "px", null != p.color && (Ge.style.backgroundColor = p.color), Ge.style.transitionDuration = `${Hs}ms`, this._containerElement.appendChild(Ge), S = Ge, window.getComputedStyle(S).getPropertyValue("opacity"), Ge.style.transform = "scale(1)"; const Os = new Ie(this, Ge, p); return Os.state = 0, this._activeRipples.add(Os), p.persistent || (this._mostRecentTransientRipple = Os), this._runTimeoutOutsideZone(() => { const Ls = Os === this._mostRecentTransientRipple; Os.state = 1, !p.persistent && (!Ls || !this._isPointerDown) && Os.fadeOut() }, Hs), Os } fadeOutRipple(n) { const c = this._activeRipples.delete(n); if (n === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !c) return; const p = n.element, C = be(be({}, Fe), n.config.animation); p.style.transitionDuration = `${C.exitDuration}ms`, p.style.opacity = "0", n.state = 2, this._runTimeoutOutsideZone(() => { n.state = 3, p.remove() }, C.exitDuration) } fadeOutAll() { this._activeRipples.forEach(n => n.fadeOut()) } fadeOutAllNonPersistent() { this._activeRipples.forEach(n => { n.config.persistent || n.fadeOut() }) } setupTriggerEvents(n) { const c = (0, it.fI)(n); !c || c === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = c, this._registerEvents(Ce)) } handleEvent(n) { "mousedown" === n.type ? this._onMousedown(n) : "touchstart" === n.type ? this._onTouchStart(n) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(At), this._pointerUpEventsRegistered = !0) } _onMousedown(n) { const c = Ot(n), p = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !c && !p && (this._isPointerDown = !0, this.fadeInRipple(n.clientX, n.clientY, this._target.rippleConfig)) } _onTouchStart(n) { if (!this._target.rippleDisabled && !Cs(n)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const c = n.changedTouches; for (let p = 0; p < c.length; p++)this.fadeInRipple(c[p].clientX, c[p].clientY, this._target.rippleConfig) } } _onPointerUp() { !this._isPointerDown || (this._isPointerDown = !1, this._activeRipples.forEach(n => { const c = 1 === n.state || n.config.terminateOnPointerUp && 0 === n.state; !n.config.persistent && c && n.fadeOut() })) } _runTimeoutOutsideZone(n, c = 0) { this._ngZone.runOutsideAngular(() => setTimeout(n, c)) } _registerEvents(n) { this._ngZone.runOutsideAngular(() => { n.forEach(c => { this._triggerElement.addEventListener(c, this, lt) }) }) } _removeTriggerEvents() { this._triggerElement && (Ce.forEach(n => { this._triggerElement.removeEventListener(n, this, lt) }), this._pointerUpEventsRegistered && At.forEach(n => { this._triggerElement.removeEventListener(n, this, lt) })) } } const Ts = new a.OlP("mat-ripple-global-options"); class ct { constructor(n, c, p, C, z) { this._elementRef = n, this._animationMode = z, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = C || {}, this._rippleRenderer = new Mt(this, c, n, p) } get disabled() { return this._disabled } set disabled(n) { n && this.fadeOutAllNonPersistent(), this._disabled = n, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(n) { this._trigger = n, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: be(be(be({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(n, c = 0, p) { return "number" == typeof n ? this._rippleRenderer.fadeInRipple(n, c, be(be({}, this.rippleConfig), p)) : this._rippleRenderer.fadeInRipple(0, 0, be(be({}, this.rippleConfig), n)) } } ct.\u0275fac = function (n) { return new (n || ct)(a.Y36(a.SBq), a.Y36(a.R0b), a.Y36(xe.t4), a.Y36(Ts, 8), a.Y36(Hn.Qb, 8)) }, ct.\u0275dir = a.lG2({ type: ct, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (n, c) { 2 & n && a.ekj("mat-ripple-unbounded", c.unbounded) }, inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] }); class qt { } qt.\u0275fac = function (n) { return new (n || qt) }, qt.\u0275mod = a.oAB({ type: qt }), qt.\u0275inj = a.cJS({ imports: [[et, xe.ud], et] }); class Fs { constructor(n) { this._animationMode = n, this.state = "unchecked", this.disabled = !1 } } Fs.\u0275fac = function (n) { return new (n || Fs)(a.Y36(Hn.Qb, 8)) }, Fs.\u0275cmp = a.Xpm({ type: Fs, selectors: [["mat-pseudo-checkbox"]], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 8, hostBindings: function (n, c) { 2 & n && a.ekj("mat-pseudo-checkbox-indeterminate", "indeterminate" === c.state)("mat-pseudo-checkbox-checked", "checked" === c.state)("mat-pseudo-checkbox-disabled", c.disabled)("_mat-animation-noopable", "NoopAnimations" === c._animationMode) }, inputs: { state: "state", disabled: "disabled" }, decls: 0, vars: 0, template: function (n, c) { }, styles: ['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'], encapsulation: 2, changeDetection: 0 }); class B { } B.\u0275fac = function (n) { return new (n || B) }, B.\u0275mod = a.oAB({ type: B }), B.\u0275inj = a.cJS({ imports: [[et]] }); const $ = new a.OlP("MAT_OPTION_PARENT_COMPONENT"), H = (S = class { }, class extends S { constructor(...n) { super(...n), this._disabled = !1 } get disabled() { return this._disabled } set disabled(n) { this._disabled = (0, it.Ig)(n) } }); var S; let re = 0; class Ee extends H { constructor(n) { var c; super(), this._labelId = "mat-optgroup-label-" + re++, this._inert = null != (c = null == n ? void 0 : n.inertGroups) && c } } Ee.\u0275fac = function (n) { return new (n || Ee)(a.Y36($, 8)) }, Ee.\u0275dir = a.lG2({ type: Ee, inputs: { label: "label" }, features: [a.qOj] }); const dt = new a.OlP("MatOptgroup"); class Oe extends Ee { } Oe.\u0275fac = function () { let S; return function (c) { return (S || (S = a.n5z(Oe)))(c || Oe) } }(), Oe.\u0275cmp = a.Xpm({ type: Oe, selectors: [["mat-optgroup"]], hostAttrs: [1, "mat-optgroup"], hostVars: 5, hostBindings: function (n, c) { 2 & n && (a.uIk("role", c._inert ? null : "group")("aria-disabled", c._inert ? null : c.disabled.toString())("aria-labelledby", c._inert ? null : c._labelId), a.ekj("mat-optgroup-disabled", c.disabled)) }, inputs: { disabled: "disabled" }, exportAs: ["matOptgroup"], features: [a._Bn([{ provide: dt, useExisting: Oe }]), a.qOj], ngContentSelectors: ["*", "mat-option, ng-container"], decls: 4, vars: 2, consts: [["aria-hidden", "true", 1, "mat-optgroup-label", 3, "id"]], template: function (n, c) { 1 & n && (a.F$t(Qn), a.TgZ(0, "span", 0), a._uU(1), a.Hsn(2), a.qZA(), a.Hsn(3, 1)), 2 & n && (a.Q6J("id", c._labelId), a.xp6(1), a.hij("", c.label, " ")) }, styles: [".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }); let Zt = 0; class ye { constructor(n, c = !1) { this.source = n, this.isUserInput = c } } class js { constructor(n, c, p, C) { this._element = n, this._changeDetectorRef = c, this._parent = p, this.group = C, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = "mat-option-" + Zt++, this.onSelectionChange = new a.vpe, this._stateChanges = new o.x } get multiple() { return this._parent && this._parent.multiple } get selected() { return this._selected } get disabled() { return this.group && this.group.disabled || this._disabled } set disabled(n) { this._disabled = (0, it.Ig)(n) } get disableRipple() { return this._parent && this._parent.disableRipple } get active() { return this._active } get viewValue() { return (this._getHostElement().textContent || "").trim() } select() { this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } deselect() { this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } focus(n, c) { const p = this._getHostElement(); "function" == typeof p.focus && p.focus(c) } setActiveStyles() { this._active || (this._active = !0, this._changeDetectorRef.markForCheck()) } setInactiveStyles() { this._active && (this._active = !1, this._changeDetectorRef.markForCheck()) } getLabel() { return this.viewValue } _handleKeydown(n) { (13 === n.keyCode || 32 === n.keyCode) && !function (S, ...n) { return n.length ? n.some(c => S[c]) : S.altKey || S.shiftKey || S.ctrlKey || S.metaKey }(n) && (this._selectViaInteraction(), n.preventDefault()) } _selectViaInteraction() { this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0)) } _getAriaSelected() { return this.selected || !this.multiple && null } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._element.nativeElement } ngAfterViewChecked() { if (this._selected) { const n = this.viewValue; n !== this._mostRecentViewValue && (this._mostRecentViewValue = n, this._stateChanges.next()) } } ngOnDestroy() { this._stateChanges.complete() } _emitSelectionChangeEvent(n = !1) { this.onSelectionChange.emit(new ye(this, n)) } } js.\u0275fac = function (n) { a.$Z() }, js.\u0275dir = a.lG2({ type: js, inputs: { value: "value", id: "id", disabled: "disabled" }, outputs: { onSelectionChange: "onSelectionChange" } }); class Te extends js { constructor(n, c, p, C) { super(n, c, p, C) } } Te.\u0275fac = function (n) { return new (n || Te)(a.Y36(a.SBq), a.Y36(a.sBO), a.Y36($, 8), a.Y36(dt, 8)) }, Te.\u0275cmp = a.Xpm({ type: Te, selectors: [["mat-option"]], hostAttrs: ["role", "option", 1, "mat-option", "mat-focus-indicator"], hostVars: 12, hostBindings: function (n, c) { 1 & n && a.NdJ("click", function () { return c._selectViaInteraction() })("keydown", function (C) { return c._handleKeydown(C) }), 2 & n && (a.Ikx("id", c.id), a.uIk("tabindex", c._getTabIndex())("aria-selected", c._getAriaSelected())("aria-disabled", c.disabled.toString()), a.ekj("mat-selected", c.selected)("mat-option-multiple", c.multiple)("mat-active", c.active)("mat-option-disabled", c.disabled)) }, exportAs: ["matOption"], features: [a.qOj], ngContentSelectors: ["*"], decls: 5, vars: 4, consts: [["class", "mat-option-pseudo-checkbox", 3, "state", "disabled", 4, "ngIf"], [1, "mat-option-text"], ["class", "cdk-visually-hidden", 4, "ngIf"], ["mat-ripple", "", 1, "mat-option-ripple", 3, "matRippleTrigger", "matRippleDisabled"], [1, "mat-option-pseudo-checkbox", 3, "state", "disabled"], [1, "cdk-visually-hidden"]], template: function (n, c) { 1 & n && (a.F$t(), a.YNc(0, Wn, 1, 2, "mat-pseudo-checkbox", 0), a.TgZ(1, "span", 1), a.Hsn(2), a.qZA(), a.YNc(3, ps, 2, 1, "span", 2), a._UZ(4, "div", 3)), 2 & n && (a.Q6J("ngIf", c.multiple), a.xp6(3), a.Q6J("ngIf", c.group && c.group._inert), a.xp6(1), a.Q6J("matRippleTrigger", c._getHostElement())("matRippleDisabled", c.disabled || c.disableRipple)) }, directives: [O.O5, ct, Fs], styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.cdk-high-contrast-active .mat-option[aria-disabled=true]{opacity:.5}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }); class ut { } ut.\u0275fac = function (n) { return new (n || ut) }, ut.\u0275mod = a.oAB({ type: ut }), ut.\u0275inj = a.cJS({ imports: [[qt, O.ez, et, B]] }) }, 9474: (Ae, J, I) => { "use strict"; I.d(J, { Qb: () => wi }); var a = I(4001), O = I(6219); class k { } const v = "*"; function F(u, e = null) { return { type: 2, steps: u, options: e } } function te(u) { return { type: 6, styles: u, offset: null } } function We(u) { Promise.resolve(null).then(u) } class ze { constructor(e = 0, t = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + t } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { We(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(e => e()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(e) { this._position = this.totalTime ? e * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(e) { const t = "start" == e ? this._onStartFns : this._onDoneFns; t.forEach(r => r()), t.length = 0 } } class bt { constructor(e) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e; let t = 0, r = 0, h = 0; const g = this.players.length; 0 == g ? We(() => this._onFinish()) : this.players.forEach(m => { m.onDone(() => { ++t == g && this._onFinish() }), m.onDestroy(() => { ++r == g && this._onDestroy() }), m.onStart(() => { ++h == g && this._onStart() }) }), this.totalTime = this.players.reduce((m, b) => Math.max(m, b.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this.players.forEach(e => e.init()) } onStart(e) { this._onStartFns.push(e) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = []) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play()) } pause() { this.players.forEach(e => e.pause()) } restart() { this.players.forEach(e => e.restart()) } finish() { this._onFinish(), this.players.forEach(e => e.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(e) { const t = e * this.totalTime; this.players.forEach(r => { const h = r.totalTime ? Math.min(1, t / r.totalTime) : 1; r.setPosition(h) }) } getPosition() { const e = this.players.reduce((t, r) => null === t || r.totalTime > t.totalTime ? r : t, null); return null != e ? e.getPosition() : 0 } beforeDestroy() { this.players.forEach(e => { e.beforeDestroy && e.beforeDestroy() }) } triggerCallback(e) { const t = "start" == e ? this._onStartFns : this._onDoneFns; t.forEach(r => r()), t.length = 0 } } function fe() { return "undefined" != typeof window && void 0 !== window.document } function Be() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function Me(u) { switch (u.length) { case 0: return new ze; case 1: return u[0]; default: return new bt(u) } } function j(u, e, t, r, h = {}, g = {}) { const m = [], b = []; let E = -1, D = null; if (r.forEach(R => { const U = R.offset, X = U == E, ne = X && D || {}; Object.keys(R).forEach(Y => { let K = Y, ae = R[Y]; if ("offset" !== Y) switch (K = e.normalizePropertyName(K, m), ae) { case "!": ae = h[Y]; break; case v: ae = g[Y]; break; default: ae = e.normalizeStyleValue(Y, K, ae, m) }ne[K] = ae }), X || b.push(ne), D = ne, E = U }), m.length) { const R = "\n - "; throw new Error(`Unable to animate due to the following errors:${R}${m.join(R)}`) } return b } function G(u, e, t, r) { switch (e) { case "start": u.onStart(() => r(t && P(t, "start", u))); break; case "done": u.onDone(() => r(t && P(t, "done", u))); break; case "destroy": u.onDestroy(() => r(t && P(t, "destroy", u))) } } function P(u, e, t) { const r = t.totalTime, h = !!t.disabled, g = se(u.element, u.triggerName, u.fromState, u.toState, e || u.phaseName, null == r ? u.totalTime : r, h), m = u._data; return null != m && (g._data = m), g } function se(u, e, t, r, h = "", g = 0, m) { return { element: u, triggerName: e, fromState: t, toState: r, phaseName: h, totalTime: g, disabled: !!m } } function ee(u, e, t) { let r; return u instanceof Map ? (r = u.get(e), r || u.set(e, r = t)) : (r = u[e], r || (r = u[e] = t)), r } function gt(u) { const e = u.indexOf(":"); return [u.substring(1, e), u.substr(e + 1)] } let N = (u, e) => !1, W = (u, e) => !1, de = (u, e, t) => []; const V = Be(); (V || "undefined" != typeof Element) && (N = fe() ? (u, e) => { for (; e && e !== document.documentElement;) { if (e === u) return !0; e = e.parentNode || e.host } return !1 } : (u, e) => u.contains(e), W = (() => { if (V || Element.prototype.matches) return (u, e) => u.matches(e); { const u = Element.prototype, e = u.matchesSelector || u.mozMatchesSelector || u.msMatchesSelector || u.oMatchesSelector || u.webkitMatchesSelector; return e ? (t, r) => e.apply(t, [r]) : W } })(), de = (u, e, t) => { let r = []; if (t) { const h = u.querySelectorAll(e); for (let g = 0; g < h.length; g++)r.push(h[g]) } else { const h = u.querySelector(e); h && r.push(h) } return r }); let L = null, pe = !1; function Ue(u) { L || (L = ("undefined" != typeof document ? document.body : null) || {}, pe = !!L.style && "WebkitAppearance" in L.style); let e = !0; return L.style && !function (u) { return "ebkit" == u.substring(1, 6) }(u) && (e = u in L.style, !e && pe && (e = "Webkit" + u.charAt(0).toUpperCase() + u.substr(1) in L.style)), e } const Dt = W, qs = N, Zs = de; function vs(u) { const e = {}; return Object.keys(u).forEach(t => { const r = t.replace(/([a-z])([A-Z])/g, "$1-$2"); e[r] = u[t] }), e } class es { validateStyleProperty(e) { return Ue(e) } matchesElement(e, t) { return Dt(e, t) } containsElement(e, t) { return qs(e, t) } query(e, t, r) { return Zs(e, t, r) } computeStyle(e, t, r) { return r || "" } animate(e, t, r, h, g, m = [], b) { return new ze(r, h) } } es.\u0275fac = function (e) { return new (e || es) }, es.\u0275prov = a.Yz7({ token: es, factory: es.\u0275fac }); class Xs { } Xs.NOOP = new es; const Js = "ng-enter", en = "ng-leave", tn = "ng-trigger", sn = ".ng-trigger", ii = "ng-animating", nn = ".ng-animating"; function Ve(u) { if ("number" == typeof u) return u; const e = u.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : nt(parseFloat(e[1]), e[2]) } function nt(u, e) { return "s" === e ? 1e3 * u : u } function Tt(u, e, t) { return u.hasOwnProperty("duration") ? u : function (u, e, t) { const r = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i; let h, g = 0, m = ""; if ("string" == typeof u) { const b = u.match(r); if (null === b) return e.push(`The provided timing value "${u}" is invalid.`), { duration: 0, delay: 0, easing: "" }; h = nt(parseFloat(b[1]), b[2]); const E = b[3]; null != E && (g = nt(parseFloat(E), b[4])); const D = b[5]; D && (m = D) } else h = u; if (!t) { let b = !1, E = e.length; h < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), b = !0), g < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), b = !0), b && e.splice(E, 0, `The provided timing value "${u}" is invalid.`) } return { duration: h, delay: g, easing: m } }(u, e, t) } function Ye(u, e = {}) { return Object.keys(u).forEach(t => { e[t] = u[t] }), e } function St(u, e, t = {}) { if (e) for (let r in u) t[r] = u[r]; else Ye(u, t); return t } function Rs(u, e, t) { return t ? e + ":" + t + ";" : "" } function Se(u) { let e = ""; for (let t = 0; t < u.style.length; t++) { const r = u.style.item(t); e += Rs(0, r, u.style.getPropertyValue(r)) } for (const t in u.style) { if (!u.style.hasOwnProperty(t) || t.startsWith("_")) continue; e += Rs(0, ai(t), u.style[t]) } u.setAttribute("style", e) } function ie(u, e, t) { u.style && (Object.keys(e).forEach(r => { const h = ln(r); t && !t.hasOwnProperty(r) && (t[r] = u.style[h]), u.style[h] = e[r] }), Be() && Se(u)) } function qe(u, e) { u.style && (Object.keys(e).forEach(t => { const r = ln(t); u.style[r] = "" }), Be() && Se(u)) } function Bs(u) { return Array.isArray(u) ? 1 == u.length ? u[0] : F(u) : u } const rn = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function ri(u) { let e = []; if ("string" == typeof u) { let t; for (; t = rn.exec(u);)e.push(t[1]); rn.lastIndex = 0 } return e } function on(u, e, t) { const r = u.toString(), h = r.replace(rn, (g, m) => { let b = e[m]; return e.hasOwnProperty(m) || (t.push(`Please provide a value for the animation param ${m}`), b = ""), b.toString() }); return h == r ? u : h } function an(u) { const e = []; let t = u.next(); for (; !t.done;)e.push(t.value), t = u.next(); return e } const oi = /-+([a-z0-9])/g; function ln(u) { return u.replace(oi, (...e) => e[1].toUpperCase()) } function ai(u) { return u.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function Dn(u, e) { return 0 === u || 0 === e } function In(u, e, t) { const r = Object.keys(t); if (r.length && e.length) { let g = e[0], m = []; if (r.forEach(b => { g.hasOwnProperty(b) || m.push(b), g[b] = t[b] }), m.length) for (var h = 1; h < e.length; h++) { let b = e[h]; m.forEach(function (E) { b[E] = pt(u, E) }) } } return e } function $e(u, e, t) { switch (e.type) { case 7: return u.visitTrigger(e, t); case 0: return u.visitState(e, t); case 1: return u.visitTransition(e, t); case 2: return u.visitSequence(e, t); case 3: return u.visitGroup(e, t); case 4: return u.visitAnimate(e, t); case 5: return u.visitKeyframes(e, t); case 6: return u.visitStyle(e, t); case 8: return u.visitReference(e, t); case 9: return u.visitAnimateChild(e, t); case 10: return u.visitAnimateRef(e, t); case 11: return u.visitQuery(e, t); case 12: return u.visitStagger(e, t); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function pt(u, e) { return window.getComputedStyle(u)[e] } function Oi(u, e) { const t = []; return "string" == typeof u ? u.split(/\s*,\s*/).forEach(r => function (u, e, t) { if (":" == u[0]) { const E = function (u, e) { switch (u) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, r) => parseFloat(r) > parseFloat(t); case ":decrement": return (t, r) => parseFloat(r) < parseFloat(t); default: return e.push(`The transition alias value "${u}" is not supported`), "* => *" } }(u, t); if ("function" == typeof E) return void e.push(E); u = E } const r = u.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return t.push(`The provided transition expression "${u}" is not supported`), e; const h = r[1], g = r[2], m = r[3]; e.push(li(h, m)); const b = "*" == h && "*" == m; "<" == g[0] && !b && e.push(li(m, h)) }(r, t, e)) : t.push(u), t } const dn = new Set(["true", "1"]), un = new Set(["false", "0"]); function li(u, e) { const t = dn.has(u) || un.has(u), r = dn.has(e) || un.has(e); return (h, g) => { let m = "*" == u || u == h, b = "*" == e || e == g; return !m && t && "boolean" == typeof h && (m = h ? dn.has(u) : un.has(u)), !b && r && "boolean" == typeof g && (b = g ? dn.has(e) : un.has(e)), m && b } } const mt = ":self", bs = new RegExp("s*:selfs*,?", "g"); function Tn(u, e, t) { return new Ri(u).build(e, t) } class Ri { constructor(e) { this._driver = e } build(e, t) { const r = new ci(t); return this._resetContextStyleTimingState(r), $e(this, Bs(e), r) } _resetContextStyleTimingState(e) { e.currentQuerySelector = "", e.collectedStyles = {}, e.collectedStyles[""] = {}, e.currentTime = 0 } visitTrigger(e, t) { let r = t.queryCount = 0, h = t.depCount = 0; const g = [], m = []; return "@" == e.name.charAt(0) && t.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), e.definitions.forEach(b => { if (this._resetContextStyleTimingState(t), 0 == b.type) { const E = b, D = E.name; D.toString().split(/\s*,\s*/).forEach(R => { E.name = R, g.push(this.visitState(E, t)) }), E.name = D } else if (1 == b.type) { const E = this.visitTransition(b, t); r += E.queryCount, h += E.depCount, m.push(E) } else t.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: e.name, states: g, transitions: m, queryCount: r, depCount: h, options: null } } visitState(e, t) { const r = this.visitStyle(e.styles, t), h = e.options && e.options.params || null; if (r.containsDynamicStyles) { const g = new Set, m = h || {}; if (r.styles.forEach(b => { if (Ft(b)) { const E = b; Object.keys(E).forEach(D => { ri(E[D]).forEach(R => { m.hasOwnProperty(R) || g.add(R) }) }) } }), g.size) { const b = an(g.values()); t.errors.push(`state("${e.name}", ...) must define default values for all the following style substitutions: ${b.join(", ")}`) } } return { type: 0, name: e.name, style: r, options: h ? { params: h } : null } } visitTransition(e, t) { t.queryCount = 0, t.depCount = 0; const r = $e(this, Bs(e.animation), t); return { type: 1, matchers: Oi(e.expr, t.errors), animation: r, queryCount: t.queryCount, depCount: t.depCount, options: Ss(e.options) } } visitSequence(e, t) { return { type: 2, steps: e.steps.map(r => $e(this, r, t)), options: Ss(e.options) } } visitGroup(e, t) { const r = t.currentTime; let h = 0; const g = e.steps.map(m => { t.currentTime = r; const b = $e(this, m, t); return h = Math.max(h, t.currentTime), b }); return t.currentTime = h, { type: 3, steps: g, options: Ss(e.options) } } visitAnimate(e, t) { const r = function (u, e) { let t = null; if (u.hasOwnProperty("duration")) t = u; else if ("number" == typeof u) { return Fn(Tt(u, e).duration, 0, "") } const r = u; if (r.split(/\s+/).some(g => "{" == g.charAt(0) && "{" == g.charAt(1))) { const g = Fn(0, 0, ""); return g.dynamic = !0, g.strValue = r, g } return t = t || Tt(r, e), Fn(t.duration, t.delay, t.easing) }(e.timings, t.errors); t.currentAnimateTimings = r; let h, g = e.styles ? e.styles : te({}); if (5 == g.type) h = this.visitKeyframes(g, t); else { let m = e.styles, b = !1; if (!m) { b = !0; const D = {}; r.easing && (D.easing = r.easing), m = te(D) } t.currentTime += r.duration + r.delay; const E = this.visitStyle(m, t); E.isEmptyStep = b, h = E } return t.currentAnimateTimings = null, { type: 4, timings: r, style: h, options: null } } visitStyle(e, t) { const r = this._makeStyleAst(e, t); return this._validateStyleAst(r, t), r } _makeStyleAst(e, t) { const r = []; Array.isArray(e.styles) ? e.styles.forEach(m => { "string" == typeof m ? m == v ? r.push(m) : t.errors.push(`The provided style string value ${m} is not allowed.`) : r.push(m) }) : r.push(e.styles); let h = !1, g = null; return r.forEach(m => { if (Ft(m)) { const b = m, E = b.easing; if (E && (g = E, delete b.easing), !h) for (let D in b) if (b[D].toString().indexOf("{{") >= 0) { h = !0; break } } }), { type: 6, styles: r, easing: g, offset: e.offset, containsDynamicStyles: h, options: null } } _validateStyleAst(e, t) { const r = t.currentAnimateTimings; let h = t.currentTime, g = t.currentTime; r && g > 0 && (g -= r.duration + r.delay), e.styles.forEach(m => { "string" != typeof m && Object.keys(m).forEach(b => { if (!this._driver.validateStyleProperty(b)) return void t.errors.push(`The provided animation property "${b}" is not a supported CSS property for animations`); const E = t.collectedStyles[t.currentQuerySelector], D = E[b]; let R = !0; D && (g != h && g >= D.startTime && h <= D.endTime && (t.errors.push(`The CSS property "${b}" that exists between the times of "${D.startTime}ms" and "${D.endTime}ms" is also being animated in a parallel animation between the times of "${g}ms" and "${h}ms"`), R = !1), g = D.startTime), R && (E[b] = { startTime: g, endTime: h }), t.options && function (u, e, t) { const r = e.params || {}, h = ri(u); h.length && h.forEach(g => { r.hasOwnProperty(g) || t.push(`Unable to resolve the local animation param ${g} in the given list of values`) }) }(m[b], t.options, t.errors) }) }) } visitKeyframes(e, t) { const r = { type: 5, styles: [], options: null }; if (!t.currentAnimateTimings) return t.errors.push("keyframes() must be placed inside of a call to animate()"), r; let g = 0; const m = []; let b = !1, E = !1, D = 0; const R = e.steps.map(ve => { const ue = this._makeStyleAst(ve, t); let Ie = null != ue.offset ? ue.offset : function (u) { if ("string" == typeof u) return null; let e = null; if (Array.isArray(u)) u.forEach(t => { if (Ft(t) && t.hasOwnProperty("offset")) { const r = t; e = parseFloat(r.offset), delete r.offset } }); else if (Ft(u) && u.hasOwnProperty("offset")) { const t = u; e = parseFloat(t.offset), delete t.offset } return e }(ue.styles), Fe = 0; return null != Ie && (g++, Fe = ue.offset = Ie), E = E || Fe < 0 || Fe > 1, b = b || Fe < D, D = Fe, m.push(Fe), ue }); E && t.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), b && t.errors.push("Please ensure that all keyframe offsets are in order"); const U = e.steps.length; let X = 0; g > 0 && g < U ? t.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == g && (X = 1 / (U - 1)); const ne = U - 1, Y = t.currentTime, K = t.currentAnimateTimings, ae = K.duration; return R.forEach((ve, ue) => { const Ie = X > 0 ? ue == ne ? 1 : X * ue : m[ue], Fe = Ie * ae; t.currentTime = Y + K.delay + Fe, K.duration = Fe, this._validateStyleAst(ve, t), ve.offset = Ie, r.styles.push(ve) }), r } visitReference(e, t) { return { type: 8, animation: $e(this, Bs(e.animation), t), options: Ss(e.options) } } visitAnimateChild(e, t) { return t.depCount++, { type: 9, options: Ss(e.options) } } visitAnimateRef(e, t) { return { type: 10, animation: this.visitReference(e.animation, t), options: Ss(e.options) } } visitQuery(e, t) { const r = t.currentQuerySelector, h = e.options || {}; t.queryCount++, t.currentQuery = e; const [g, m] = function (u) { const e = !!u.split(/\s*,\s*/).find(t => t == mt); return e && (u = u.replace(bs, "")), u = u.replace(/@\*/g, sn).replace(/@\w+/g, t => sn + "-" + t.substr(1)).replace(/:animating/g, nn), [u, e] }(e.selector); t.currentQuerySelector = r.length ? r + " " + g : g, ee(t.collectedStyles, t.currentQuerySelector, {}); const b = $e(this, Bs(e.animation), t); return t.currentQuery = null, t.currentQuerySelector = r, { type: 11, selector: g, limit: h.limit || 0, optional: !!h.optional, includeSelf: m, animation: b, originalSelector: e.selector, options: Ss(e.options) } } visitStagger(e, t) { t.currentQuery || t.errors.push("stagger() can only be used inside of query()"); const r = "full" === e.timings ? { duration: 0, delay: 0, easing: "full" } : Tt(e.timings, t.errors, !0); return { type: 12, animation: $e(this, Bs(e.animation), t), timings: r, options: null } } } class ci { constructor(e) { this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Ft(u) { return !Array.isArray(u) && "object" == typeof u } function Ss(u) { return u ? (u = Ye(u)).params && (u.params = function (u) { return u ? Ye(u) : null }(u.params)) : u = {}, u } function Fn(u, e, t) { return { duration: u, delay: e, easing: t } } function ns(u, e, t, r, h, g, m = null, b = !1) { return { type: 1, element: u, keyframes: e, preStyleProps: t, postStyleProps: r, duration: h, delay: g, totalTime: h + g, easing: m, subTimeline: b } } class hn { constructor() { this._map = new Map } consume(e) { let t = this._map.get(e); return t ? this._map.delete(e) : t = [], t } append(e, t) { let r = this._map.get(e); r || this._map.set(e, r = []), r.push(...t) } has(e) { return this._map.has(e) } clear() { this._map.clear() } } const di = new RegExp(":enter", "g"), yt = new RegExp(":leave", "g"); function On(u, e, t, r, h, g = {}, m = {}, b, E, D = []) { return (new is).buildKeyframes(u, e, t, r, h, g, m, b, E, D) } class is { buildKeyframes(e, t, r, h, g, m, b, E, D, R = []) { D = D || new hn; const U = new Ln(e, t, D, h, g, R, []); U.options = E, U.currentTimeline.setStyles([m], null, U.errors, E), $e(this, r, U); const X = U.timelines.filter(ne => ne.containsAnimation()); if (X.length && Object.keys(b).length) { const ne = X[X.length - 1]; ne.allowOnlyTimelineStyles() || ne.setStyles([b], null, U.errors, E) } return X.length ? X.map(ne => ne.buildKeyframes()) : [ns(t, [], [], [], 0, 0, "", !1)] } visitTrigger(e, t) { } visitState(e, t) { } visitTransition(e, t) { } visitAnimateChild(e, t) { const r = t.subInstructions.consume(t.element); if (r) { const h = t.createSubContext(e.options), g = t.currentTimeline.currentTime, m = this._visitSubInstructions(r, h, h.options); g != m && t.transformIntoNewTimeline(m) } t.previousNode = e } visitAnimateRef(e, t) { const r = t.createSubContext(e.options); r.transformIntoNewTimeline(), this.visitReference(e.animation, r), t.transformIntoNewTimeline(r.currentTimeline.currentTime), t.previousNode = e } _visitSubInstructions(e, t, r) { let g = t.currentTimeline.currentTime; const m = null != r.duration ? Ve(r.duration) : null, b = null != r.delay ? Ve(r.delay) : null; return 0 !== m && e.forEach(E => { const D = t.appendInstructionToTimeline(E, m, b); g = Math.max(g, D.duration + D.delay) }), g } visitReference(e, t) { t.updateOptions(e.options, !0), $e(this, e.animation, t), t.previousNode = e } visitSequence(e, t) { const r = t.subContextCount; let h = t; const g = e.options; if (g && (g.params || g.delay) && (h = t.createSubContext(g), h.transformIntoNewTimeline(), null != g.delay)) { 6 == h.previousNode.type && (h.currentTimeline.snapshotCurrentStyles(), h.previousNode = Pt); const m = Ve(g.delay); h.delayNextStep(m) } e.steps.length && (e.steps.forEach(m => $e(this, m, h)), h.currentTimeline.applyStylesToKeyframe(), h.subContextCount > r && h.transformIntoNewTimeline()), t.previousNode = e } visitGroup(e, t) { const r = []; let h = t.currentTimeline.currentTime; const g = e.options && e.options.delay ? Ve(e.options.delay) : 0; e.steps.forEach(m => { const b = t.createSubContext(e.options); g && b.delayNextStep(g), $e(this, m, b), h = Math.max(h, b.currentTimeline.currentTime), r.push(b.currentTimeline) }), r.forEach(m => t.currentTimeline.mergeTimelineCollectedStyles(m)), t.transformIntoNewTimeline(h), t.previousNode = e } _visitTiming(e, t) { if (e.dynamic) { const r = e.strValue; return Tt(t.params ? on(r, t.params, t.errors) : r, t.errors) } return { duration: e.duration, delay: e.delay, easing: e.easing } } visitAnimate(e, t) { const r = t.currentAnimateTimings = this._visitTiming(e.timings, t), h = t.currentTimeline; r.delay && (t.incrementTime(r.delay), h.snapshotCurrentStyles()); const g = e.style; 5 == g.type ? this.visitKeyframes(g, t) : (t.incrementTime(r.duration), this.visitStyle(g, t), h.applyStylesToKeyframe()), t.currentAnimateTimings = null, t.previousNode = e } visitStyle(e, t) { const r = t.currentTimeline, h = t.currentAnimateTimings; !h && r.getCurrentStyleProperties().length && r.forwardFrame(); const g = h && h.easing || e.easing; e.isEmptyStep ? r.applyEmptyStep(g) : r.setStyles(e.styles, g, t.errors, t.options), t.previousNode = e } visitKeyframes(e, t) { const r = t.currentAnimateTimings, h = t.currentTimeline.duration, g = r.duration, b = t.createSubContext().currentTimeline; b.easing = r.easing, e.styles.forEach(E => { const D = E.offset || 0; b.forwardTime(D * g), b.setStyles(E.styles, E.easing, t.errors, t.options), b.applyStylesToKeyframe() }), t.currentTimeline.mergeTimelineCollectedStyles(b), t.transformIntoNewTimeline(h + g), t.previousNode = e } visitQuery(e, t) { const r = t.currentTimeline.currentTime, h = e.options || {}, g = h.delay ? Ve(h.delay) : 0; g && (6 === t.previousNode.type || 0 == r && t.currentTimeline.getCurrentStyleProperties().length) && (t.currentTimeline.snapshotCurrentStyles(), t.previousNode = Pt); let m = r; const b = t.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!h.optional, t.errors); t.currentQueryTotal = b.length; let E = null; b.forEach((D, R) => { t.currentQueryIndex = R; const U = t.createSubContext(e.options, D); g && U.delayNextStep(g), D === t.element && (E = U.currentTimeline), $e(this, e.animation, U), U.currentTimeline.applyStylesToKeyframe(); const X = U.currentTimeline.currentTime; m = Math.max(m, X) }), t.currentQueryIndex = 0, t.currentQueryTotal = 0, t.transformIntoNewTimeline(m), E && (t.currentTimeline.mergeTimelineCollectedStyles(E), t.currentTimeline.snapshotCurrentStyles()), t.previousNode = e } visitStagger(e, t) { const r = t.parentContext, h = t.currentTimeline, g = e.timings, m = Math.abs(g.duration), b = m * (t.currentQueryTotal - 1); let E = m * t.currentQueryIndex; switch (g.duration < 0 ? "reverse" : g.easing) { case "reverse": E = b - E; break; case "full": E = r.currentStaggerTime }const R = t.currentTimeline; E && R.delayNextStep(E); const U = R.currentTime; $e(this, e.animation, t), t.previousNode = e, r.currentStaggerTime = h.currentTime - U + (h.startTime - r.currentTimeline.startTime) } } const Pt = {}; class Ln { constructor(e, t, r, h, g, m, b, E) { this._driver = e, this.element = t, this.subInstructions = r, this._enterClassName = h, this._leaveClassName = g, this.errors = m, this.timelines = b, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Pt, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = E || new gn(this._driver, t, 0), b.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(e, t) { if (!e) return; const r = e; let h = this.options; null != r.duration && (h.duration = Ve(r.duration)), null != r.delay && (h.delay = Ve(r.delay)); const g = r.params; if (g) { let m = h.params; m || (m = this.options.params = {}), Object.keys(g).forEach(b => { (!t || !m.hasOwnProperty(b)) && (m[b] = on(g[b], m, this.errors)) }) } } _copyOptions() { const e = {}; if (this.options) { const t = this.options.params; if (t) { const r = e.params = {}; Object.keys(t).forEach(h => { r[h] = t[h] }) } } return e } createSubContext(e = null, t, r) { const h = t || this.element, g = new Ln(this._driver, h, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(h, r || 0)); return g.previousNode = this.previousNode, g.currentAnimateTimings = this.currentAnimateTimings, g.options = this._copyOptions(), g.updateOptions(e), g.currentQueryIndex = this.currentQueryIndex, g.currentQueryTotal = this.currentQueryTotal, g.parentContext = this, this.subContextCount++, g } transformIntoNewTimeline(e) { return this.previousNode = Pt, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(e, t, r) { const h = { duration: null != t ? t : e.duration, delay: this.currentTimeline.currentTime + (null != r ? r : 0) + e.delay, easing: "" }, g = new Ki(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, h, e.stretchStartingKeyframe); return this.timelines.push(g), h } incrementTime(e) { this.currentTimeline.forwardTime(this.currentTimeline.duration + e) } delayNextStep(e) { e > 0 && this.currentTimeline.delayNextStep(e) } invokeQuery(e, t, r, h, g, m) { let b = []; if (h && b.push(this.element), e.length > 0) { e = (e = e.replace(di, "." + this._enterClassName)).replace(yt, "." + this._leaveClassName); const E = 1 != r; let D = this._driver.query(this.element, e, E); 0 !== r && (D = r < 0 ? D.slice(D.length + r, D.length) : D.slice(0, r)), b.push(...D) } return !g && 0 == b.length && m.push(`\`query("${t}")\` returned zero elements. (Use \`query("${t}", { optional: true })\` if you wish to allow this.)`), b } } class gn { constructor(e, t, r, h) { this._driver = e, this.element = t, this.startTime = r, this._elementTimelineStylesLookup = h, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(t), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(t, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(e) { const t = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || t ? (this.forwardTime(this.currentTime + e), t && this.snapshotCurrentStyles()) : this.startTime += e } fork(e, t) { return this.applyStylesToKeyframe(), new gn(this._driver, e, t || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(e) { this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe() } _updateStyle(e, t) { this._localTimelineStyles[e] = t, this._globalTimelineStyles[e] = t, this._styleSummary[e] = { time: this.currentTime, value: t } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(e) { e && (this._previousKeyframe.easing = e), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || v, this._currentKeyframe[t] = v }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(e, t, r, h) { t && (this._previousKeyframe.easing = t); const g = h && h.params || {}, m = function (u, e) { const t = {}; let r; return u.forEach(h => { "*" === h ? (r = r || Object.keys(e), r.forEach(g => { t[g] = v })) : St(h, !1, t) }), t }(e, this._globalTimelineStyles); Object.keys(m).forEach(b => { const E = on(m[b], g, r); this._pendingStyles[b] = E, this._localTimelineStyles.hasOwnProperty(b) || (this._backFill[b] = this._globalTimelineStyles.hasOwnProperty(b) ? this._globalTimelineStyles[b] : v), this._updateStyle(b, E) }) } applyStylesToKeyframe() { const e = this._pendingStyles, t = Object.keys(e); 0 != t.length && (this._pendingStyles = {}, t.forEach(r => { const h = e[r]; this._currentKeyframe[r] = h }), Object.keys(this._localTimelineStyles).forEach(r => { this._currentKeyframe.hasOwnProperty(r) || (this._currentKeyframe[r] = this._localTimelineStyles[r]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(e => { const t = this._localTimelineStyles[e]; this._pendingStyles[e] = t, this._updateStyle(e, t) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const e = []; for (let t in this._currentKeyframe) e.push(t); return e } mergeTimelineCollectedStyles(e) { Object.keys(e._styleSummary).forEach(t => { const r = this._styleSummary[t], h = e._styleSummary[t]; (!r || h.time > r.time) && this._updateStyle(t, h.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const e = new Set, t = new Set, r = 1 === this._keyframes.size && 0 === this.duration; let h = []; this._keyframes.forEach((b, E) => { const D = St(b, !0); Object.keys(D).forEach(R => { const U = D[R]; "!" == U ? e.add(R) : U == v && t.add(R) }), r || (D.offset = E / this.duration), h.push(D) }); const g = e.size ? an(e.values()) : [], m = t.size ? an(t.values()) : []; if (r) { const b = h[0], E = Ye(b); b.offset = 0, E.offset = 1, h = [b, E] } return ns(this.element, h, g, m, this.duration, this.startTime, this.easing, !1) } } class Ki extends gn { constructor(e, t, r, h, g, m, b = !1) { super(e, t, m.delay), this.keyframes = r, this.preStyleProps = h, this.postStyleProps = g, this._stretchStartingKeyframe = b, this.timings = { duration: m.duration, delay: m.delay, easing: m.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let e = this.keyframes, { delay: t, duration: r, easing: h } = this.timings; if (this._stretchStartingKeyframe && t) { const g = [], m = r + t, b = t / m, E = St(e[0], !1); E.offset = 0, g.push(E); const D = St(e[0], !1); D.offset = rs(b), g.push(D); const R = e.length - 1; for (let U = 1; U <= R; U++) { let X = St(e[U], !1); const Y = t + X.offset * r; X.offset = rs(Y / m), g.push(X) } r = m, t = 0, h = "", e = g } return ns(this.element, e, this.preStyleProps, this.postStyleProps, r, t, h, !0) } } function rs(u, e = 3) { const t = Math.pow(10, e - 1); return Math.round(u * t) / t } class hi { } class os extends hi { normalizePropertyName(e, t) { return ln(e) } normalizeStyleValue(e, t, r, h) { let g = ""; const m = r.toString().trim(); if (zs[t] && 0 !== r && "0" !== r) if ("number" == typeof r) g = "px"; else { const b = r.match(/^[+-]?[\d\.]+([a-z]*)$/); b && 0 == b[1].length && h.push(`Please provide a CSS unit value for ${e}:${r}`) } return m + g } } const zs = function (u) { const e = {}; return u.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")); function gi(u, e, t, r, h, g, m, b, E, D, R, U, X) { return { type: 0, element: u, triggerName: e, isRemovalTransition: h, fromState: t, fromStyles: g, toState: r, toStyles: m, timelines: b, queriedElements: E, preStyleProps: D, postStyleProps: R, totalTime: U, errors: X } } const Rn = {}; class Gt { constructor(e, t, r) { this._triggerName = e, this.ast = t, this._stateStyles = r } match(e, t, r, h) { return function (u, e, t, r, h) { return u.some(g => g(e, t, r, h)) }(this.ast.matchers, e, t, r, h) } buildStyles(e, t, r) { const h = this._stateStyles["*"], g = this._stateStyles[e], m = h ? h.buildStyles(t, r) : {}; return g ? g.buildStyles(t, r) : m } build(e, t, r, h, g, m, b, E, D, R) { const U = [], X = this.ast.options && this.ast.options.params || Rn, ne = b && b.params || Rn, Y = this.buildStyles(r, ne, U), K = E && E.params || Rn, ae = this.buildStyles(h, K, U), ve = new Set, ue = new Map, Ie = new Map, Fe = "void" === h, _s = { params: be(be({}, X), K) }, lt = R ? [] : On(e, t, this.ast.animation, g, m, Y, ae, _s, D, U); let Ce = 0; if (lt.forEach(Mt => { Ce = Math.max(Mt.duration + Mt.delay, Ce) }), U.length) return gi(t, this._triggerName, r, h, Fe, Y, ae, [], [], ue, Ie, Ce, U); lt.forEach(Mt => { const ke = Mt.element, xs = ee(ue, ke, {}); Mt.preStyleProps.forEach(ct => xs[ct] = !0); const Ts = ee(Ie, ke, {}); Mt.postStyleProps.forEach(ct => Ts[ct] = !0), ke !== t && ve.add(ke) }); const At = an(ve.values()); return gi(t, this._triggerName, r, h, Fe, Y, ae, lt, At, ue, Ie, Ce) } } class Bn { constructor(e, t, r) { this.styles = e, this.defaultParams = t, this.normalizer = r } buildStyles(e, t) { const r = {}, h = Ye(this.defaultParams); return Object.keys(e).forEach(g => { const m = e[g]; null != m && (h[g] = m) }), this.styles.styles.forEach(g => { if ("string" != typeof g) { const m = g; Object.keys(m).forEach(b => { let E = m[b]; E.length > 1 && (E = on(E, h, t)); const D = this.normalizer.normalizePropertyName(b, t); E = this.normalizer.normalizeStyleValue(b, D, E, t), r[D] = E }) } }), r } } class mi { constructor(e, t, r) { this.name = e, this.ast = t, this._normalizer = r, this.transitionFactories = [], this.states = {}, t.states.forEach(h => { const g = h.options && h.options.params || {}; this.states[h.name] = new Bn(h.style, g, r) }), fn(this.states, "true", "1"), fn(this.states, "false", "0"), t.transitions.forEach(h => { this.transitionFactories.push(new Gt(e, h, this.states)) }), this.fallbackTransition = function (u, e, t) { return new Gt(u, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(m, b) => !0], options: null, queryCount: 0, depCount: 0 }, e) }(e, this.states, this._normalizer) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(e, t, r, h) { return this.transitionFactories.find(m => m.match(e, t, r, h)) || null } matchStyles(e, t, r) { return this.fallbackTransition.buildStyles(e, t, r) } } function fn(u, e, t) { u.hasOwnProperty(e) ? u.hasOwnProperty(t) || (u[t] = u[e]) : u.hasOwnProperty(t) && (u[e] = u[t]) } const Gn = new hn; class Es { constructor(e, t, r) { this.bodyNode = e, this._driver = t, this._normalizer = r, this._animations = {}, this._playersById = {}, this.players = [] } register(e, t) { const r = [], h = Tn(this._driver, t, r); if (r.length) throw new Error(`Unable to build the animation due to the following errors: ${r.join("\n")}`); this._animations[e] = h } _buildPlayer(e, t, r) { const h = e.element, g = j(this._driver, this._normalizer, 0, e.keyframes, t, r); return this._driver.animate(h, g, e.duration, e.delay, e.easing, [], !0) } create(e, t, r = {}) { const h = [], g = this._animations[e]; let m; const b = new Map; if (g ? (m = On(this._driver, t, g, Js, en, {}, {}, r, Gn, h), m.forEach(R => { const U = ee(b, R.element, {}); R.postStyleProps.forEach(X => U[X] = null) })) : (h.push("The requested animation doesn't exist or has already been destroyed"), m = []), h.length) throw new Error(`Unable to create the animation due to the following errors: ${h.join("\n")}`); b.forEach((R, U) => { Object.keys(R).forEach(X => { R[X] = this._driver.computeStyle(U, X, v) }) }); const D = Me(m.map(R => { const U = b.get(R.element); return this._buildPlayer(R, {}, U) })); return this._playersById[e] = D, D.onDestroy(() => this.destroy(e)), this.players.push(D), D } destroy(e) { const t = this._getPlayer(e); t.destroy(), delete this._playersById[e]; const r = this.players.indexOf(t); r >= 0 && this.players.splice(r, 1) } _getPlayer(e) { const t = this._playersById[e]; if (!t) throw new Error(`Unable to find the timeline player referenced by ${e}`); return t } listen(e, t, r, h) { const g = se(t, "", "", ""); return G(this._getPlayer(e), r, g, h), () => { } } command(e, t, r, h) { if ("register" == r) return void this.register(e, h[0]); if ("create" == r) { const m = h[0] || {}; return void this.create(e, t, m) } const g = this._getPlayer(e); switch (r) { case "play": g.play(); break; case "pause": g.pause(); break; case "reset": g.reset(); break; case "restart": g.restart(); break; case "finish": g.finish(); break; case "init": g.init(); break; case "setPosition": g.setPosition(parseFloat(h[0])); break; case "destroy": this.destroy(e) } } } const Nn = "ng-animate-queued", xe = "ng-animate-disabled", pn = ".ng-animate-disabled", Et = [], rt = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, as = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, Ze = "__ng_removed"; class Nt { constructor(e, t = "") { this.namespaceId = t; const r = e && e.hasOwnProperty("value"), h = r ? e.value : e; if (this.value = null != (u = h) ? u : null, r) { const g = Ye(e); delete g.value, this.options = g } else this.options = {}; var u; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(e) { const t = e.params; if (t) { const r = this.options.params; Object.keys(t).forEach(h => { null == r[h] && (r[h] = t[h]) }) } } } const _t = "void", ls = new Nt(_t); class mn { constructor(e, t, r) { this.id = e, this.hostElement = t, this._engine = r, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, ot(t, this._hostClassName) } listen(e, t, r, h) { if (!this._triggers.hasOwnProperty(t)) throw new Error(`Unable to listen on the animation trigger event "${r}" because the animation trigger "${t}" doesn't exist!`); if (null == r || 0 == r.length) throw new Error(`Unable to listen on the animation trigger "${t}" because the provided event is undefined!`); if ("start" != (u = r) && "done" != u) throw new Error(`The provided animation trigger event "${r}" for the animation trigger "${t}" is not supported!`); var u; const g = ee(this._elementListeners, e, []), m = { name: t, phase: r, callback: h }; g.push(m); const b = ee(this._engine.statesByElement, e, {}); return b.hasOwnProperty(t) || (ot(e, tn), ot(e, tn + "-" + t), b[t] = ls), () => { this._engine.afterFlush(() => { const E = g.indexOf(m); E >= 0 && g.splice(E, 1), this._triggers[t] || delete b[t] }) } } register(e, t) { return !this._triggers[e] && (this._triggers[e] = t, !0) } _getTrigger(e) { const t = this._triggers[e]; if (!t) throw new Error(`The provided animation trigger "${e}" has not been registered!`); return t } trigger(e, t, r, h = !0) { const g = this._getTrigger(t), m = new cs(this.id, t, e); let b = this._engine.statesByElement.get(e); b || (ot(e, tn), ot(e, tn + "-" + t), this._engine.statesByElement.set(e, b = {})); let E = b[t]; const D = new Nt(r, this.id); if (!(r && r.hasOwnProperty("value")) && E && D.absorbOptions(E.options), b[t] = D, E || (E = ls), D.value !== _t && E.value === D.value) { if (!function (u, e) { const t = Object.keys(u), r = Object.keys(e); if (t.length != r.length) return !1; for (let h = 0; h < t.length; h++) { const g = t[h]; if (!e.hasOwnProperty(g) || u[g] !== e[g]) return !1 } return !0 }(E.params, D.params)) { const K = [], ae = g.matchStyles(E.value, E.params, K), ve = g.matchStyles(D.value, D.params, K); K.length ? this._engine.reportError(K) : this._engine.afterFlush(() => { qe(e, ae), ie(e, ve) }) } return } const X = ee(this._engine.playersByElement, e, []); X.forEach(K => { K.namespaceId == this.id && K.triggerName == t && K.queued && K.destroy() }); let ne = g.matchTransition(E.value, D.value, e, D.params), Y = !1; if (!ne) { if (!h) return; ne = g.fallbackTransition, Y = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: t, transition: ne, fromState: E, toState: D, player: m, isFallbackTransition: Y }), Y || (ot(e, Nn), m.onStart(() => { je(e, Nn) })), m.onDone(() => { let K = this.players.indexOf(m); K >= 0 && this.players.splice(K, 1); const ae = this._engine.playersByElement.get(e); if (ae) { let ve = ae.indexOf(m); ve >= 0 && ae.splice(ve, 1) } }), this.players.push(m), X.push(m), m } deregister(e) { delete this._triggers[e], this._engine.statesByElement.forEach((t, r) => { delete t[e] }), this._elementListeners.forEach((t, r) => { this._elementListeners.set(r, t.filter(h => h.name != e)) }) } clearElementCache(e) { this._engine.statesByElement.delete(e), this._elementListeners.delete(e); const t = this._engine.playersByElement.get(e); t && (t.forEach(r => r.destroy()), this._engine.playersByElement.delete(e)) } _signalRemovalForInnerTriggers(e, t) { const r = this._engine.driver.query(e, sn, !0); r.forEach(h => { if (h[Ze]) return; const g = this._engine.fetchNamespacesByElement(h); g.size ? g.forEach(m => m.triggerLeaveAnimation(h, t, !1, !0)) : this.clearElementCache(h) }), this._engine.afterFlushAnimationsDone(() => r.forEach(h => this.clearElementCache(h))) } triggerLeaveAnimation(e, t, r, h) { const g = this._engine.statesByElement.get(e); if (g) { const m = []; if (Object.keys(g).forEach(b => { if (this._triggers[b]) { const E = this.trigger(e, b, _t, h); E && m.push(E) } }), m.length) return this._engine.markElementAsRemoved(this.id, e, !0, t), r && Me(m).onDone(() => this._engine.processLeaveNode(e)), !0 } return !1 } prepareLeaveAnimationListeners(e) { const t = this._elementListeners.get(e), r = this._engine.statesByElement.get(e); if (t && r) { const h = new Set; t.forEach(g => { const m = g.name; if (h.has(m)) return; h.add(m); const E = this._triggers[m].fallbackTransition, D = r[m] || ls, R = new Nt(_t), U = new cs(this.id, m, e); this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: m, transition: E, fromState: D, toState: R, player: U, isFallbackTransition: !0 }) }) } } removeNode(e, t) { const r = this._engine; if (e.childElementCount && this._signalRemovalForInnerTriggers(e, t), this.triggerLeaveAnimation(e, t, !0)) return; let h = !1; if (r.totalAnimations) { const g = r.players.length ? r.playersByQueriedElement.get(e) : []; if (g && g.length) h = !0; else { let m = e; for (; m = m.parentNode;)if (r.statesByElement.get(m)) { h = !0; break } } } if (this.prepareLeaveAnimationListeners(e), h) r.markElementAsRemoved(this.id, e, !1, t); else { const g = e[Ze]; (!g || g === rt) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, t)) } } insertNode(e, t) { ot(e, this._hostClassName) } drainQueuedTransitions(e) { const t = []; return this._queue.forEach(r => { const h = r.player; if (h.destroyed) return; const g = r.element, m = this._elementListeners.get(g); m && m.forEach(b => { if (b.name == r.triggerName) { const E = se(g, r.triggerName, r.fromState.value, r.toState.value); E._data = e, G(r.player, b.phase, E, b.callback) } }), h.markedForDestroy ? this._engine.afterFlush(() => { h.destroy() }) : t.push(r) }), this._queue = [], t.sort((r, h) => { const g = r.transition.ast.depCount, m = h.transition.ast.depCount; return 0 == g || 0 == m ? g - m : this._engine.driver.containsElement(r.element, h.element) ? 1 : -1 }) } destroy(e) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e) } elementContainsData(e) { let t = !1; return this._elementListeners.has(e) && (t = !0), t = !!this._queue.find(r => r.element === e) || t, t } } class zt { constructor(e, t, r) { this.bodyNode = e, this.driver = t, this._normalizer = r, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (h, g) => { } } _onRemovalComplete(e, t) { this.onRemovalComplete(e, t) } get queuedPlayers() { const e = []; return this._namespaceList.forEach(t => { t.players.forEach(r => { r.queued && e.push(r) }) }), e } createNamespace(e, t) { const r = new mn(e, t, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, t) ? this._balanceNamespaceList(r, t) : (this.newHostElements.set(t, r), this.collectEnterElement(t)), this._namespaceLookup[e] = r } _balanceNamespaceList(e, t) { const r = this._namespaceList.length - 1; if (r >= 0) { let h = !1; for (let g = r; g >= 0; g--) { const m = this._namespaceList[g]; if (this.driver.containsElement(m.hostElement, t)) { this._namespaceList.splice(g + 1, 0, e), h = !0; break } } h || this._namespaceList.splice(0, 0, e) } else this._namespaceList.push(e); return this.namespacesByHostElement.set(t, e), e } register(e, t) { let r = this._namespaceLookup[e]; return r || (r = this.createNamespace(e, t)), r } registerTrigger(e, t, r) { let h = this._namespaceLookup[e]; h && h.register(t, r) && this.totalAnimations++ } destroy(e, t) { if (!e) return; const r = this._fetchNamespace(e); this.afterFlush(() => { this.namespacesByHostElement.delete(r.hostElement), delete this._namespaceLookup[e]; const h = this._namespaceList.indexOf(r); h >= 0 && this._namespaceList.splice(h, 1) }), this.afterFlushAnimationsDone(() => r.destroy(t)) } _fetchNamespace(e) { return this._namespaceLookup[e] } fetchNamespacesByElement(e) { const t = new Set, r = this.statesByElement.get(e); if (r) { const h = Object.keys(r); for (let g = 0; g < h.length; g++) { const m = r[h[g]].namespaceId; if (m) { const b = this._fetchNamespace(m); b && t.add(b) } } } return t } trigger(e, t, r, h) { if (we(t)) { const g = this._fetchNamespace(e); if (g) return g.trigger(t, r, h), !0 } return !1 } insertNode(e, t, r, h) { if (!we(t)) return; const g = t[Ze]; if (g && g.setForRemoval) { g.setForRemoval = !1, g.setForMove = !0; const m = this.collectedLeaveElements.indexOf(t); m >= 0 && this.collectedLeaveElements.splice(m, 1) } if (e) { const m = this._fetchNamespace(e); m && m.insertNode(t, r) } h && this.collectEnterElement(t) } collectEnterElement(e) { this.collectedEnterElements.push(e) } markElementAsDisabled(e, t) { t ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), ot(e, xe)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), je(e, xe)) } removeNode(e, t, r, h) { if (we(t)) { const g = e ? this._fetchNamespace(e) : null; if (g ? g.removeNode(t, h) : this.markElementAsRemoved(e, t, !1, h), r) { const m = this.namespacesByHostElement.get(t); m && m.id !== e && m.removeNode(t, h) } } else this._onRemovalComplete(t, h) } markElementAsRemoved(e, t, r, h) { this.collectedLeaveElements.push(t), t[Ze] = { namespaceId: e, setForRemoval: h, hasAnimation: r, removedBeforeQueried: !1 } } listen(e, t, r, h, g) { return we(t) ? this._fetchNamespace(e).listen(t, r, h, g) : () => { } } _buildInstruction(e, t, r, h, g) { return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, h, e.fromState.options, e.toState.options, t, g) } destroyInnerAnimations(e) { let t = this.driver.query(e, sn, !0); t.forEach(r => this.destroyActiveAnimationsForElement(r)), 0 != this.playersByQueriedElement.size && (t = this.driver.query(e, nn, !0), t.forEach(r => this.finishActiveQueriedAnimationOnElement(r))) } destroyActiveAnimationsForElement(e) { const t = this.playersByElement.get(e); t && t.forEach(r => { r.queued ? r.markedForDestroy = !0 : r.destroy() }) } finishActiveQueriedAnimationOnElement(e) { const t = this.playersByQueriedElement.get(e); t && t.forEach(r => r.finish()) } whenRenderingDone() { return new Promise(e => { if (this.players.length) return Me(this.players).onDone(() => e()); e() }) } processLeaveNode(e) { const t = e[Ze]; if (t && t.setForRemoval) { if (e[Ze] = rt, t.namespaceId) { this.destroyInnerAnimations(e); const r = this._fetchNamespace(t.namespaceId); r && r.clearElementCache(e) } this._onRemovalComplete(e, t.setForRemoval) } this.driver.matchesElement(e, pn) && this.markElementAsDisabled(e, !1), this.driver.query(e, pn, !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(e = -1) { let t = []; if (this.newHostElements.size && (this.newHostElements.forEach((r, h) => this._balanceNamespaceList(r, h)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let r = 0; r < this.collectedEnterElements.length; r++) { ot(this.collectedEnterElements[r], "ng-star-inserted") } if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const r = []; try { t = this._flushAnimations(r, e) } finally { for (let h = 0; h < r.length; h++)r[h]() } } else for (let r = 0; r < this.collectedLeaveElements.length; r++) { const h = this.collectedLeaveElements[r]; this.processLeaveNode(h) } if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) { const r = this._whenQuietFns; this._whenQuietFns = [], t.length ? Me(t).onDone(() => { r.forEach(h => h()) }) : r.forEach(h => h()) } } reportError(e) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${e.join("\n")}`) } _flushAnimations(e, t) { const r = new hn, h = [], g = new Map, m = [], b = new Map, E = new Map, D = new Map, R = new Set; this.disabledNodes.forEach(B => { R.add(B); const $ = this.driver.query(B, ".ng-animate-queued", !0); for (let H = 0; H < $.length; H++)R.add($[H]) }); const U = this.bodyNode, X = Array.from(this.statesByElement.keys()), ne = yi(X, this.collectedEnterElements), Y = new Map; let K = 0; ne.forEach((B, $) => { const H = Js + K++; Y.set($, H), B.forEach(re => ot(re, H)) }); const ae = [], ve = new Set, ue = new Set; for (let B = 0; B < this.collectedLeaveElements.length; B++) { const $ = this.collectedLeaveElements[B], H = $[Ze]; H && H.setForRemoval && (ae.push($), ve.add($), H.hasAnimation ? this.driver.query($, ".ng-star-inserted", !0).forEach(re => ve.add(re)) : ue.add($)) } const Ie = new Map, Fe = yi(X, Array.from(ve)); Fe.forEach((B, $) => { const H = en + K++; Ie.set($, H), B.forEach(re => ot(re, H)) }), e.push(() => { ne.forEach((B, $) => { const H = Y.get($); B.forEach(re => je(re, H)) }), Fe.forEach((B, $) => { const H = Ie.get($); B.forEach(re => je(re, H)) }), ae.forEach(B => { this.processLeaveNode(B) }) }); const _s = [], lt = []; for (let B = this._namespaceList.length - 1; B >= 0; B--)this._namespaceList[B].drainQueuedTransitions(t).forEach(H => { const re = H.player, Ee = H.element; if (_s.push(re), this.collectedEnterElements.length) { const Te = Ee[Ze]; if (Te && Te.setForMove) return void re.destroy() } const dt = !U || !this.driver.containsElement(U, Ee), Oe = Ie.get(Ee), Zt = Y.get(Ee), ye = this._buildInstruction(H, r, Zt, Oe, dt); if (ye.errors && ye.errors.length) return void lt.push(ye); if (dt) return re.onStart(() => qe(Ee, ye.fromStyles)), re.onDestroy(() => ie(Ee, ye.toStyles)), void h.push(re); if (H.isFallbackTransition) return re.onStart(() => qe(Ee, ye.fromStyles)), re.onDestroy(() => ie(Ee, ye.toStyles)), void h.push(re); ye.timelines.forEach(Te => Te.stretchStartingKeyframe = !0), r.append(Ee, ye.timelines); const js = { instruction: ye, player: re, element: Ee }; m.push(js), ye.queriedElements.forEach(Te => ee(b, Te, []).push(re)), ye.preStyleProps.forEach((Te, Rt) => { const bn = Object.keys(Te); if (bn.length) { let ut = E.get(Rt); ut || E.set(Rt, ut = new Set), bn.forEach(S => ut.add(S)) } }), ye.postStyleProps.forEach((Te, Rt) => { const bn = Object.keys(Te); let ut = D.get(Rt); ut || D.set(Rt, ut = new Set), bn.forEach(S => ut.add(S)) }) }); if (lt.length) { const B = []; lt.forEach($ => { B.push(`@${$.triggerName} has failed due to:\n`), $.errors.forEach(H => B.push(`- ${H}\n`)) }), _s.forEach($ => $.destroy()), this.reportError(B) } const Ce = new Map, At = new Map; m.forEach(B => { const $ = B.element; r.has($) && (At.set($, $), this._beforeAnimationBuild(B.player.namespaceId, B.instruction, Ce)) }), h.forEach(B => { const $ = B.element; this._getPreviousPlayers($, !1, B.namespaceId, B.triggerName, null).forEach(re => { ee(Ce, $, []).push(re), re.destroy() }) }); const Mt = ae.filter(B => hs(B, E, D)), ke = new Map; yn(ke, this.driver, ue, D, v).forEach(B => { hs(B, E, D) && Mt.push(B) }); const Ts = new Map; ne.forEach((B, $) => { yn(Ts, this.driver, new Set(B), E, "!") }), Mt.forEach(B => { const $ = ke.get(B), H = Ts.get(B); ke.set(B, be(be({}, $), H)) }); const ct = [], qt = [], Fs = {}; m.forEach(B => { const { element: $, player: H, instruction: re } = B; if (r.has($)) { if (R.has($)) return H.onDestroy(() => ie($, re.toStyles)), H.disabled = !0, H.overrideTotalTime(re.totalTime), void h.push(H); let Ee = Fs; if (At.size > 1) { let Oe = $; const Zt = []; for (; Oe = Oe.parentNode;) { const ye = At.get(Oe); if (ye) { Ee = ye; break } Zt.push(Oe) } Zt.forEach(ye => At.set(ye, Ee)) } const dt = this._buildAnimation(H.namespaceId, re, Ce, g, Ts, ke); if (H.setRealPlayer(dt), Ee === Fs) ct.push(H); else { const Oe = this.playersByElement.get(Ee); Oe && Oe.length && (H.parentPlayer = Me(Oe)), h.push(H) } } else qe($, re.fromStyles), H.onDestroy(() => ie($, re.toStyles)), qt.push(H), R.has($) && h.push(H) }), qt.forEach(B => { const $ = g.get(B.element); if ($ && $.length) { const H = Me($); B.setRealPlayer(H) } }), h.forEach(B => { B.parentPlayer ? B.syncPlayerEvents(B.parentPlayer) : B.destroy() }); for (let B = 0; B < ae.length; B++) { const $ = ae[B], H = $[Ze]; if (je($, en), H && H.hasAnimation) continue; let re = []; if (b.size) { let dt = b.get($); dt && dt.length && re.push(...dt); let Oe = this.driver.query($, nn, !0); for (let Zt = 0; Zt < Oe.length; Zt++) { let ye = b.get(Oe[Zt]); ye && ye.length && re.push(...ye) } } const Ee = re.filter(dt => !dt.destroyed); Ee.length ? _i(this, $, Ee) : this.processLeaveNode($) } return ae.length = 0, ct.forEach(B => { this.players.push(B), B.onDone(() => { B.destroy(); const $ = this.players.indexOf(B); this.players.splice($, 1) }), B.play() }), ct } elementContainsData(e, t) { let r = !1; const h = t[Ze]; return h && h.setForRemoval && (r = !0), this.playersByElement.has(t) && (r = !0), this.playersByQueriedElement.has(t) && (r = !0), this.statesByElement.has(t) && (r = !0), this._fetchNamespace(e).elementContainsData(t) || r } afterFlush(e) { this._flushFns.push(e) } afterFlushAnimationsDone(e) { this._whenQuietFns.push(e) } _getPreviousPlayers(e, t, r, h, g) { let m = []; if (t) { const b = this.playersByQueriedElement.get(e); b && (m = b) } else { const b = this.playersByElement.get(e); if (b) { const E = !g || g == _t; b.forEach(D => { D.queued || !E && D.triggerName != h || m.push(D) }) } } return (r || h) && (m = m.filter(b => !(r && r != b.namespaceId || h && h != b.triggerName))), m } _beforeAnimationBuild(e, t, r) { const h = t.triggerName, g = t.element, m = t.isRemovalTransition ? void 0 : e, b = t.isRemovalTransition ? void 0 : h; for (const E of t.timelines) { const D = E.element, R = D !== g, U = ee(r, D, []); this._getPreviousPlayers(D, R, m, b, t.toState).forEach(ne => { const Y = ne.getRealPlayer(); Y.beforeDestroy && Y.beforeDestroy(), ne.destroy(), U.push(ne) }) } qe(g, t.fromStyles) } _buildAnimation(e, t, r, h, g, m) { const b = t.triggerName, E = t.element, D = [], R = new Set, U = new Set, X = t.timelines.map(Y => { const K = Y.element; R.add(K); const ae = K[Ze]; if (ae && ae.removedBeforeQueried) return new ze(Y.duration, Y.delay); const ve = K !== E, ue = function (u) { const e = []; return zn(u, e), e }((r.get(K) || Et).map(Ce => Ce.getRealPlayer())).filter(Ce => { const At = Ce; return !!At.element && At.element === K }), Ie = g.get(K), Fe = m.get(K), _s = j(this.driver, this._normalizer, 0, Y.keyframes, Ie, Fe), lt = this._buildPlayer(Y, _s, ue); if (Y.subTimeline && h && U.add(K), ve) { const Ce = new cs(e, b, K); Ce.setRealPlayer(lt), D.push(Ce) } return lt }); D.forEach(Y => { ee(this.playersByQueriedElement, Y.element, []).push(Y), Y.onDone(() => function (u, e, t) { let r; if (u instanceof Map) { if (r = u.get(e), r) { if (r.length) { const h = r.indexOf(t); r.splice(h, 1) } 0 == r.length && u.delete(e) } } else if (r = u[e], r) { if (r.length) { const h = r.indexOf(t); r.splice(h, 1) } 0 == r.length && delete u[e] } return r }(this.playersByQueriedElement, Y.element, Y)) }), R.forEach(Y => ot(Y, ii)); const ne = Me(X); return ne.onDestroy(() => { R.forEach(Y => je(Y, ii)), ie(E, t.toStyles) }), U.forEach(Y => { ee(h, Y, []).push(ne) }), ne } _buildPlayer(e, t, r) { return t.length > 0 ? this.driver.animate(e.element, t, e.duration, e.delay, e.easing, r) : new ze(e.duration, e.delay) } } class cs { constructor(e, t, r) { this.namespaceId = e, this.triggerName = t, this.element = r, this._player = new ze, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(e) { this._containsRealPlayer || (this._player = e, Object.keys(this._queuedCallbacks).forEach(t => { this._queuedCallbacks[t].forEach(r => G(e, t, void 0, r)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(e) { this.totalTime = e } syncPlayerEvents(e) { const t = this._player; t.triggerCallback && e.onStart(() => t.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy()) } _queueEvent(e, t) { ee(this._queuedCallbacks, e, []).push(t) } onDone(e) { this.queued && this._queueEvent("done", e), this._player.onDone(e) } onStart(e) { this.queued && this._queueEvent("start", e), this._player.onStart(e) } onDestroy(e) { this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(e) { this.queued || this._player.setPosition(e) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(e) { const t = this._player; t.triggerCallback && t.triggerCallback(e) } } function we(u) { return u && 1 === u.nodeType } function Us(u, e) { const t = u.style.display; return u.style.display = null != e ? e : "none", t } function yn(u, e, t, r, h) { const g = []; t.forEach(E => g.push(Us(E))); const m = []; r.forEach((E, D) => { const R = {}; E.forEach(U => { const X = R[U] = e.computeStyle(D, U, h); (!X || 0 == X.length) && (D[Ze] = as, m.push(D)) }), u.set(D, R) }); let b = 0; return t.forEach(E => Us(E, g[b++])), m } function yi(u, e) { const t = new Map; if (u.forEach(b => t.set(b, [])), 0 == e.length) return t; const h = new Set(e), g = new Map; function m(b) { if (!b) return 1; let E = g.get(b); if (E) return E; const D = b.parentNode; return E = t.has(D) ? D : h.has(D) ? 1 : m(D), g.set(b, E), E } return e.forEach(b => { const E = m(b); 1 !== E && t.get(E).push(b) }), t } const ds = "$$classes"; function ot(u, e) { if (u.classList) u.classList.add(e); else { let t = u[ds]; t || (t = u[ds] = {}), t[e] = !0 } } function je(u, e) { if (u.classList) u.classList.remove(e); else { let t = u[ds]; t && delete t[e] } } function _i(u, e, t) { Me(t).onDone(() => u.processLeaveNode(e)) } function zn(u, e) { for (let t = 0; t < u.length; t++) { const r = u[t]; r instanceof bt ? zn(r.players, e) : e.push(r) } } function hs(u, e, t) { const r = t.get(u); if (!r) return !1; let h = e.get(u); return h ? r.forEach(g => h.add(g)) : e.set(u, r), t.delete(u), !0 } class wt { constructor(e, t, r) { this.bodyNode = e, this._driver = t, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (h, g) => { }, this._transitionEngine = new zt(e, t, r), this._timelineEngine = new Es(e, t, r), this._transitionEngine.onRemovalComplete = (h, g) => this.onRemovalComplete(h, g) } registerTrigger(e, t, r, h, g) { const m = e + "-" + h; let b = this._triggerCache[m]; if (!b) { const E = [], D = Tn(this._driver, g, E); if (E.length) throw new Error(`The animation trigger "${h}" has failed to build due to the following errors:\n - ${E.join("\n - ")}`); b = function (u, e, t) { return new mi(u, e, t) }(h, D, this._normalizer), this._triggerCache[m] = b } this._transitionEngine.registerTrigger(t, h, b) } register(e, t) { this._transitionEngine.register(e, t) } destroy(e, t) { this._transitionEngine.destroy(e, t) } onInsert(e, t, r, h) { this._transitionEngine.insertNode(e, t, r, h) } onRemove(e, t, r, h) { this._transitionEngine.removeNode(e, t, h || !1, r) } disableAnimations(e, t) { this._transitionEngine.markElementAsDisabled(e, t) } process(e, t, r, h) { if ("@" == r.charAt(0)) { const [g, m] = gt(r), b = h; this._timelineEngine.command(g, t, m, b) } else this._transitionEngine.trigger(e, t, r, h) } listen(e, t, r, h, g) { if ("@" == r.charAt(0)) { const [m, b] = gt(r); return this._timelineEngine.listen(m, t, b, g) } return this._transitionEngine.listen(e, t, r, h, g) } flush(e = -1) { this._transitionEngine.flush(e) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function Un(u, e) { let t = null, r = null; return Array.isArray(e) && e.length ? (t = Vs(e[0]), e.length > 1 && (r = Vs(e[e.length - 1]))) : e && (t = Vs(e)), t || r ? new Ut(u, t, r) : null } class Ut { constructor(e, t, r) { this._element = e, this._startStyles = t, this._endStyles = r, this._state = 0; let h = Ut.initialStylesByElement.get(e); h || Ut.initialStylesByElement.set(e, h = {}), this._initialStyles = h } start() { this._state < 1 && (this._startStyles && ie(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (ie(this._element, this._initialStyles), this._endStyles && (ie(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (Ut.initialStylesByElement.delete(this._element), this._startStyles && (qe(this._element, this._startStyles), this._endStyles = null), this._endStyles && (qe(this._element, this._endStyles), this._endStyles = null), ie(this._element, this._initialStyles), this._state = 3) } } function Vs(u) { let e = null; const t = Object.keys(u); for (let r = 0; r < t.length; r++) { const h = t[r]; xi(h) && (e = e || {}, e[h] = u[h]) } return e } function xi(u) { return "display" === u || "position" === u } Ut.initialStylesByElement = new WeakMap; const Vn = "animation", Yn = "animationend"; class Ys { constructor(e, t, r, h, g, m, b) { this._element = e, this._name = t, this._duration = r, this._delay = h, this._easing = g, this._fillMode = m, this._onDoneFn = b, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = E => this._handleCallback(E) } apply() { (function (u, e) { const t = _n(u, "").trim(); let r = 0; t.length && (r = function (u, e) { let t = 0; for (let r = 0; r < u.length; r++)u.charAt(r) === e && t++; return t }(t, ",") + 1, e = `${t}, ${e}`), Cs(u, "", e) })(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Ot(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Yt(this._element, this._name, "paused") } resume() { Yt(this._element, this._name, "running") } setPosition(e) { const t = gs(this._element, this._name); this._position = e * this._duration, Cs(this._element, "Delay", `-${this._position}ms`, t) } getPosition() { return this._position } _handleCallback(e) { const t = e._ngTestManualTimestamp || Date.now(), r = 1e3 * parseFloat(e.elapsedTime.toFixed(3)); e.animationName == this._name && Math.max(t - this._startTime, 0) >= this._delay && r >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), Ot(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (u, e) { const r = _n(u, "").split(","), h = at(r, e); if (h >= 0) { r.splice(h, 1); Cs(u, "", r.join(",")) } }(this._element, this._name)) } } function Yt(u, e, t) { Cs(u, "PlayState", t, gs(u, e)) } function gs(u, e) { const t = _n(u, ""); if (t.indexOf(",") > 0) { return at(t.split(","), e) } return at([t], e) } function at(u, e) { for (let t = 0; t < u.length; t++)if (u[t].indexOf(e) >= 0) return t; return -1 } function Ot(u, e, t) { t ? u.removeEventListener(Yn, e) : u.addEventListener(Yn, e) } function Cs(u, e, t, r) { const h = Vn + e; if (null != r) { const g = u.style[h]; if (g.length) { const m = g.split(","); m[r] = t, t = m.join(",") } } u.style[h] = t } function _n(u, e) { return u.style[Vn + e] || "" } class Kt { constructor(e, t, r, h, g, m, b, E) { this.element = e, this.keyframes = t, this.animationName = r, this._duration = h, this._delay = g, this._finalStyles = b, this._specialStyles = E, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = m || "linear", this.totalTime = h + g, this._buildStyler() } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } destroy() { this.init(), !(this._state >= 4) && (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(e => e()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(e => e()), this._onStartFns = [] } finish() { this.init(), !(this._state >= 3) && (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(e) { this._styler.setPosition(e) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { if (this._state >= 1) return; this._state = 1; this.element; this._styler.apply(), this._delay && this._styler.pause() } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Ys(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(e) { const t = "start" == e ? this._onStartFns : this._onDoneFns; t.forEach(r => r()), t.length = 0 } beforeDestroy() { this.init(); const e = {}; if (this.hasStarted()) { const t = this._state >= 3; Object.keys(this._finalStyles).forEach(r => { "offset" != r && (e[r] = t ? this._finalStyles[r] : pt(this.element, r)) }) } this.currentSnapshot = e } } class Vi extends ze { constructor(e, t) { super(), this.element = e, this._startingStyles = {}, this.__initialized = !1, this._styles = vs(t) } init() { this.__initialized || !this._startingStyles || (this.__initialized = !0, Object.keys(this._styles).forEach(e => { this._startingStyles[e] = this.element.style[e] }), super.init()) } play() { !this._startingStyles || (this.init(), Object.keys(this._styles).forEach(e => this.element.style.setProperty(e, this._styles[e])), super.play()) } destroy() { !this._startingStyles || (Object.keys(this._startingStyles).forEach(e => { const t = this._startingStyles[e]; t ? this.element.style.setProperty(e, t) : this.element.style.removeProperty(e) }), this._startingStyles = null, super.destroy()) } } class Je { constructor() { this._count = 0 } validateStyleProperty(e) { return Ue(e) } matchesElement(e, t) { return Dt(e, t) } containsElement(e, t) { return qs(e, t) } query(e, t, r) { return Zs(e, t, r) } computeStyle(e, t, r) { return window.getComputedStyle(e)[t] } buildKeyframeElement(e, t, r) { r = r.map(b => vs(b)); let h = `@keyframes ${t} {\n`, g = ""; r.forEach(b => { g = " "; const E = parseFloat(b.offset); h += `${g}${100 * E}% {\n`, g += " ", Object.keys(b).forEach(D => { const R = b[D]; switch (D) { case "offset": return; case "easing": return void (R && (h += `${g}animation-timing-function: ${R};\n`)); default: return void (h += `${g}${D}: ${R};\n`) } }), h += `${g}}\n` }), h += "}\n"; const m = document.createElement("style"); return m.textContent = h, m } animate(e, t, r, h, g, m = [], b) { const E = m.filter(ae => ae instanceof Kt), D = {}; Dn(r, h) && E.forEach(ae => { let ve = ae.currentSnapshot; Object.keys(ve).forEach(ue => D[ue] = ve[ue]) }); const R = function (u) { let e = {}; return u && (Array.isArray(u) ? u : [u]).forEach(r => { Object.keys(r).forEach(h => { "offset" == h || "easing" == h || (e[h] = r[h]) }) }), e }(t = In(e, t, D)); if (0 == r) return new Vi(e, R); const U = "gen_css_kf_" + this._count++, X = this.buildKeyframeElement(e, U, t); (function (u) { var t; const e = null == (t = u.getRootNode) ? void 0 : t.call(u); return "undefined" != typeof ShadowRoot && e instanceof ShadowRoot ? e : document.head })(e).appendChild(X); const Y = Un(e, t), K = new Kt(e, t, U, r, h, g, R, Y); return K.onDestroy(() => { var u; (u = X).parentNode.removeChild(u) }), K } } class xn { constructor(e, t, r, h) { this.element = e, this.keyframes = t, this.options = r, this._specialStyles = h, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const e = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(e, t, r) { return e.animate(t, r) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } setPosition(e) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = e * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const e = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(t => { "offset" != t && (e[t] = this._finished ? this._finalKeyframe[t] : pt(this.element, t)) }), this.currentSnapshot = e } triggerCallback(e) { const t = "start" == e ? this._onStartFns : this._onDoneFns; t.forEach(r => r()), t.length = 0 } } class bi { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(He().toString()), this._cssKeyframesDriver = new Je } validateStyleProperty(e) { return Ue(e) } matchesElement(e, t) { return Dt(e, t) } containsElement(e, t) { return qs(e, t) } query(e, t, r) { return Zs(e, t, r) } computeStyle(e, t, r) { return window.getComputedStyle(e)[t] } overrideWebAnimationsSupport(e) { this._isNativeImpl = e } animate(e, t, r, h, g, m = [], b) { if (!b && !this._isNativeImpl) return this._cssKeyframesDriver.animate(e, t, r, h, g, m); const R = { duration: r, delay: h, fill: 0 == h ? "both" : "forwards" }; g && (R.easing = g); const U = {}, X = m.filter(Y => Y instanceof xn); Dn(r, h) && X.forEach(Y => { let K = Y.currentSnapshot; Object.keys(K).forEach(ae => U[ae] = K[ae]) }); const ne = Un(e, t = In(e, t = t.map(Y => St(Y, !1)), U)); return new xn(e, t, R, ne) } } function He() { return fe() && Element.prototype.animate || {} } var fs = I(8267); class Wt extends k { constructor(e, t) { super(), this._nextAnimationId = 0; const r = { id: "0", encapsulation: a.ifc.None, styles: [], data: { animation: [] } }; this._renderer = e.createRenderer(t.body, r) } build(e) { const t = this._nextAnimationId.toString(); this._nextAnimationId++; const r = Array.isArray(e) ? F(e) : e; return Qn(this._renderer, null, t, "register", [r]), new jn(t, this._renderer) } } Wt.\u0275fac = function (e) { return new (e || Wt)(a.LFG(a.FYo), a.LFG(fs.K0)) }, Wt.\u0275prov = a.Yz7({ token: Wt, factory: Wt.\u0275fac }); class jn extends class { }{ constructor(e, t) { super(), this._id = e, this._renderer = t } create(e, t) { return new Hn(this._id, e, t || {}, this._renderer) } } class Hn { constructor(e, t, r, h) { this.id = e, this.element = t, this._renderer = h, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", r) } _listen(e, t) { return this._renderer.listen(this.element, `@@${this.id}:${e}`, t) } _command(e, ...t) { return Qn(this._renderer, this.element, this.id, e, t) } onDone(e) { this._listen("done", e) } onStart(e) { this._listen("start", e) } onDestroy(e) { this._listen("destroy", e) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(e) { this._command("setPosition", e) } getPosition() { var e, t; return null != (t = null == (e = this._renderer.engine.players[+this.id]) ? void 0 : e.getPosition()) ? t : 0 } } function Qn(u, e, t, r, h) { return u.setProperty(e, `@@${t}:${r}`, h) } const Wn = "@.disabled"; class ps { constructor(e, t, r) { this.delegate = e, this.engine = t, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), t.onRemovalComplete = (h, g) => { const m = null == g ? void 0 : g.parentNode(h); m && g.removeChild(m, h) } } createRenderer(e, t) { const h = this.delegate.createRenderer(e, t); if (!(e && t && t.data && t.data.animation)) { let D = this._rendererCache.get(h); return D || (D = new Si("", h, this.engine), this._rendererCache.set(h, D)), D } const g = t.id, m = t.id + "-" + this._currentId; this._currentId++, this.engine.register(m, e); const b = D => { Array.isArray(D) ? D.forEach(b) : this.engine.registerTrigger(g, m, e, D.name, D) }; return t.data.animation.forEach(b), new ms(this, m, h, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(e, t, r) { e >= 0 && e < this._microtaskId ? this._zone.run(() => t(r)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(h => { const [g, m] = h; g(m) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([t, r])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } ps.\u0275fac = function (e) { return new (e || ps)(a.LFG(a.FYo), a.LFG(wt), a.LFG(a.R0b)) }, ps.\u0275prov = a.Yz7({ token: ps, factory: ps.\u0275fac }); class Si { constructor(e, t, r) { this.namespaceId = e, this.delegate = t, this.engine = r, this.destroyNode = this.delegate.destroyNode ? h => t.destroyNode(h) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(e, t) { return this.delegate.createElement(e, t) } createComment(e) { return this.delegate.createComment(e) } createText(e) { return this.delegate.createText(e) } appendChild(e, t) { this.delegate.appendChild(e, t), this.engine.onInsert(this.namespaceId, t, e, !1) } insertBefore(e, t, r, h = !0) { this.delegate.insertBefore(e, t, r), this.engine.onInsert(this.namespaceId, t, e, h) } removeChild(e, t, r) { this.engine.onRemove(this.namespaceId, t, this.delegate, r) } selectRootElement(e, t) { return this.delegate.selectRootElement(e, t) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setAttribute(e, t, r, h) { this.delegate.setAttribute(e, t, r, h) } removeAttribute(e, t, r) { this.delegate.removeAttribute(e, t, r) } addClass(e, t) { this.delegate.addClass(e, t) } removeClass(e, t) { this.delegate.removeClass(e, t) } setStyle(e, t, r, h) { this.delegate.setStyle(e, t, r, h) } removeStyle(e, t, r) { this.delegate.removeStyle(e, t, r) } setProperty(e, t, r) { "@" == t.charAt(0) && t == Wn ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, t, r) } setValue(e, t) { this.delegate.setValue(e, t) } listen(e, t, r) { return this.delegate.listen(e, t, r) } disableAnimations(e, t) { this.engine.disableAnimations(e, t) } } class ms extends Si { constructor(e, t, r, h) { super(t, r, h), this.factory = e, this.namespaceId = t } setProperty(e, t, r) { "@" == t.charAt(0) ? "." == t.charAt(1) && t == Wn ? (r = void 0 === r || !!r, this.disableAnimations(e, r)) : this.engine.process(this.namespaceId, e, t.substr(1), r) : this.delegate.setProperty(e, t, r) } listen(e, t, r) { if ("@" == t.charAt(0)) { const h = function (u) { switch (u) { case "body": return document.body; case "document": return document; case "window": return window; default: return u } }(e); let g = t.substr(1), m = ""; return "@" != g.charAt(0) && ([g, m] = function (u) { const e = u.indexOf("."), t = u.substring(0, e), r = u.substr(e + 1); return [t, r] }(g)), this.engine.listen(this.namespaceId, h, g, m, b => { const E = b._data || -1; this.factory.scheduleListenerCallback(E, r, b) }) } return this.delegate.listen(e, t, r) } } class Qe extends wt { constructor(e, t, r) { super(e.body, t, r) } ngOnDestroy() { this.flush() } } Qe.\u0275fac = function (e) { return new (e || Qe)(a.LFG(fs.K0), a.LFG(Xs), a.LFG(hi)) }, Qe.\u0275prov = a.Yz7({ token: Qe, factory: Qe.\u0275fac }); const wi = new a.OlP("AnimationModuleType"), ys = [{ provide: k, useClass: Wt }, { provide: hi, useFactory: function () { return new os } }, { provide: wt, useClass: Qe }, { provide: a.FYo, useFactory: function (u, e, t) { return new ps(u, e, t) }, deps: [O.se, wt, a.R0b] }], Ci = [{ provide: Xs, useFactory: function () { return "function" == typeof He() ? new bi : new Je } }, { provide: wi, useValue: "BrowserAnimations" }, ...ys], An = [{ provide: Xs, useClass: es }, { provide: wi, useValue: "NoopAnimations" }, ...ys]; class kt { static withConfig(e) { return { ngModule: kt, providers: e.disableAnimations ? An : Ci } } } kt.\u0275fac = function (e) { return new (e || kt) }, kt.\u0275mod = a.oAB({ type: kt }), kt.\u0275inj = a.cJS({ providers: Ci, imports: [O.b2] }); class vt { } vt.\u0275fac = function (e) { return new (e || vt) }, vt.\u0275mod = a.oAB({ type: vt }), vt.\u0275inj = a.cJS({ providers: An, imports: [O.b2] }) }, 8094: (Ae, J, I) => { "use strict"; I.d(J, { c: () => bt, t: () => ee }); var a = I(3238), O = I(2270), v = (I(7797), I(4163), I(4001)), _ = (I(4243), I(6567)); const x = v.GuJ; const te = Symbol("__destroy"), oe = Symbol("__decoratorApplied"); function ce(N) { return "string" == typeof N ? Symbol(`__destroy__${N}`) : te } function De(N, W) { N[W] || (N[W] = new a.x) } function q(N, W) { N[W] && (N[W].next(), N[W].complete(), N[W] = null) } function tt(N) { N instanceof O.w0 && N.unsubscribe() } function st(N, W) { return function () { var de; if (N && N.call(this), q(this, ce()), W.arrayName && function (N) { Array.isArray(N) && N.forEach(tt) }(this[W.arrayName]), W.checkProperties) for (const V in this) (null == (de = W.blackList) ? void 0 : de.includes(V)) || tt(this[V]) } } function bt(N = {}) { return W => { !function (N) { return !!N[x] }(W) ? function (N, W) { N.prototype.ngOnDestroy = st(N.prototype.ngOnDestroy, W) }(W, N) : function (N, W) { const de = N.\u0275pipe; de.onDestroy = st(de.onDestroy, W) }(W, N), function (N) { N.prototype[oe] = !0 }(W) } } Symbol("CheckerHasBeenSet"); function ee(N, W) { return de => { const V = ce(W); "string" == typeof W ? function (N, W, de) { const V = N[W]; De(N, de), N[W] = function () { V.apply(this, arguments), q(this, de), N[W] = V } }(N, W, V) : De(N, V); const M = N[V]; return de.pipe((0, _.R)(M)) } } } }]);
//# sourceMappingURL=default-projects_browser-extension_src_app_components_ext-header_ext-header_component_ts-proj-ac64ab.js.map